/* tslint:disable */
/* eslint-disable */ // @ts-nocheck
/**
 * Jupiter API
 * Welcome to Jupiter\'s ClimateScore Global API
 *
 * The version of the OpenAPI document: 2.3.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AnalysisAggregateDataResponse,
  AnalysisLocationSelectionStrategyState,
  AnalysisSettingsWithMetadataResponse,
  AnalysisUpdateSettingsRequest,
  ErrorResponse,
  HTTPValidationError,
  LocationAnalysisData,
  LocationAssetAttributes,
  LocationIdsBody,
  UpdateBulkLocationSettingsBody,
  UpdateIndividualLocationSettingsBody,
} from '../models/index';
import {
    AnalysisAggregateDataResponseFromJSON,
    AnalysisAggregateDataResponseToJSON,
    AnalysisLocationSelectionStrategyStateFromJSON,
    AnalysisLocationSelectionStrategyStateToJSON,
    AnalysisSettingsWithMetadataResponseFromJSON,
    AnalysisSettingsWithMetadataResponseToJSON,
    AnalysisUpdateSettingsRequestFromJSON,
    AnalysisUpdateSettingsRequestToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    LocationAnalysisDataFromJSON,
    LocationAnalysisDataToJSON,
    LocationAssetAttributesFromJSON,
    LocationAssetAttributesToJSON,
    LocationIdsBodyFromJSON,
    LocationIdsBodyToJSON,
    UpdateBulkLocationSettingsBodyFromJSON,
    UpdateBulkLocationSettingsBodyToJSON,
    UpdateIndividualLocationSettingsBodyFromJSON,
    UpdateIndividualLocationSettingsBodyToJSON,
} from '../models/index';

export interface GetAdaptationAnalysisAdaptationAnalysisAnalysisIdGetRequest {
    analysisId: string;
}

export interface PostAdaptationAnalysisAdaptationAnalysisAnalysisIdPostRequest {
    analysisId: string;
    analysisUpdateSettingsRequest: AnalysisUpdateSettingsRequest;
}

export interface PostAdaptationAnalysisAggregateDataAdaptationAnalysisAnalysisIdAggregateDataPostRequest {
    analysisId: string;
    locationIdsBody: LocationIdsBody;
}

export interface PostAdaptationAnalysisIdLocationsDataAdaptationAnalysisAnalysisIdLocationsAnalysisDataPostRequest {
    analysisId: string;
    locationIdsBody: LocationIdsBody;
}

export interface PostAdaptationAnalysisLocationBulkAdaptationAnalysisAnalysisIdLocationsBulkPostRequest {
    analysisId: string;
    updateBulkLocationSettingsBody: UpdateBulkLocationSettingsBody;
}

export interface PostAdaptationAnalysisLocationIndividualAdaptationAnalysisAnalysisIdLocationsIndividualPostRequest {
    analysisId: string;
    updateIndividualLocationSettingsBody: UpdateIndividualLocationSettingsBody;
}

export interface PostAdaptationAnalysisLocationSelectionStrategyStateAdaptationAnalysisAnalysisIdLocationsStrategyStatePostRequest {
    analysisId: string;
    locationIdsBody: LocationIdsBody;
}

export interface PostAdaptationResultSetLocationsAdaptationAnalysisAnalysisIdLocationsAssetAttributesPostRequest {
    analysisId: string;
    locationIdsBody: LocationIdsBody;
}

/**
 * 
 */
export class AdaptationApi extends runtime.BaseAPI {

    /**
     * Get the analysis settings for the provided analysis.
     * Get Adaptation Analysis
     */
    async getAdaptationAnalysisAdaptationAnalysisAnalysisIdGetRaw(requestParameters: GetAdaptationAnalysisAdaptationAnalysisAnalysisIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnalysisSettingsWithMetadataResponse>> {
        if (requestParameters['analysisId'] == null) {
            throw new runtime.RequiredError(
                'analysisId',
                'Required parameter "analysisId" was null or undefined when calling getAdaptationAnalysisAdaptationAnalysisAnalysisIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/adaptation/analysis/{analysis_id}`.replace(`{${"analysis_id"}}`, encodeURIComponent(String(requestParameters['analysisId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisSettingsWithMetadataResponseFromJSON(jsonValue));
    }

    /**
     * Get the analysis settings for the provided analysis.
     * Get Adaptation Analysis
     */
    async getAdaptationAnalysisAdaptationAnalysisAnalysisIdGet(requestParameters: GetAdaptationAnalysisAdaptationAnalysisAnalysisIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnalysisSettingsWithMetadataResponse> {
        const response = await this.getAdaptationAnalysisAdaptationAnalysisAnalysisIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update analysis settings.
     * Post Adaptation Analysis
     */
    async postAdaptationAnalysisAdaptationAnalysisAnalysisIdPostRaw(requestParameters: PostAdaptationAnalysisAdaptationAnalysisAnalysisIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnalysisSettingsWithMetadataResponse>> {
        if (requestParameters['analysisId'] == null) {
            throw new runtime.RequiredError(
                'analysisId',
                'Required parameter "analysisId" was null or undefined when calling postAdaptationAnalysisAdaptationAnalysisAnalysisIdPost().'
            );
        }

        if (requestParameters['analysisUpdateSettingsRequest'] == null) {
            throw new runtime.RequiredError(
                'analysisUpdateSettingsRequest',
                'Required parameter "analysisUpdateSettingsRequest" was null or undefined when calling postAdaptationAnalysisAdaptationAnalysisAnalysisIdPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/adaptation/analysis/{analysis_id}`.replace(`{${"analysis_id"}}`, encodeURIComponent(String(requestParameters['analysisId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AnalysisUpdateSettingsRequestToJSON(requestParameters['analysisUpdateSettingsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisSettingsWithMetadataResponseFromJSON(jsonValue));
    }

    /**
     * Update analysis settings.
     * Post Adaptation Analysis
     */
    async postAdaptationAnalysisAdaptationAnalysisAnalysisIdPost(requestParameters: PostAdaptationAnalysisAdaptationAnalysisAnalysisIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnalysisSettingsWithMetadataResponse> {
        const response = await this.postAdaptationAnalysisAdaptationAnalysisAnalysisIdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get key performance indicators and timeseries data for the analysis. Data is computed based on the stored settings for each location and the analysis settings. KPIs are seen across the application, and some of the asset selection summary screen. Timeseries data is for each analysis year, and drives the AAL progression and capex timelines.
     * Post Adaptation Analysis Aggregate Data
     */
    async postAdaptationAnalysisAggregateDataAdaptationAnalysisAnalysisIdAggregateDataPostRaw(requestParameters: PostAdaptationAnalysisAggregateDataAdaptationAnalysisAnalysisIdAggregateDataPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnalysisAggregateDataResponse>> {
        if (requestParameters['analysisId'] == null) {
            throw new runtime.RequiredError(
                'analysisId',
                'Required parameter "analysisId" was null or undefined when calling postAdaptationAnalysisAggregateDataAdaptationAnalysisAnalysisIdAggregateDataPost().'
            );
        }

        if (requestParameters['locationIdsBody'] == null) {
            throw new runtime.RequiredError(
                'locationIdsBody',
                'Required parameter "locationIdsBody" was null or undefined when calling postAdaptationAnalysisAggregateDataAdaptationAnalysisAnalysisIdAggregateDataPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/adaptation/analysis/{analysis_id}/aggregate_data`.replace(`{${"analysis_id"}}`, encodeURIComponent(String(requestParameters['analysisId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LocationIdsBodyToJSON(requestParameters['locationIdsBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisAggregateDataResponseFromJSON(jsonValue));
    }

    /**
     * Get key performance indicators and timeseries data for the analysis. Data is computed based on the stored settings for each location and the analysis settings. KPIs are seen across the application, and some of the asset selection summary screen. Timeseries data is for each analysis year, and drives the AAL progression and capex timelines.
     * Post Adaptation Analysis Aggregate Data
     */
    async postAdaptationAnalysisAggregateDataAdaptationAnalysisAnalysisIdAggregateDataPost(requestParameters: PostAdaptationAnalysisAggregateDataAdaptationAnalysisAnalysisIdAggregateDataPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnalysisAggregateDataResponse> {
        const response = await this.postAdaptationAnalysisAggregateDataAdaptationAnalysisAnalysisIdAggregateDataPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get location data for the result set. Drives the investment matrix. Data is computed based on the stored settings for each location.
     * Post Adaptation Analysis Id Locations Data
     */
    async postAdaptationAnalysisIdLocationsDataAdaptationAnalysisAnalysisIdLocationsAnalysisDataPostRaw(requestParameters: PostAdaptationAnalysisIdLocationsDataAdaptationAnalysisAnalysisIdLocationsAnalysisDataPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<LocationAnalysisData>>> {
        if (requestParameters['analysisId'] == null) {
            throw new runtime.RequiredError(
                'analysisId',
                'Required parameter "analysisId" was null or undefined when calling postAdaptationAnalysisIdLocationsDataAdaptationAnalysisAnalysisIdLocationsAnalysisDataPost().'
            );
        }

        if (requestParameters['locationIdsBody'] == null) {
            throw new runtime.RequiredError(
                'locationIdsBody',
                'Required parameter "locationIdsBody" was null or undefined when calling postAdaptationAnalysisIdLocationsDataAdaptationAnalysisAnalysisIdLocationsAnalysisDataPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/adaptation/analysis/{analysis_id}/locations/analysis_data`.replace(`{${"analysis_id"}}`, encodeURIComponent(String(requestParameters['analysisId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LocationIdsBodyToJSON(requestParameters['locationIdsBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LocationAnalysisDataFromJSON));
    }

    /**
     * Get location data for the result set. Drives the investment matrix. Data is computed based on the stored settings for each location.
     * Post Adaptation Analysis Id Locations Data
     */
    async postAdaptationAnalysisIdLocationsDataAdaptationAnalysisAnalysisIdLocationsAnalysisDataPost(requestParameters: PostAdaptationAnalysisIdLocationsDataAdaptationAnalysisAnalysisIdLocationsAnalysisDataPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<LocationAnalysisData>> {
        const response = await this.postAdaptationAnalysisIdLocationsDataAdaptationAnalysisAnalysisIdLocationsAnalysisDataPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update location settings for the analysis.
     * Post Adaptation Analysis Location Bulk
     */
    async postAdaptationAnalysisLocationBulkAdaptationAnalysisAnalysisIdLocationsBulkPostRaw(requestParameters: PostAdaptationAnalysisLocationBulkAdaptationAnalysisAnalysisIdLocationsBulkPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['analysisId'] == null) {
            throw new runtime.RequiredError(
                'analysisId',
                'Required parameter "analysisId" was null or undefined when calling postAdaptationAnalysisLocationBulkAdaptationAnalysisAnalysisIdLocationsBulkPost().'
            );
        }

        if (requestParameters['updateBulkLocationSettingsBody'] == null) {
            throw new runtime.RequiredError(
                'updateBulkLocationSettingsBody',
                'Required parameter "updateBulkLocationSettingsBody" was null or undefined when calling postAdaptationAnalysisLocationBulkAdaptationAnalysisAnalysisIdLocationsBulkPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/adaptation/analysis/{analysis_id}/locations/bulk`.replace(`{${"analysis_id"}}`, encodeURIComponent(String(requestParameters['analysisId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateBulkLocationSettingsBodyToJSON(requestParameters['updateBulkLocationSettingsBody']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Update location settings for the analysis.
     * Post Adaptation Analysis Location Bulk
     */
    async postAdaptationAnalysisLocationBulkAdaptationAnalysisAnalysisIdLocationsBulkPost(requestParameters: PostAdaptationAnalysisLocationBulkAdaptationAnalysisAnalysisIdLocationsBulkPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.postAdaptationAnalysisLocationBulkAdaptationAnalysisAnalysisIdLocationsBulkPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update location settings for the analysis.
     * Post Adaptation Analysis Location Individual
     */
    async postAdaptationAnalysisLocationIndividualAdaptationAnalysisAnalysisIdLocationsIndividualPostRaw(requestParameters: PostAdaptationAnalysisLocationIndividualAdaptationAnalysisAnalysisIdLocationsIndividualPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['analysisId'] == null) {
            throw new runtime.RequiredError(
                'analysisId',
                'Required parameter "analysisId" was null or undefined when calling postAdaptationAnalysisLocationIndividualAdaptationAnalysisAnalysisIdLocationsIndividualPost().'
            );
        }

        if (requestParameters['updateIndividualLocationSettingsBody'] == null) {
            throw new runtime.RequiredError(
                'updateIndividualLocationSettingsBody',
                'Required parameter "updateIndividualLocationSettingsBody" was null or undefined when calling postAdaptationAnalysisLocationIndividualAdaptationAnalysisAnalysisIdLocationsIndividualPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/adaptation/analysis/{analysis_id}/locations/individual`.replace(`{${"analysis_id"}}`, encodeURIComponent(String(requestParameters['analysisId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateIndividualLocationSettingsBodyToJSON(requestParameters['updateIndividualLocationSettingsBody']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Update location settings for the analysis.
     * Post Adaptation Analysis Location Individual
     */
    async postAdaptationAnalysisLocationIndividualAdaptationAnalysisAnalysisIdLocationsIndividualPost(requestParameters: PostAdaptationAnalysisLocationIndividualAdaptationAnalysisAnalysisIdLocationsIndividualPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.postAdaptationAnalysisLocationIndividualAdaptationAnalysisAnalysisIdLocationsIndividualPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get strategy settings resolved for the provided selection of locations. Used by the sidecar.
     * Post Adaptation Analysis Location Selection Strategy State
     */
    async postAdaptationAnalysisLocationSelectionStrategyStateAdaptationAnalysisAnalysisIdLocationsStrategyStatePostRaw(requestParameters: PostAdaptationAnalysisLocationSelectionStrategyStateAdaptationAnalysisAnalysisIdLocationsStrategyStatePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AnalysisLocationSelectionStrategyState>> {
        if (requestParameters['analysisId'] == null) {
            throw new runtime.RequiredError(
                'analysisId',
                'Required parameter "analysisId" was null or undefined when calling postAdaptationAnalysisLocationSelectionStrategyStateAdaptationAnalysisAnalysisIdLocationsStrategyStatePost().'
            );
        }

        if (requestParameters['locationIdsBody'] == null) {
            throw new runtime.RequiredError(
                'locationIdsBody',
                'Required parameter "locationIdsBody" was null or undefined when calling postAdaptationAnalysisLocationSelectionStrategyStateAdaptationAnalysisAnalysisIdLocationsStrategyStatePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/adaptation/analysis/{analysis_id}/locations/strategy_state`.replace(`{${"analysis_id"}}`, encodeURIComponent(String(requestParameters['analysisId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LocationIdsBodyToJSON(requestParameters['locationIdsBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisLocationSelectionStrategyStateFromJSON(jsonValue));
    }

    /**
     * Get strategy settings resolved for the provided selection of locations. Used by the sidecar.
     * Post Adaptation Analysis Location Selection Strategy State
     */
    async postAdaptationAnalysisLocationSelectionStrategyStateAdaptationAnalysisAnalysisIdLocationsStrategyStatePost(requestParameters: PostAdaptationAnalysisLocationSelectionStrategyStateAdaptationAnalysisAnalysisIdLocationsStrategyStatePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AnalysisLocationSelectionStrategyState> {
        const response = await this.postAdaptationAnalysisLocationSelectionStrategyStateAdaptationAnalysisAnalysisIdLocationsStrategyStatePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get locations for the result set. Drives the asset selection screen. Data is static.
     * Post Adaptation Result Set Locations
     */
    async postAdaptationResultSetLocationsAdaptationAnalysisAnalysisIdLocationsAssetAttributesPostRaw(requestParameters: PostAdaptationResultSetLocationsAdaptationAnalysisAnalysisIdLocationsAssetAttributesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<LocationAssetAttributes>>> {
        if (requestParameters['analysisId'] == null) {
            throw new runtime.RequiredError(
                'analysisId',
                'Required parameter "analysisId" was null or undefined when calling postAdaptationResultSetLocationsAdaptationAnalysisAnalysisIdLocationsAssetAttributesPost().'
            );
        }

        if (requestParameters['locationIdsBody'] == null) {
            throw new runtime.RequiredError(
                'locationIdsBody',
                'Required parameter "locationIdsBody" was null or undefined when calling postAdaptationResultSetLocationsAdaptationAnalysisAnalysisIdLocationsAssetAttributesPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/adaptation/analysis/{analysis_id}/locations/asset_attributes`.replace(`{${"analysis_id"}}`, encodeURIComponent(String(requestParameters['analysisId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LocationIdsBodyToJSON(requestParameters['locationIdsBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LocationAssetAttributesFromJSON));
    }

    /**
     * Get locations for the result set. Drives the asset selection screen. Data is static.
     * Post Adaptation Result Set Locations
     */
    async postAdaptationResultSetLocationsAdaptationAnalysisAnalysisIdLocationsAssetAttributesPost(requestParameters: PostAdaptationResultSetLocationsAdaptationAnalysisAnalysisIdLocationsAssetAttributesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<LocationAssetAttributes>> {
        const response = await this.postAdaptationResultSetLocationsAdaptationAnalysisAnalysisIdLocationsAssetAttributesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
