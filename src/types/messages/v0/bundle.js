/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const havocai = $root.havocai = (() => {

    /**
     * Namespace havocai.
     * @exports havocai
     * @namespace
     */
    const havocai = {};

    havocai.messages = (function() {

        /**
         * Namespace messages.
         * @memberof havocai
         * @namespace
         */
        const messages = {};

        messages.v0 = (function() {

            /**
             * Namespace v0.
             * @memberof havocai.messages
             * @namespace
             */
            const v0 = {};

            v0.PlayInstance = (function() {

                /**
                 * Properties of a PlayInstance.
                 * @memberof havocai.messages.v0
                 * @interface IPlayInstance
                 * @property {string|null} [id] PlayInstance id
                 * @property {havocai.messages.v0.ITeam|null} [team] PlayInstance team
                 * @property {Array.<havocai.messages.v0.ITaskInstance>|null} [tasks] PlayInstance tasks
                 * @property {Array.<havocai.messages.v0.IGeoFence>|null} [avoidZones] PlayInstance avoidZones
                 * @property {number|null} [avoidanceDistance] PlayInstance avoidanceDistance
                 */

                /**
                 * Constructs a new PlayInstance.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PlayInstance.
                 * @implements IPlayInstance
                 * @constructor
                 * @param {havocai.messages.v0.IPlayInstance=} [properties] Properties to set
                 */
                function PlayInstance(properties) {
                    this.tasks = [];
                    this.avoidZones = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlayInstance id.
                 * @member {string} id
                 * @memberof havocai.messages.v0.PlayInstance
                 * @instance
                 */
                PlayInstance.prototype.id = "";

                /**
                 * PlayInstance team.
                 * @member {havocai.messages.v0.ITeam|null|undefined} team
                 * @memberof havocai.messages.v0.PlayInstance
                 * @instance
                 */
                PlayInstance.prototype.team = null;

                /**
                 * PlayInstance tasks.
                 * @member {Array.<havocai.messages.v0.ITaskInstance>} tasks
                 * @memberof havocai.messages.v0.PlayInstance
                 * @instance
                 */
                PlayInstance.prototype.tasks = $util.emptyArray;

                /**
                 * PlayInstance avoidZones.
                 * @member {Array.<havocai.messages.v0.IGeoFence>} avoidZones
                 * @memberof havocai.messages.v0.PlayInstance
                 * @instance
                 */
                PlayInstance.prototype.avoidZones = $util.emptyArray;

                /**
                 * PlayInstance avoidanceDistance.
                 * @member {number} avoidanceDistance
                 * @memberof havocai.messages.v0.PlayInstance
                 * @instance
                 */
                PlayInstance.prototype.avoidanceDistance = 0;

                /**
                 * Creates a new PlayInstance instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PlayInstance
                 * @static
                 * @param {havocai.messages.v0.IPlayInstance=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PlayInstance} PlayInstance instance
                 */
                PlayInstance.create = function create(properties) {
                    return new PlayInstance(properties);
                };

                /**
                 * Encodes the specified PlayInstance message. Does not implicitly {@link havocai.messages.v0.PlayInstance.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PlayInstance
                 * @static
                 * @param {havocai.messages.v0.IPlayInstance} message PlayInstance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayInstance.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                        $root.havocai.messages.v0.Team.encode(message.team, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.tasks != null && message.tasks.length)
                        for (let i = 0; i < message.tasks.length; ++i)
                            $root.havocai.messages.v0.TaskInstance.encode(message.tasks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.avoidZones != null && message.avoidZones.length)
                        for (let i = 0; i < message.avoidZones.length; ++i)
                            $root.havocai.messages.v0.GeoFence.encode(message.avoidZones[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.avoidanceDistance != null && Object.hasOwnProperty.call(message, "avoidanceDistance"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.avoidanceDistance);
                    return writer;
                };

                /**
                 * Encodes the specified PlayInstance message, length delimited. Does not implicitly {@link havocai.messages.v0.PlayInstance.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PlayInstance
                 * @static
                 * @param {havocai.messages.v0.IPlayInstance} message PlayInstance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayInstance.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlayInstance message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PlayInstance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PlayInstance} PlayInstance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayInstance.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PlayInstance();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.id = reader.string();
                                break;
                            }
                        case 2: {
                                message.team = $root.havocai.messages.v0.Team.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                if (!(message.tasks && message.tasks.length))
                                    message.tasks = [];
                                message.tasks.push($root.havocai.messages.v0.TaskInstance.decode(reader, reader.uint32()));
                                break;
                            }
                        case 4: {
                                if (!(message.avoidZones && message.avoidZones.length))
                                    message.avoidZones = [];
                                message.avoidZones.push($root.havocai.messages.v0.GeoFence.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                message.avoidanceDistance = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlayInstance message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PlayInstance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PlayInstance} PlayInstance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayInstance.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlayInstance message.
                 * @function verify
                 * @memberof havocai.messages.v0.PlayInstance
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayInstance.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.team != null && message.hasOwnProperty("team")) {
                        let error = $root.havocai.messages.v0.Team.verify(message.team);
                        if (error)
                            return "team." + error;
                    }
                    if (message.tasks != null && message.hasOwnProperty("tasks")) {
                        if (!Array.isArray(message.tasks))
                            return "tasks: array expected";
                        for (let i = 0; i < message.tasks.length; ++i) {
                            let error = $root.havocai.messages.v0.TaskInstance.verify(message.tasks[i]);
                            if (error)
                                return "tasks." + error;
                        }
                    }
                    if (message.avoidZones != null && message.hasOwnProperty("avoidZones")) {
                        if (!Array.isArray(message.avoidZones))
                            return "avoidZones: array expected";
                        for (let i = 0; i < message.avoidZones.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoFence.verify(message.avoidZones[i]);
                            if (error)
                                return "avoidZones." + error;
                        }
                    }
                    if (message.avoidanceDistance != null && message.hasOwnProperty("avoidanceDistance"))
                        if (typeof message.avoidanceDistance !== "number")
                            return "avoidanceDistance: number expected";
                    return null;
                };

                /**
                 * Creates a PlayInstance message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PlayInstance
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PlayInstance} PlayInstance
                 */
                PlayInstance.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PlayInstance)
                        return object;
                    let message = new $root.havocai.messages.v0.PlayInstance();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.team != null) {
                        if (typeof object.team !== "object")
                            throw TypeError(".havocai.messages.v0.PlayInstance.team: object expected");
                        message.team = $root.havocai.messages.v0.Team.fromObject(object.team);
                    }
                    if (object.tasks) {
                        if (!Array.isArray(object.tasks))
                            throw TypeError(".havocai.messages.v0.PlayInstance.tasks: array expected");
                        message.tasks = [];
                        for (let i = 0; i < object.tasks.length; ++i) {
                            if (typeof object.tasks[i] !== "object")
                                throw TypeError(".havocai.messages.v0.PlayInstance.tasks: object expected");
                            message.tasks[i] = $root.havocai.messages.v0.TaskInstance.fromObject(object.tasks[i]);
                        }
                    }
                    if (object.avoidZones) {
                        if (!Array.isArray(object.avoidZones))
                            throw TypeError(".havocai.messages.v0.PlayInstance.avoidZones: array expected");
                        message.avoidZones = [];
                        for (let i = 0; i < object.avoidZones.length; ++i) {
                            if (typeof object.avoidZones[i] !== "object")
                                throw TypeError(".havocai.messages.v0.PlayInstance.avoidZones: object expected");
                            message.avoidZones[i] = $root.havocai.messages.v0.GeoFence.fromObject(object.avoidZones[i]);
                        }
                    }
                    if (object.avoidanceDistance != null)
                        message.avoidanceDistance = Number(object.avoidanceDistance);
                    return message;
                };

                /**
                 * Creates a plain object from a PlayInstance message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PlayInstance
                 * @static
                 * @param {havocai.messages.v0.PlayInstance} message PlayInstance
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayInstance.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.tasks = [];
                        object.avoidZones = [];
                    }
                    if (options.defaults) {
                        object.id = "";
                        object.team = null;
                        object.avoidanceDistance = 0;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.team != null && message.hasOwnProperty("team"))
                        object.team = $root.havocai.messages.v0.Team.toObject(message.team, options);
                    if (message.tasks && message.tasks.length) {
                        object.tasks = [];
                        for (let j = 0; j < message.tasks.length; ++j)
                            object.tasks[j] = $root.havocai.messages.v0.TaskInstance.toObject(message.tasks[j], options);
                    }
                    if (message.avoidZones && message.avoidZones.length) {
                        object.avoidZones = [];
                        for (let j = 0; j < message.avoidZones.length; ++j)
                            object.avoidZones[j] = $root.havocai.messages.v0.GeoFence.toObject(message.avoidZones[j], options);
                    }
                    if (message.avoidanceDistance != null && message.hasOwnProperty("avoidanceDistance"))
                        object.avoidanceDistance = options.json && !isFinite(message.avoidanceDistance) ? String(message.avoidanceDistance) : message.avoidanceDistance;
                    return object;
                };

                /**
                 * Converts this PlayInstance to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PlayInstance
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayInstance.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlayInstance
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PlayInstance
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlayInstance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PlayInstance";
                };

                return PlayInstance;
            })();

            v0.TaskInstance = (function() {

                /**
                 * Properties of a TaskInstance.
                 * @memberof havocai.messages.v0
                 * @interface ITaskInstance
                 * @property {havocai.messages.v0.ITaskExecution|null} [execution] TaskInstance execution
                 * @property {havocai.messages.v0.ITaskDefinition|null} [definition] TaskInstance definition
                 */

                /**
                 * Constructs a new TaskInstance.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a TaskInstance.
                 * @implements ITaskInstance
                 * @constructor
                 * @param {havocai.messages.v0.ITaskInstance=} [properties] Properties to set
                 */
                function TaskInstance(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TaskInstance execution.
                 * @member {havocai.messages.v0.ITaskExecution|null|undefined} execution
                 * @memberof havocai.messages.v0.TaskInstance
                 * @instance
                 */
                TaskInstance.prototype.execution = null;

                /**
                 * TaskInstance definition.
                 * @member {havocai.messages.v0.ITaskDefinition|null|undefined} definition
                 * @memberof havocai.messages.v0.TaskInstance
                 * @instance
                 */
                TaskInstance.prototype.definition = null;

                /**
                 * Creates a new TaskInstance instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.TaskInstance
                 * @static
                 * @param {havocai.messages.v0.ITaskInstance=} [properties] Properties to set
                 * @returns {havocai.messages.v0.TaskInstance} TaskInstance instance
                 */
                TaskInstance.create = function create(properties) {
                    return new TaskInstance(properties);
                };

                /**
                 * Encodes the specified TaskInstance message. Does not implicitly {@link havocai.messages.v0.TaskInstance.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.TaskInstance
                 * @static
                 * @param {havocai.messages.v0.ITaskInstance} message TaskInstance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskInstance.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.execution != null && Object.hasOwnProperty.call(message, "execution"))
                        $root.havocai.messages.v0.TaskExecution.encode(message.execution, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.definition != null && Object.hasOwnProperty.call(message, "definition"))
                        $root.havocai.messages.v0.TaskDefinition.encode(message.definition, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TaskInstance message, length delimited. Does not implicitly {@link havocai.messages.v0.TaskInstance.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.TaskInstance
                 * @static
                 * @param {havocai.messages.v0.ITaskInstance} message TaskInstance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskInstance.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TaskInstance message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.TaskInstance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.TaskInstance} TaskInstance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskInstance.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.TaskInstance();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.execution = $root.havocai.messages.v0.TaskExecution.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.definition = $root.havocai.messages.v0.TaskDefinition.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TaskInstance message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.TaskInstance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.TaskInstance} TaskInstance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskInstance.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TaskInstance message.
                 * @function verify
                 * @memberof havocai.messages.v0.TaskInstance
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskInstance.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.execution != null && message.hasOwnProperty("execution")) {
                        let error = $root.havocai.messages.v0.TaskExecution.verify(message.execution);
                        if (error)
                            return "execution." + error;
                    }
                    if (message.definition != null && message.hasOwnProperty("definition")) {
                        let error = $root.havocai.messages.v0.TaskDefinition.verify(message.definition);
                        if (error)
                            return "definition." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TaskInstance message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.TaskInstance
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.TaskInstance} TaskInstance
                 */
                TaskInstance.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.TaskInstance)
                        return object;
                    let message = new $root.havocai.messages.v0.TaskInstance();
                    if (object.execution != null) {
                        if (typeof object.execution !== "object")
                            throw TypeError(".havocai.messages.v0.TaskInstance.execution: object expected");
                        message.execution = $root.havocai.messages.v0.TaskExecution.fromObject(object.execution);
                    }
                    if (object.definition != null) {
                        if (typeof object.definition !== "object")
                            throw TypeError(".havocai.messages.v0.TaskInstance.definition: object expected");
                        message.definition = $root.havocai.messages.v0.TaskDefinition.fromObject(object.definition);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TaskInstance message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.TaskInstance
                 * @static
                 * @param {havocai.messages.v0.TaskInstance} message TaskInstance
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TaskInstance.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.execution = null;
                        object.definition = null;
                    }
                    if (message.execution != null && message.hasOwnProperty("execution"))
                        object.execution = $root.havocai.messages.v0.TaskExecution.toObject(message.execution, options);
                    if (message.definition != null && message.hasOwnProperty("definition"))
                        object.definition = $root.havocai.messages.v0.TaskDefinition.toObject(message.definition, options);
                    return object;
                };

                /**
                 * Converts this TaskInstance to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.TaskInstance
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TaskInstance.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TaskInstance
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.TaskInstance
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TaskInstance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.TaskInstance";
                };

                return TaskInstance;
            })();

            v0.PlayDefinitionSpec = (function() {

                /**
                 * Properties of a PlayDefinitionSpec.
                 * @memberof havocai.messages.v0
                 * @interface IPlayDefinitionSpec
                 * @property {Array.<havocai.messages.v0.ITaskDefinition>|null} [tasks] PlayDefinitionSpec tasks
                 */

                /**
                 * Constructs a new PlayDefinitionSpec.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PlayDefinitionSpec.
                 * @implements IPlayDefinitionSpec
                 * @constructor
                 * @param {havocai.messages.v0.IPlayDefinitionSpec=} [properties] Properties to set
                 */
                function PlayDefinitionSpec(properties) {
                    this.tasks = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlayDefinitionSpec tasks.
                 * @member {Array.<havocai.messages.v0.ITaskDefinition>} tasks
                 * @memberof havocai.messages.v0.PlayDefinitionSpec
                 * @instance
                 */
                PlayDefinitionSpec.prototype.tasks = $util.emptyArray;

                /**
                 * Creates a new PlayDefinitionSpec instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PlayDefinitionSpec
                 * @static
                 * @param {havocai.messages.v0.IPlayDefinitionSpec=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PlayDefinitionSpec} PlayDefinitionSpec instance
                 */
                PlayDefinitionSpec.create = function create(properties) {
                    return new PlayDefinitionSpec(properties);
                };

                /**
                 * Encodes the specified PlayDefinitionSpec message. Does not implicitly {@link havocai.messages.v0.PlayDefinitionSpec.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PlayDefinitionSpec
                 * @static
                 * @param {havocai.messages.v0.IPlayDefinitionSpec} message PlayDefinitionSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayDefinitionSpec.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.tasks != null && message.tasks.length)
                        for (let i = 0; i < message.tasks.length; ++i)
                            $root.havocai.messages.v0.TaskDefinition.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PlayDefinitionSpec message, length delimited. Does not implicitly {@link havocai.messages.v0.PlayDefinitionSpec.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PlayDefinitionSpec
                 * @static
                 * @param {havocai.messages.v0.IPlayDefinitionSpec} message PlayDefinitionSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayDefinitionSpec.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlayDefinitionSpec message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PlayDefinitionSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PlayDefinitionSpec} PlayDefinitionSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayDefinitionSpec.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PlayDefinitionSpec();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.tasks && message.tasks.length))
                                    message.tasks = [];
                                message.tasks.push($root.havocai.messages.v0.TaskDefinition.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlayDefinitionSpec message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PlayDefinitionSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PlayDefinitionSpec} PlayDefinitionSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayDefinitionSpec.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlayDefinitionSpec message.
                 * @function verify
                 * @memberof havocai.messages.v0.PlayDefinitionSpec
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayDefinitionSpec.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.tasks != null && message.hasOwnProperty("tasks")) {
                        if (!Array.isArray(message.tasks))
                            return "tasks: array expected";
                        for (let i = 0; i < message.tasks.length; ++i) {
                            let error = $root.havocai.messages.v0.TaskDefinition.verify(message.tasks[i]);
                            if (error)
                                return "tasks." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a PlayDefinitionSpec message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PlayDefinitionSpec
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PlayDefinitionSpec} PlayDefinitionSpec
                 */
                PlayDefinitionSpec.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PlayDefinitionSpec)
                        return object;
                    let message = new $root.havocai.messages.v0.PlayDefinitionSpec();
                    if (object.tasks) {
                        if (!Array.isArray(object.tasks))
                            throw TypeError(".havocai.messages.v0.PlayDefinitionSpec.tasks: array expected");
                        message.tasks = [];
                        for (let i = 0; i < object.tasks.length; ++i) {
                            if (typeof object.tasks[i] !== "object")
                                throw TypeError(".havocai.messages.v0.PlayDefinitionSpec.tasks: object expected");
                            message.tasks[i] = $root.havocai.messages.v0.TaskDefinition.fromObject(object.tasks[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlayDefinitionSpec message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PlayDefinitionSpec
                 * @static
                 * @param {havocai.messages.v0.PlayDefinitionSpec} message PlayDefinitionSpec
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayDefinitionSpec.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.tasks = [];
                    if (message.tasks && message.tasks.length) {
                        object.tasks = [];
                        for (let j = 0; j < message.tasks.length; ++j)
                            object.tasks[j] = $root.havocai.messages.v0.TaskDefinition.toObject(message.tasks[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this PlayDefinitionSpec to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PlayDefinitionSpec
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayDefinitionSpec.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlayDefinitionSpec
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PlayDefinitionSpec
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlayDefinitionSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PlayDefinitionSpec";
                };

                return PlayDefinitionSpec;
            })();

            v0.TaskDefinition = (function() {

                /**
                 * Properties of a TaskDefinition.
                 * @memberof havocai.messages.v0
                 * @interface ITaskDefinition
                 * @property {string|null} [id] TaskDefinition id
                 * @property {havocai.messages.v0.TaskType|null} [type] TaskDefinition type
                 * @property {string|null} [name] TaskDefinition name
                 * @property {Array.<havocai.messages.v0.IConditional>|null} [conditionals] TaskDefinition conditionals
                 */

                /**
                 * Constructs a new TaskDefinition.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a TaskDefinition.
                 * @implements ITaskDefinition
                 * @constructor
                 * @param {havocai.messages.v0.ITaskDefinition=} [properties] Properties to set
                 */
                function TaskDefinition(properties) {
                    this.conditionals = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TaskDefinition id.
                 * @member {string} id
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @instance
                 */
                TaskDefinition.prototype.id = "";

                /**
                 * TaskDefinition type.
                 * @member {havocai.messages.v0.TaskType} type
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @instance
                 */
                TaskDefinition.prototype.type = 0;

                /**
                 * TaskDefinition name.
                 * @member {string} name
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @instance
                 */
                TaskDefinition.prototype.name = "";

                /**
                 * TaskDefinition conditionals.
                 * @member {Array.<havocai.messages.v0.IConditional>} conditionals
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @instance
                 */
                TaskDefinition.prototype.conditionals = $util.emptyArray;

                /**
                 * Creates a new TaskDefinition instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @static
                 * @param {havocai.messages.v0.ITaskDefinition=} [properties] Properties to set
                 * @returns {havocai.messages.v0.TaskDefinition} TaskDefinition instance
                 */
                TaskDefinition.create = function create(properties) {
                    return new TaskDefinition(properties);
                };

                /**
                 * Encodes the specified TaskDefinition message. Does not implicitly {@link havocai.messages.v0.TaskDefinition.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @static
                 * @param {havocai.messages.v0.ITaskDefinition} message TaskDefinition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskDefinition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if (message.conditionals != null && message.conditionals.length)
                        for (let i = 0; i < message.conditionals.length; ++i)
                            $root.havocai.messages.v0.Conditional.encode(message.conditionals[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TaskDefinition message, length delimited. Does not implicitly {@link havocai.messages.v0.TaskDefinition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @static
                 * @param {havocai.messages.v0.ITaskDefinition} message TaskDefinition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskDefinition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TaskDefinition message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.TaskDefinition} TaskDefinition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskDefinition.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.TaskDefinition();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.id = reader.string();
                                break;
                            }
                        case 2: {
                                message.type = reader.int32();
                                break;
                            }
                        case 3: {
                                message.name = reader.string();
                                break;
                            }
                        case 4: {
                                if (!(message.conditionals && message.conditionals.length))
                                    message.conditionals = [];
                                message.conditionals.push($root.havocai.messages.v0.Conditional.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TaskDefinition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.TaskDefinition} TaskDefinition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskDefinition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TaskDefinition message.
                 * @function verify
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskDefinition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                            break;
                        }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.conditionals != null && message.hasOwnProperty("conditionals")) {
                        if (!Array.isArray(message.conditionals))
                            return "conditionals: array expected";
                        for (let i = 0; i < message.conditionals.length; ++i) {
                            let error = $root.havocai.messages.v0.Conditional.verify(message.conditionals[i]);
                            if (error)
                                return "conditionals." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TaskDefinition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.TaskDefinition} TaskDefinition
                 */
                TaskDefinition.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.TaskDefinition)
                        return object;
                    let message = new $root.havocai.messages.v0.TaskDefinition();
                    if (object.id != null)
                        message.id = String(object.id);
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "TASK_TYPE_UNSPECIFIED":
                    case 0:
                        message.type = 0;
                        break;
                    case "TASK_TYPE_ROUTE":
                    case 1:
                        message.type = 1;
                        break;
                    case "TASK_TYPE_SEARCH":
                    case 2:
                        message.type = 2;
                        break;
                    case "TASK_TYPE_ENGAGE":
                    case 3:
                        message.type = 3;
                        break;
                    case "TASK_TYPE_COOPERATIVE_FORMATION":
                    case 4:
                        message.type = 4;
                        break;
                    case "TASK_TYPE_GEO_FORMATION":
                    case 5:
                        message.type = 5;
                        break;
                    case "TASK_TYPE_ESCORT":
                    case 6:
                        message.type = 6;
                        break;
                    case "TASK_TYPE_CHECKOUT":
                    case 7:
                        message.type = 7;
                        break;
                    case "TASK_TYPE_PATROL":
                    case 8:
                        message.type = 8;
                        break;
                    case "TASK_TYPE_DRIFT":
                    case 9:
                        message.type = 9;
                        break;
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.conditionals) {
                        if (!Array.isArray(object.conditionals))
                            throw TypeError(".havocai.messages.v0.TaskDefinition.conditionals: array expected");
                        message.conditionals = [];
                        for (let i = 0; i < object.conditionals.length; ++i) {
                            if (typeof object.conditionals[i] !== "object")
                                throw TypeError(".havocai.messages.v0.TaskDefinition.conditionals: object expected");
                            message.conditionals[i] = $root.havocai.messages.v0.Conditional.fromObject(object.conditionals[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TaskDefinition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @static
                 * @param {havocai.messages.v0.TaskDefinition} message TaskDefinition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TaskDefinition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.conditionals = [];
                    if (options.defaults) {
                        object.id = "";
                        object.type = options.enums === String ? "TASK_TYPE_UNSPECIFIED" : 0;
                        object.name = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.havocai.messages.v0.TaskType[message.type] === undefined ? message.type : $root.havocai.messages.v0.TaskType[message.type] : message.type;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.conditionals && message.conditionals.length) {
                        object.conditionals = [];
                        for (let j = 0; j < message.conditionals.length; ++j)
                            object.conditionals[j] = $root.havocai.messages.v0.Conditional.toObject(message.conditionals[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this TaskDefinition to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TaskDefinition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TaskDefinition
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.TaskDefinition
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TaskDefinition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.TaskDefinition";
                };

                return TaskDefinition;
            })();

            v0.Conditional = (function() {

                /**
                 * Properties of a Conditional.
                 * @memberof havocai.messages.v0
                 * @interface IConditional
                 * @property {string|null} [id] Conditional id
                 * @property {havocai.messages.v0.ICommandConditional|null} [command] Conditional command
                 */

                /**
                 * Constructs a new Conditional.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Conditional.
                 * @implements IConditional
                 * @constructor
                 * @param {havocai.messages.v0.IConditional=} [properties] Properties to set
                 */
                function Conditional(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Conditional id.
                 * @member {string} id
                 * @memberof havocai.messages.v0.Conditional
                 * @instance
                 */
                Conditional.prototype.id = "";

                /**
                 * Conditional command.
                 * @member {havocai.messages.v0.ICommandConditional|null|undefined} command
                 * @memberof havocai.messages.v0.Conditional
                 * @instance
                 */
                Conditional.prototype.command = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Conditional conditional.
                 * @member {"command"|undefined} conditional
                 * @memberof havocai.messages.v0.Conditional
                 * @instance
                 */
                Object.defineProperty(Conditional.prototype, "conditional", {
                    get: $util.oneOfGetter($oneOfFields = ["command"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Conditional instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Conditional
                 * @static
                 * @param {havocai.messages.v0.IConditional=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Conditional} Conditional instance
                 */
                Conditional.create = function create(properties) {
                    return new Conditional(properties);
                };

                /**
                 * Encodes the specified Conditional message. Does not implicitly {@link havocai.messages.v0.Conditional.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Conditional
                 * @static
                 * @param {havocai.messages.v0.IConditional} message Conditional message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Conditional.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                        $root.havocai.messages.v0.CommandConditional.encode(message.command, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Conditional message, length delimited. Does not implicitly {@link havocai.messages.v0.Conditional.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Conditional
                 * @static
                 * @param {havocai.messages.v0.IConditional} message Conditional message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Conditional.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Conditional message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Conditional
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Conditional} Conditional
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Conditional.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Conditional();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.id = reader.string();
                                break;
                            }
                        case 2: {
                                message.command = $root.havocai.messages.v0.CommandConditional.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Conditional message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Conditional
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Conditional} Conditional
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Conditional.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Conditional message.
                 * @function verify
                 * @memberof havocai.messages.v0.Conditional
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Conditional.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.command != null && message.hasOwnProperty("command")) {
                        properties.conditional = 1;
                        {
                            let error = $root.havocai.messages.v0.CommandConditional.verify(message.command);
                            if (error)
                                return "command." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Conditional message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Conditional
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Conditional} Conditional
                 */
                Conditional.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Conditional)
                        return object;
                    let message = new $root.havocai.messages.v0.Conditional();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.command != null) {
                        if (typeof object.command !== "object")
                            throw TypeError(".havocai.messages.v0.Conditional.command: object expected");
                        message.command = $root.havocai.messages.v0.CommandConditional.fromObject(object.command);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Conditional message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Conditional
                 * @static
                 * @param {havocai.messages.v0.Conditional} message Conditional
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Conditional.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.id = "";
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.command != null && message.hasOwnProperty("command")) {
                        object.command = $root.havocai.messages.v0.CommandConditional.toObject(message.command, options);
                        if (options.oneofs)
                            object.conditional = "command";
                    }
                    return object;
                };

                /**
                 * Converts this Conditional to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Conditional
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Conditional.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Conditional
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Conditional
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Conditional.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Conditional";
                };

                return Conditional;
            })();

            v0.CommandConditional = (function() {

                /**
                 * Properties of a CommandConditional.
                 * @memberof havocai.messages.v0
                 * @interface ICommandConditional
                 * @property {havocai.messages.v0.Command|null} [targetCommand] CommandConditional targetCommand
                 */

                /**
                 * Constructs a new CommandConditional.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a CommandConditional.
                 * @implements ICommandConditional
                 * @constructor
                 * @param {havocai.messages.v0.ICommandConditional=} [properties] Properties to set
                 */
                function CommandConditional(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommandConditional targetCommand.
                 * @member {havocai.messages.v0.Command} targetCommand
                 * @memberof havocai.messages.v0.CommandConditional
                 * @instance
                 */
                CommandConditional.prototype.targetCommand = 0;

                /**
                 * Creates a new CommandConditional instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.CommandConditional
                 * @static
                 * @param {havocai.messages.v0.ICommandConditional=} [properties] Properties to set
                 * @returns {havocai.messages.v0.CommandConditional} CommandConditional instance
                 */
                CommandConditional.create = function create(properties) {
                    return new CommandConditional(properties);
                };

                /**
                 * Encodes the specified CommandConditional message. Does not implicitly {@link havocai.messages.v0.CommandConditional.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.CommandConditional
                 * @static
                 * @param {havocai.messages.v0.ICommandConditional} message CommandConditional message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandConditional.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.targetCommand != null && Object.hasOwnProperty.call(message, "targetCommand"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.targetCommand);
                    return writer;
                };

                /**
                 * Encodes the specified CommandConditional message, length delimited. Does not implicitly {@link havocai.messages.v0.CommandConditional.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.CommandConditional
                 * @static
                 * @param {havocai.messages.v0.ICommandConditional} message CommandConditional message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommandConditional.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommandConditional message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.CommandConditional
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.CommandConditional} CommandConditional
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandConditional.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.CommandConditional();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.targetCommand = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommandConditional message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.CommandConditional
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.CommandConditional} CommandConditional
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommandConditional.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommandConditional message.
                 * @function verify
                 * @memberof havocai.messages.v0.CommandConditional
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommandConditional.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.targetCommand != null && message.hasOwnProperty("targetCommand"))
                        switch (message.targetCommand) {
                        default:
                            return "targetCommand: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a CommandConditional message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.CommandConditional
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.CommandConditional} CommandConditional
                 */
                CommandConditional.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.CommandConditional)
                        return object;
                    let message = new $root.havocai.messages.v0.CommandConditional();
                    switch (object.targetCommand) {
                    default:
                        if (typeof object.targetCommand === "number") {
                            message.targetCommand = object.targetCommand;
                            break;
                        }
                        break;
                    case "COMMAND_UNKNOWN":
                    case 0:
                        message.targetCommand = 0;
                        break;
                    case "COMMAND_CANCEL":
                    case 1:
                        message.targetCommand = 1;
                        break;
                    case "COMMAND_GO":
                    case 2:
                        message.targetCommand = 2;
                        break;
                    case "COMMAND_AUTHORIZE":
                    case 3:
                        message.targetCommand = 3;
                        break;
                    case "COMMAND_CUSTOM":
                    case 4:
                        message.targetCommand = 4;
                        break;
                    case "COMMAND_AUTHORIZE_TASK":
                    case 5:
                        message.targetCommand = 5;
                        break;
                    case "COMMAND_EXECUTE_TASK":
                    case 6:
                        message.targetCommand = 6;
                        break;
                    case "COMMAND_TRIGGER_PAYLOAD":
                    case 7:
                        message.targetCommand = 7;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CommandConditional message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.CommandConditional
                 * @static
                 * @param {havocai.messages.v0.CommandConditional} message CommandConditional
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommandConditional.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.targetCommand = options.enums === String ? "COMMAND_UNKNOWN" : 0;
                    if (message.targetCommand != null && message.hasOwnProperty("targetCommand"))
                        object.targetCommand = options.enums === String ? $root.havocai.messages.v0.Command[message.targetCommand] === undefined ? message.targetCommand : $root.havocai.messages.v0.Command[message.targetCommand] : message.targetCommand;
                    return object;
                };

                /**
                 * Converts this CommandConditional to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.CommandConditional
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommandConditional.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for CommandConditional
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.CommandConditional
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                CommandConditional.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.CommandConditional";
                };

                return CommandConditional;
            })();

            v0.TaskExecution = (function() {

                /**
                 * Properties of a TaskExecution.
                 * @memberof havocai.messages.v0
                 * @interface ITaskExecution
                 * @property {string|null} [id] TaskExecution id
                 * @property {string|null} [taskDefinition] TaskExecution taskDefinition
                 * @property {havocai.messages.v0.IRouteParams|null} [route] TaskExecution route
                 * @property {havocai.messages.v0.ISearchParams|null} [search] TaskExecution search
                 * @property {havocai.messages.v0.IEngageParams|null} [engage] TaskExecution engage
                 * @property {havocai.messages.v0.IGeoFormationParams|null} [geoFormation] TaskExecution geoFormation
                 * @property {havocai.messages.v0.IEscortParams|null} [escort] TaskExecution escort
                 * @property {havocai.messages.v0.ICheckoutParams|null} [checkout] TaskExecution checkout
                 * @property {havocai.messages.v0.IPatrolParams|null} [patrol] TaskExecution patrol
                 * @property {havocai.messages.v0.IDriftParams|null} [drift] TaskExecution drift
                 */

                /**
                 * Constructs a new TaskExecution.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a TaskExecution.
                 * @implements ITaskExecution
                 * @constructor
                 * @param {havocai.messages.v0.ITaskExecution=} [properties] Properties to set
                 */
                function TaskExecution(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TaskExecution id.
                 * @member {string} id
                 * @memberof havocai.messages.v0.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.id = "";

                /**
                 * TaskExecution taskDefinition.
                 * @member {string} taskDefinition
                 * @memberof havocai.messages.v0.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.taskDefinition = "";

                /**
                 * TaskExecution route.
                 * @member {havocai.messages.v0.IRouteParams|null|undefined} route
                 * @memberof havocai.messages.v0.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.route = null;

                /**
                 * TaskExecution search.
                 * @member {havocai.messages.v0.ISearchParams|null|undefined} search
                 * @memberof havocai.messages.v0.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.search = null;

                /**
                 * TaskExecution engage.
                 * @member {havocai.messages.v0.IEngageParams|null|undefined} engage
                 * @memberof havocai.messages.v0.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.engage = null;

                /**
                 * TaskExecution geoFormation.
                 * @member {havocai.messages.v0.IGeoFormationParams|null|undefined} geoFormation
                 * @memberof havocai.messages.v0.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.geoFormation = null;

                /**
                 * TaskExecution escort.
                 * @member {havocai.messages.v0.IEscortParams|null|undefined} escort
                 * @memberof havocai.messages.v0.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.escort = null;

                /**
                 * TaskExecution checkout.
                 * @member {havocai.messages.v0.ICheckoutParams|null|undefined} checkout
                 * @memberof havocai.messages.v0.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.checkout = null;

                /**
                 * TaskExecution patrol.
                 * @member {havocai.messages.v0.IPatrolParams|null|undefined} patrol
                 * @memberof havocai.messages.v0.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.patrol = null;

                /**
                 * TaskExecution drift.
                 * @member {havocai.messages.v0.IDriftParams|null|undefined} drift
                 * @memberof havocai.messages.v0.TaskExecution
                 * @instance
                 */
                TaskExecution.prototype.drift = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * TaskExecution params.
                 * @member {"route"|"search"|"engage"|"geoFormation"|"escort"|"checkout"|"patrol"|"drift"|undefined} params
                 * @memberof havocai.messages.v0.TaskExecution
                 * @instance
                 */
                Object.defineProperty(TaskExecution.prototype, "params", {
                    get: $util.oneOfGetter($oneOfFields = ["route", "search", "engage", "geoFormation", "escort", "checkout", "patrol", "drift"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new TaskExecution instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.TaskExecution
                 * @static
                 * @param {havocai.messages.v0.ITaskExecution=} [properties] Properties to set
                 * @returns {havocai.messages.v0.TaskExecution} TaskExecution instance
                 */
                TaskExecution.create = function create(properties) {
                    return new TaskExecution(properties);
                };

                /**
                 * Encodes the specified TaskExecution message. Does not implicitly {@link havocai.messages.v0.TaskExecution.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.TaskExecution
                 * @static
                 * @param {havocai.messages.v0.ITaskExecution} message TaskExecution message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecution.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.taskDefinition != null && Object.hasOwnProperty.call(message, "taskDefinition"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.taskDefinition);
                    if (message.route != null && Object.hasOwnProperty.call(message, "route"))
                        $root.havocai.messages.v0.RouteParams.encode(message.route, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.search != null && Object.hasOwnProperty.call(message, "search"))
                        $root.havocai.messages.v0.SearchParams.encode(message.search, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.engage != null && Object.hasOwnProperty.call(message, "engage"))
                        $root.havocai.messages.v0.EngageParams.encode(message.engage, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.geoFormation != null && Object.hasOwnProperty.call(message, "geoFormation"))
                        $root.havocai.messages.v0.GeoFormationParams.encode(message.geoFormation, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.escort != null && Object.hasOwnProperty.call(message, "escort"))
                        $root.havocai.messages.v0.EscortParams.encode(message.escort, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.checkout != null && Object.hasOwnProperty.call(message, "checkout"))
                        $root.havocai.messages.v0.CheckoutParams.encode(message.checkout, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.patrol != null && Object.hasOwnProperty.call(message, "patrol"))
                        $root.havocai.messages.v0.PatrolParams.encode(message.patrol, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.drift != null && Object.hasOwnProperty.call(message, "drift"))
                        $root.havocai.messages.v0.DriftParams.encode(message.drift, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TaskExecution message, length delimited. Does not implicitly {@link havocai.messages.v0.TaskExecution.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.TaskExecution
                 * @static
                 * @param {havocai.messages.v0.ITaskExecution} message TaskExecution message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecution.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TaskExecution message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.TaskExecution
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.TaskExecution} TaskExecution
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecution.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.TaskExecution();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.id = reader.string();
                                break;
                            }
                        case 2: {
                                message.taskDefinition = reader.string();
                                break;
                            }
                        case 4: {
                                message.route = $root.havocai.messages.v0.RouteParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.search = $root.havocai.messages.v0.SearchParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 6: {
                                message.engage = $root.havocai.messages.v0.EngageParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 8: {
                                message.geoFormation = $root.havocai.messages.v0.GeoFormationParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 9: {
                                message.escort = $root.havocai.messages.v0.EscortParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 10: {
                                message.checkout = $root.havocai.messages.v0.CheckoutParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 11: {
                                message.patrol = $root.havocai.messages.v0.PatrolParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 12: {
                                message.drift = $root.havocai.messages.v0.DriftParams.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TaskExecution message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.TaskExecution
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.TaskExecution} TaskExecution
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecution.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TaskExecution message.
                 * @function verify
                 * @memberof havocai.messages.v0.TaskExecution
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecution.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.taskDefinition != null && message.hasOwnProperty("taskDefinition"))
                        if (!$util.isString(message.taskDefinition))
                            return "taskDefinition: string expected";
                    if (message.route != null && message.hasOwnProperty("route")) {
                        properties.params = 1;
                        {
                            let error = $root.havocai.messages.v0.RouteParams.verify(message.route);
                            if (error)
                                return "route." + error;
                        }
                    }
                    if (message.search != null && message.hasOwnProperty("search")) {
                        if (properties.params === 1)
                            return "params: multiple values";
                        properties.params = 1;
                        {
                            let error = $root.havocai.messages.v0.SearchParams.verify(message.search);
                            if (error)
                                return "search." + error;
                        }
                    }
                    if (message.engage != null && message.hasOwnProperty("engage")) {
                        if (properties.params === 1)
                            return "params: multiple values";
                        properties.params = 1;
                        {
                            let error = $root.havocai.messages.v0.EngageParams.verify(message.engage);
                            if (error)
                                return "engage." + error;
                        }
                    }
                    if (message.geoFormation != null && message.hasOwnProperty("geoFormation")) {
                        if (properties.params === 1)
                            return "params: multiple values";
                        properties.params = 1;
                        {
                            let error = $root.havocai.messages.v0.GeoFormationParams.verify(message.geoFormation);
                            if (error)
                                return "geoFormation." + error;
                        }
                    }
                    if (message.escort != null && message.hasOwnProperty("escort")) {
                        if (properties.params === 1)
                            return "params: multiple values";
                        properties.params = 1;
                        {
                            let error = $root.havocai.messages.v0.EscortParams.verify(message.escort);
                            if (error)
                                return "escort." + error;
                        }
                    }
                    if (message.checkout != null && message.hasOwnProperty("checkout")) {
                        if (properties.params === 1)
                            return "params: multiple values";
                        properties.params = 1;
                        {
                            let error = $root.havocai.messages.v0.CheckoutParams.verify(message.checkout);
                            if (error)
                                return "checkout." + error;
                        }
                    }
                    if (message.patrol != null && message.hasOwnProperty("patrol")) {
                        if (properties.params === 1)
                            return "params: multiple values";
                        properties.params = 1;
                        {
                            let error = $root.havocai.messages.v0.PatrolParams.verify(message.patrol);
                            if (error)
                                return "patrol." + error;
                        }
                    }
                    if (message.drift != null && message.hasOwnProperty("drift")) {
                        if (properties.params === 1)
                            return "params: multiple values";
                        properties.params = 1;
                        {
                            let error = $root.havocai.messages.v0.DriftParams.verify(message.drift);
                            if (error)
                                return "drift." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TaskExecution message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.TaskExecution
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.TaskExecution} TaskExecution
                 */
                TaskExecution.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.TaskExecution)
                        return object;
                    let message = new $root.havocai.messages.v0.TaskExecution();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.taskDefinition != null)
                        message.taskDefinition = String(object.taskDefinition);
                    if (object.route != null) {
                        if (typeof object.route !== "object")
                            throw TypeError(".havocai.messages.v0.TaskExecution.route: object expected");
                        message.route = $root.havocai.messages.v0.RouteParams.fromObject(object.route);
                    }
                    if (object.search != null) {
                        if (typeof object.search !== "object")
                            throw TypeError(".havocai.messages.v0.TaskExecution.search: object expected");
                        message.search = $root.havocai.messages.v0.SearchParams.fromObject(object.search);
                    }
                    if (object.engage != null) {
                        if (typeof object.engage !== "object")
                            throw TypeError(".havocai.messages.v0.TaskExecution.engage: object expected");
                        message.engage = $root.havocai.messages.v0.EngageParams.fromObject(object.engage);
                    }
                    if (object.geoFormation != null) {
                        if (typeof object.geoFormation !== "object")
                            throw TypeError(".havocai.messages.v0.TaskExecution.geoFormation: object expected");
                        message.geoFormation = $root.havocai.messages.v0.GeoFormationParams.fromObject(object.geoFormation);
                    }
                    if (object.escort != null) {
                        if (typeof object.escort !== "object")
                            throw TypeError(".havocai.messages.v0.TaskExecution.escort: object expected");
                        message.escort = $root.havocai.messages.v0.EscortParams.fromObject(object.escort);
                    }
                    if (object.checkout != null) {
                        if (typeof object.checkout !== "object")
                            throw TypeError(".havocai.messages.v0.TaskExecution.checkout: object expected");
                        message.checkout = $root.havocai.messages.v0.CheckoutParams.fromObject(object.checkout);
                    }
                    if (object.patrol != null) {
                        if (typeof object.patrol !== "object")
                            throw TypeError(".havocai.messages.v0.TaskExecution.patrol: object expected");
                        message.patrol = $root.havocai.messages.v0.PatrolParams.fromObject(object.patrol);
                    }
                    if (object.drift != null) {
                        if (typeof object.drift !== "object")
                            throw TypeError(".havocai.messages.v0.TaskExecution.drift: object expected");
                        message.drift = $root.havocai.messages.v0.DriftParams.fromObject(object.drift);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TaskExecution message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.TaskExecution
                 * @static
                 * @param {havocai.messages.v0.TaskExecution} message TaskExecution
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TaskExecution.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.taskDefinition = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.taskDefinition != null && message.hasOwnProperty("taskDefinition"))
                        object.taskDefinition = message.taskDefinition;
                    if (message.route != null && message.hasOwnProperty("route")) {
                        object.route = $root.havocai.messages.v0.RouteParams.toObject(message.route, options);
                        if (options.oneofs)
                            object.params = "route";
                    }
                    if (message.search != null && message.hasOwnProperty("search")) {
                        object.search = $root.havocai.messages.v0.SearchParams.toObject(message.search, options);
                        if (options.oneofs)
                            object.params = "search";
                    }
                    if (message.engage != null && message.hasOwnProperty("engage")) {
                        object.engage = $root.havocai.messages.v0.EngageParams.toObject(message.engage, options);
                        if (options.oneofs)
                            object.params = "engage";
                    }
                    if (message.geoFormation != null && message.hasOwnProperty("geoFormation")) {
                        object.geoFormation = $root.havocai.messages.v0.GeoFormationParams.toObject(message.geoFormation, options);
                        if (options.oneofs)
                            object.params = "geoFormation";
                    }
                    if (message.escort != null && message.hasOwnProperty("escort")) {
                        object.escort = $root.havocai.messages.v0.EscortParams.toObject(message.escort, options);
                        if (options.oneofs)
                            object.params = "escort";
                    }
                    if (message.checkout != null && message.hasOwnProperty("checkout")) {
                        object.checkout = $root.havocai.messages.v0.CheckoutParams.toObject(message.checkout, options);
                        if (options.oneofs)
                            object.params = "checkout";
                    }
                    if (message.patrol != null && message.hasOwnProperty("patrol")) {
                        object.patrol = $root.havocai.messages.v0.PatrolParams.toObject(message.patrol, options);
                        if (options.oneofs)
                            object.params = "patrol";
                    }
                    if (message.drift != null && message.hasOwnProperty("drift")) {
                        object.drift = $root.havocai.messages.v0.DriftParams.toObject(message.drift, options);
                        if (options.oneofs)
                            object.params = "drift";
                    }
                    return object;
                };

                /**
                 * Converts this TaskExecution to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.TaskExecution
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TaskExecution.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TaskExecution
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.TaskExecution
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TaskExecution.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.TaskExecution";
                };

                return TaskExecution;
            })();

            v0.RouteParams = (function() {

                /**
                 * Properties of a RouteParams.
                 * @memberof havocai.messages.v0
                 * @interface IRouteParams
                 * @property {havocai.messages.v0.IRoute|null} [route] RouteParams route
                 */

                /**
                 * Constructs a new RouteParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a RouteParams.
                 * @implements IRouteParams
                 * @constructor
                 * @param {havocai.messages.v0.IRouteParams=} [properties] Properties to set
                 */
                function RouteParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RouteParams route.
                 * @member {havocai.messages.v0.IRoute|null|undefined} route
                 * @memberof havocai.messages.v0.RouteParams
                 * @instance
                 */
                RouteParams.prototype.route = null;

                /**
                 * Creates a new RouteParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.RouteParams
                 * @static
                 * @param {havocai.messages.v0.IRouteParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.RouteParams} RouteParams instance
                 */
                RouteParams.create = function create(properties) {
                    return new RouteParams(properties);
                };

                /**
                 * Encodes the specified RouteParams message. Does not implicitly {@link havocai.messages.v0.RouteParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.RouteParams
                 * @static
                 * @param {havocai.messages.v0.IRouteParams} message RouteParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RouteParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.route != null && Object.hasOwnProperty.call(message, "route"))
                        $root.havocai.messages.v0.Route.encode(message.route, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RouteParams message, length delimited. Does not implicitly {@link havocai.messages.v0.RouteParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.RouteParams
                 * @static
                 * @param {havocai.messages.v0.IRouteParams} message RouteParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RouteParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RouteParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.RouteParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.RouteParams} RouteParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RouteParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.RouteParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.route = $root.havocai.messages.v0.Route.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RouteParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.RouteParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.RouteParams} RouteParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RouteParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RouteParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.RouteParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RouteParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.route != null && message.hasOwnProperty("route")) {
                        let error = $root.havocai.messages.v0.Route.verify(message.route);
                        if (error)
                            return "route." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RouteParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.RouteParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.RouteParams} RouteParams
                 */
                RouteParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.RouteParams)
                        return object;
                    let message = new $root.havocai.messages.v0.RouteParams();
                    if (object.route != null) {
                        if (typeof object.route !== "object")
                            throw TypeError(".havocai.messages.v0.RouteParams.route: object expected");
                        message.route = $root.havocai.messages.v0.Route.fromObject(object.route);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RouteParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.RouteParams
                 * @static
                 * @param {havocai.messages.v0.RouteParams} message RouteParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RouteParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.route = null;
                    if (message.route != null && message.hasOwnProperty("route"))
                        object.route = $root.havocai.messages.v0.Route.toObject(message.route, options);
                    return object;
                };

                /**
                 * Converts this RouteParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.RouteParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RouteParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for RouteParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.RouteParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                RouteParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.RouteParams";
                };

                return RouteParams;
            })();

            v0.SearchParams = (function() {

                /**
                 * Properties of a SearchParams.
                 * @memberof havocai.messages.v0
                 * @interface ISearchParams
                 * @property {havocai.messages.v0.IResourceRef|null} [zone] SearchParams zone
                 * @property {havocai.messages.v0.IPolygon|null} [polygon] SearchParams polygon
                 * @property {havocai.messages.v0.SearchStrategy|null} [searchStrategy] SearchParams searchStrategy
                 * @property {number|null} [targetSpeed] SearchParams targetSpeed
                 * @property {number|null} [sensorRadius] SearchParams sensorRadius
                 * @property {boolean|null} [indefiniteExecution] SearchParams indefiniteExecution
                 * @property {number|null} [altitude] SearchParams altitude
                 */

                /**
                 * Constructs a new SearchParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a SearchParams.
                 * @implements ISearchParams
                 * @constructor
                 * @param {havocai.messages.v0.ISearchParams=} [properties] Properties to set
                 */
                function SearchParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SearchParams zone.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} zone
                 * @memberof havocai.messages.v0.SearchParams
                 * @instance
                 */
                SearchParams.prototype.zone = null;

                /**
                 * SearchParams polygon.
                 * @member {havocai.messages.v0.IPolygon|null|undefined} polygon
                 * @memberof havocai.messages.v0.SearchParams
                 * @instance
                 */
                SearchParams.prototype.polygon = null;

                /**
                 * SearchParams searchStrategy.
                 * @member {havocai.messages.v0.SearchStrategy} searchStrategy
                 * @memberof havocai.messages.v0.SearchParams
                 * @instance
                 */
                SearchParams.prototype.searchStrategy = 0;

                /**
                 * SearchParams targetSpeed.
                 * @member {number} targetSpeed
                 * @memberof havocai.messages.v0.SearchParams
                 * @instance
                 */
                SearchParams.prototype.targetSpeed = 0;

                /**
                 * SearchParams sensorRadius.
                 * @member {number} sensorRadius
                 * @memberof havocai.messages.v0.SearchParams
                 * @instance
                 */
                SearchParams.prototype.sensorRadius = 0;

                /**
                 * SearchParams indefiniteExecution.
                 * @member {boolean} indefiniteExecution
                 * @memberof havocai.messages.v0.SearchParams
                 * @instance
                 */
                SearchParams.prototype.indefiniteExecution = false;

                /**
                 * SearchParams altitude.
                 * @member {number|null|undefined} altitude
                 * @memberof havocai.messages.v0.SearchParams
                 * @instance
                 */
                SearchParams.prototype.altitude = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * SearchParams searchArea.
                 * @member {"zone"|"polygon"|undefined} searchArea
                 * @memberof havocai.messages.v0.SearchParams
                 * @instance
                 */
                Object.defineProperty(SearchParams.prototype, "searchArea", {
                    get: $util.oneOfGetter($oneOfFields = ["zone", "polygon"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * SearchParams _altitude.
                 * @member {"altitude"|undefined} _altitude
                 * @memberof havocai.messages.v0.SearchParams
                 * @instance
                 */
                Object.defineProperty(SearchParams.prototype, "_altitude", {
                    get: $util.oneOfGetter($oneOfFields = ["altitude"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new SearchParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.SearchParams
                 * @static
                 * @param {havocai.messages.v0.ISearchParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.SearchParams} SearchParams instance
                 */
                SearchParams.create = function create(properties) {
                    return new SearchParams(properties);
                };

                /**
                 * Encodes the specified SearchParams message. Does not implicitly {@link havocai.messages.v0.SearchParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.SearchParams
                 * @static
                 * @param {havocai.messages.v0.ISearchParams} message SearchParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SearchParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.zone != null && Object.hasOwnProperty.call(message, "zone"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.zone, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.polygon != null && Object.hasOwnProperty.call(message, "polygon"))
                        $root.havocai.messages.v0.Polygon.encode(message.polygon, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.searchStrategy != null && Object.hasOwnProperty.call(message, "searchStrategy"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.searchStrategy);
                    if (message.targetSpeed != null && Object.hasOwnProperty.call(message, "targetSpeed"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.targetSpeed);
                    if (message.sensorRadius != null && Object.hasOwnProperty.call(message, "sensorRadius"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.sensorRadius);
                    if (message.indefiniteExecution != null && Object.hasOwnProperty.call(message, "indefiniteExecution"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.indefiniteExecution);
                    if (message.altitude != null && Object.hasOwnProperty.call(message, "altitude"))
                        writer.uint32(/* id 7, wireType 1 =*/57).double(message.altitude);
                    return writer;
                };

                /**
                 * Encodes the specified SearchParams message, length delimited. Does not implicitly {@link havocai.messages.v0.SearchParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.SearchParams
                 * @static
                 * @param {havocai.messages.v0.ISearchParams} message SearchParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SearchParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SearchParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.SearchParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.SearchParams} SearchParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SearchParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.SearchParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.zone = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.polygon = $root.havocai.messages.v0.Polygon.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.searchStrategy = reader.int32();
                                break;
                            }
                        case 4: {
                                message.targetSpeed = reader.float();
                                break;
                            }
                        case 5: {
                                message.sensorRadius = reader.float();
                                break;
                            }
                        case 6: {
                                message.indefiniteExecution = reader.bool();
                                break;
                            }
                        case 7: {
                                message.altitude = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SearchParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.SearchParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.SearchParams} SearchParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SearchParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SearchParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.SearchParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SearchParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.zone != null && message.hasOwnProperty("zone")) {
                        properties.searchArea = 1;
                        {
                            let error = $root.havocai.messages.v0.ResourceRef.verify(message.zone);
                            if (error)
                                return "zone." + error;
                        }
                    }
                    if (message.polygon != null && message.hasOwnProperty("polygon")) {
                        if (properties.searchArea === 1)
                            return "searchArea: multiple values";
                        properties.searchArea = 1;
                        {
                            let error = $root.havocai.messages.v0.Polygon.verify(message.polygon);
                            if (error)
                                return "polygon." + error;
                        }
                    }
                    if (message.searchStrategy != null && message.hasOwnProperty("searchStrategy"))
                        switch (message.searchStrategy) {
                        default:
                            return "searchStrategy: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        if (typeof message.targetSpeed !== "number")
                            return "targetSpeed: number expected";
                    if (message.sensorRadius != null && message.hasOwnProperty("sensorRadius"))
                        if (typeof message.sensorRadius !== "number")
                            return "sensorRadius: number expected";
                    if (message.indefiniteExecution != null && message.hasOwnProperty("indefiniteExecution"))
                        if (typeof message.indefiniteExecution !== "boolean")
                            return "indefiniteExecution: boolean expected";
                    if (message.altitude != null && message.hasOwnProperty("altitude")) {
                        properties._altitude = 1;
                        if (typeof message.altitude !== "number")
                            return "altitude: number expected";
                    }
                    return null;
                };

                /**
                 * Creates a SearchParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.SearchParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.SearchParams} SearchParams
                 */
                SearchParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.SearchParams)
                        return object;
                    let message = new $root.havocai.messages.v0.SearchParams();
                    if (object.zone != null) {
                        if (typeof object.zone !== "object")
                            throw TypeError(".havocai.messages.v0.SearchParams.zone: object expected");
                        message.zone = $root.havocai.messages.v0.ResourceRef.fromObject(object.zone);
                    }
                    if (object.polygon != null) {
                        if (typeof object.polygon !== "object")
                            throw TypeError(".havocai.messages.v0.SearchParams.polygon: object expected");
                        message.polygon = $root.havocai.messages.v0.Polygon.fromObject(object.polygon);
                    }
                    switch (object.searchStrategy) {
                    default:
                        if (typeof object.searchStrategy === "number") {
                            message.searchStrategy = object.searchStrategy;
                            break;
                        }
                        break;
                    case "SEARCH_STRATEGY_UNKNOWN":
                    case 0:
                        message.searchStrategy = 0;
                        break;
                    case "SEARCH_STRATEGY_RANDOM":
                    case 1:
                        message.searchStrategy = 1;
                        break;
                    case "SEARCH_STRATEGY_SWEEP":
                    case 2:
                        message.searchStrategy = 2;
                        break;
                    case "SEARCH_STRATEGY_SPIRAL":
                    case 3:
                        message.searchStrategy = 3;
                        break;
                    }
                    if (object.targetSpeed != null)
                        message.targetSpeed = Number(object.targetSpeed);
                    if (object.sensorRadius != null)
                        message.sensorRadius = Number(object.sensorRadius);
                    if (object.indefiniteExecution != null)
                        message.indefiniteExecution = Boolean(object.indefiniteExecution);
                    if (object.altitude != null)
                        message.altitude = Number(object.altitude);
                    return message;
                };

                /**
                 * Creates a plain object from a SearchParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.SearchParams
                 * @static
                 * @param {havocai.messages.v0.SearchParams} message SearchParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SearchParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.searchStrategy = options.enums === String ? "SEARCH_STRATEGY_UNKNOWN" : 0;
                        object.targetSpeed = 0;
                        object.sensorRadius = 0;
                        object.indefiniteExecution = false;
                    }
                    if (message.zone != null && message.hasOwnProperty("zone")) {
                        object.zone = $root.havocai.messages.v0.ResourceRef.toObject(message.zone, options);
                        if (options.oneofs)
                            object.searchArea = "zone";
                    }
                    if (message.polygon != null && message.hasOwnProperty("polygon")) {
                        object.polygon = $root.havocai.messages.v0.Polygon.toObject(message.polygon, options);
                        if (options.oneofs)
                            object.searchArea = "polygon";
                    }
                    if (message.searchStrategy != null && message.hasOwnProperty("searchStrategy"))
                        object.searchStrategy = options.enums === String ? $root.havocai.messages.v0.SearchStrategy[message.searchStrategy] === undefined ? message.searchStrategy : $root.havocai.messages.v0.SearchStrategy[message.searchStrategy] : message.searchStrategy;
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        object.targetSpeed = options.json && !isFinite(message.targetSpeed) ? String(message.targetSpeed) : message.targetSpeed;
                    if (message.sensorRadius != null && message.hasOwnProperty("sensorRadius"))
                        object.sensorRadius = options.json && !isFinite(message.sensorRadius) ? String(message.sensorRadius) : message.sensorRadius;
                    if (message.indefiniteExecution != null && message.hasOwnProperty("indefiniteExecution"))
                        object.indefiniteExecution = message.indefiniteExecution;
                    if (message.altitude != null && message.hasOwnProperty("altitude")) {
                        object.altitude = options.json && !isFinite(message.altitude) ? String(message.altitude) : message.altitude;
                        if (options.oneofs)
                            object._altitude = "altitude";
                    }
                    return object;
                };

                /**
                 * Converts this SearchParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.SearchParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SearchParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SearchParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.SearchParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SearchParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.SearchParams";
                };

                return SearchParams;
            })();

            v0.PatrolParams = (function() {

                /**
                 * Properties of a PatrolParams.
                 * @memberof havocai.messages.v0
                 * @interface IPatrolParams
                 * @property {havocai.messages.v0.IResourceRef|null} [zone] PatrolParams zone
                 * @property {havocai.messages.v0.IPolygon|null} [polygon] PatrolParams polygon
                 * @property {havocai.messages.v0.IRoute|null} [route] PatrolParams route
                 * @property {havocai.messages.v0.RotationDirection|null} [direction] PatrolParams direction
                 * @property {number|null} [targetSpeed] PatrolParams targetSpeed
                 * @property {number|null} [altitude] PatrolParams altitude
                 */

                /**
                 * Constructs a new PatrolParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PatrolParams.
                 * @implements IPatrolParams
                 * @constructor
                 * @param {havocai.messages.v0.IPatrolParams=} [properties] Properties to set
                 */
                function PatrolParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PatrolParams zone.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} zone
                 * @memberof havocai.messages.v0.PatrolParams
                 * @instance
                 */
                PatrolParams.prototype.zone = null;

                /**
                 * PatrolParams polygon.
                 * @member {havocai.messages.v0.IPolygon|null|undefined} polygon
                 * @memberof havocai.messages.v0.PatrolParams
                 * @instance
                 */
                PatrolParams.prototype.polygon = null;

                /**
                 * PatrolParams route.
                 * @member {havocai.messages.v0.IRoute|null|undefined} route
                 * @memberof havocai.messages.v0.PatrolParams
                 * @instance
                 */
                PatrolParams.prototype.route = null;

                /**
                 * PatrolParams direction.
                 * @member {havocai.messages.v0.RotationDirection} direction
                 * @memberof havocai.messages.v0.PatrolParams
                 * @instance
                 */
                PatrolParams.prototype.direction = 0;

                /**
                 * PatrolParams targetSpeed.
                 * @member {number} targetSpeed
                 * @memberof havocai.messages.v0.PatrolParams
                 * @instance
                 */
                PatrolParams.prototype.targetSpeed = 0;

                /**
                 * PatrolParams altitude.
                 * @member {number|null|undefined} altitude
                 * @memberof havocai.messages.v0.PatrolParams
                 * @instance
                 */
                PatrolParams.prototype.altitude = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * PatrolParams patrolArea.
                 * @member {"zone"|"polygon"|"route"|undefined} patrolArea
                 * @memberof havocai.messages.v0.PatrolParams
                 * @instance
                 */
                Object.defineProperty(PatrolParams.prototype, "patrolArea", {
                    get: $util.oneOfGetter($oneOfFields = ["zone", "polygon", "route"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * PatrolParams _altitude.
                 * @member {"altitude"|undefined} _altitude
                 * @memberof havocai.messages.v0.PatrolParams
                 * @instance
                 */
                Object.defineProperty(PatrolParams.prototype, "_altitude", {
                    get: $util.oneOfGetter($oneOfFields = ["altitude"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new PatrolParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PatrolParams
                 * @static
                 * @param {havocai.messages.v0.IPatrolParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PatrolParams} PatrolParams instance
                 */
                PatrolParams.create = function create(properties) {
                    return new PatrolParams(properties);
                };

                /**
                 * Encodes the specified PatrolParams message. Does not implicitly {@link havocai.messages.v0.PatrolParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PatrolParams
                 * @static
                 * @param {havocai.messages.v0.IPatrolParams} message PatrolParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PatrolParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.zone != null && Object.hasOwnProperty.call(message, "zone"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.zone, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.polygon != null && Object.hasOwnProperty.call(message, "polygon"))
                        $root.havocai.messages.v0.Polygon.encode(message.polygon, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.route != null && Object.hasOwnProperty.call(message, "route"))
                        $root.havocai.messages.v0.Route.encode(message.route, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.direction);
                    if (message.targetSpeed != null && Object.hasOwnProperty.call(message, "targetSpeed"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.targetSpeed);
                    if (message.altitude != null && Object.hasOwnProperty.call(message, "altitude"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.altitude);
                    return writer;
                };

                /**
                 * Encodes the specified PatrolParams message, length delimited. Does not implicitly {@link havocai.messages.v0.PatrolParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PatrolParams
                 * @static
                 * @param {havocai.messages.v0.IPatrolParams} message PatrolParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PatrolParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PatrolParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PatrolParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PatrolParams} PatrolParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PatrolParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PatrolParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.zone = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.polygon = $root.havocai.messages.v0.Polygon.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.route = $root.havocai.messages.v0.Route.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.direction = reader.int32();
                                break;
                            }
                        case 5: {
                                message.targetSpeed = reader.float();
                                break;
                            }
                        case 6: {
                                message.altitude = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PatrolParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PatrolParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PatrolParams} PatrolParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PatrolParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PatrolParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.PatrolParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PatrolParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.zone != null && message.hasOwnProperty("zone")) {
                        properties.patrolArea = 1;
                        {
                            let error = $root.havocai.messages.v0.ResourceRef.verify(message.zone);
                            if (error)
                                return "zone." + error;
                        }
                    }
                    if (message.polygon != null && message.hasOwnProperty("polygon")) {
                        if (properties.patrolArea === 1)
                            return "patrolArea: multiple values";
                        properties.patrolArea = 1;
                        {
                            let error = $root.havocai.messages.v0.Polygon.verify(message.polygon);
                            if (error)
                                return "polygon." + error;
                        }
                    }
                    if (message.route != null && message.hasOwnProperty("route")) {
                        if (properties.patrolArea === 1)
                            return "patrolArea: multiple values";
                        properties.patrolArea = 1;
                        {
                            let error = $root.havocai.messages.v0.Route.verify(message.route);
                            if (error)
                                return "route." + error;
                        }
                    }
                    if (message.direction != null && message.hasOwnProperty("direction"))
                        switch (message.direction) {
                        default:
                            return "direction: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        if (typeof message.targetSpeed !== "number")
                            return "targetSpeed: number expected";
                    if (message.altitude != null && message.hasOwnProperty("altitude")) {
                        properties._altitude = 1;
                        if (typeof message.altitude !== "number")
                            return "altitude: number expected";
                    }
                    return null;
                };

                /**
                 * Creates a PatrolParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PatrolParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PatrolParams} PatrolParams
                 */
                PatrolParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PatrolParams)
                        return object;
                    let message = new $root.havocai.messages.v0.PatrolParams();
                    if (object.zone != null) {
                        if (typeof object.zone !== "object")
                            throw TypeError(".havocai.messages.v0.PatrolParams.zone: object expected");
                        message.zone = $root.havocai.messages.v0.ResourceRef.fromObject(object.zone);
                    }
                    if (object.polygon != null) {
                        if (typeof object.polygon !== "object")
                            throw TypeError(".havocai.messages.v0.PatrolParams.polygon: object expected");
                        message.polygon = $root.havocai.messages.v0.Polygon.fromObject(object.polygon);
                    }
                    if (object.route != null) {
                        if (typeof object.route !== "object")
                            throw TypeError(".havocai.messages.v0.PatrolParams.route: object expected");
                        message.route = $root.havocai.messages.v0.Route.fromObject(object.route);
                    }
                    switch (object.direction) {
                    default:
                        if (typeof object.direction === "number") {
                            message.direction = object.direction;
                            break;
                        }
                        break;
                    case "ROTATION_DIRECTION_UNKNOWN":
                    case 0:
                        message.direction = 0;
                        break;
                    case "ROTATION_DIRECTION_CLOCKWISE":
                    case 1:
                        message.direction = 1;
                        break;
                    case "ROTATION_DIRECTION_COUNTERCLOCKWISE":
                    case 2:
                        message.direction = 2;
                        break;
                    }
                    if (object.targetSpeed != null)
                        message.targetSpeed = Number(object.targetSpeed);
                    if (object.altitude != null)
                        message.altitude = Number(object.altitude);
                    return message;
                };

                /**
                 * Creates a plain object from a PatrolParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PatrolParams
                 * @static
                 * @param {havocai.messages.v0.PatrolParams} message PatrolParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PatrolParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.direction = options.enums === String ? "ROTATION_DIRECTION_UNKNOWN" : 0;
                        object.targetSpeed = 0;
                    }
                    if (message.zone != null && message.hasOwnProperty("zone")) {
                        object.zone = $root.havocai.messages.v0.ResourceRef.toObject(message.zone, options);
                        if (options.oneofs)
                            object.patrolArea = "zone";
                    }
                    if (message.polygon != null && message.hasOwnProperty("polygon")) {
                        object.polygon = $root.havocai.messages.v0.Polygon.toObject(message.polygon, options);
                        if (options.oneofs)
                            object.patrolArea = "polygon";
                    }
                    if (message.route != null && message.hasOwnProperty("route")) {
                        object.route = $root.havocai.messages.v0.Route.toObject(message.route, options);
                        if (options.oneofs)
                            object.patrolArea = "route";
                    }
                    if (message.direction != null && message.hasOwnProperty("direction"))
                        object.direction = options.enums === String ? $root.havocai.messages.v0.RotationDirection[message.direction] === undefined ? message.direction : $root.havocai.messages.v0.RotationDirection[message.direction] : message.direction;
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        object.targetSpeed = options.json && !isFinite(message.targetSpeed) ? String(message.targetSpeed) : message.targetSpeed;
                    if (message.altitude != null && message.hasOwnProperty("altitude")) {
                        object.altitude = options.json && !isFinite(message.altitude) ? String(message.altitude) : message.altitude;
                        if (options.oneofs)
                            object._altitude = "altitude";
                    }
                    return object;
                };

                /**
                 * Converts this PatrolParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PatrolParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PatrolParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PatrolParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PatrolParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PatrolParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PatrolParams";
                };

                return PatrolParams;
            })();

            v0.GeoFormationParams = (function() {

                /**
                 * Properties of a GeoFormationParams.
                 * @memberof havocai.messages.v0
                 * @interface IGeoFormationParams
                 * @property {havocai.messages.v0.ICooperativeOffset|null} [formation] GeoFormationParams formation
                 * @property {havocai.messages.v0.IGeoPoint|null} [musterPoint] GeoFormationParams musterPoint
                 * @property {number|null} [targetSpeed] GeoFormationParams targetSpeed
                 * @property {number|null} [altitude] GeoFormationParams altitude
                 */

                /**
                 * Constructs a new GeoFormationParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a GeoFormationParams.
                 * @implements IGeoFormationParams
                 * @constructor
                 * @param {havocai.messages.v0.IGeoFormationParams=} [properties] Properties to set
                 */
                function GeoFormationParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GeoFormationParams formation.
                 * @member {havocai.messages.v0.ICooperativeOffset|null|undefined} formation
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @instance
                 */
                GeoFormationParams.prototype.formation = null;

                /**
                 * GeoFormationParams musterPoint.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} musterPoint
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @instance
                 */
                GeoFormationParams.prototype.musterPoint = null;

                /**
                 * GeoFormationParams targetSpeed.
                 * @member {number} targetSpeed
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @instance
                 */
                GeoFormationParams.prototype.targetSpeed = 0;

                /**
                 * GeoFormationParams altitude.
                 * @member {number|null|undefined} altitude
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @instance
                 */
                GeoFormationParams.prototype.altitude = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * GeoFormationParams _musterPoint.
                 * @member {"musterPoint"|undefined} _musterPoint
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @instance
                 */
                Object.defineProperty(GeoFormationParams.prototype, "_musterPoint", {
                    get: $util.oneOfGetter($oneOfFields = ["musterPoint"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * GeoFormationParams _altitude.
                 * @member {"altitude"|undefined} _altitude
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @instance
                 */
                Object.defineProperty(GeoFormationParams.prototype, "_altitude", {
                    get: $util.oneOfGetter($oneOfFields = ["altitude"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new GeoFormationParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @static
                 * @param {havocai.messages.v0.IGeoFormationParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.GeoFormationParams} GeoFormationParams instance
                 */
                GeoFormationParams.create = function create(properties) {
                    return new GeoFormationParams(properties);
                };

                /**
                 * Encodes the specified GeoFormationParams message. Does not implicitly {@link havocai.messages.v0.GeoFormationParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @static
                 * @param {havocai.messages.v0.IGeoFormationParams} message GeoFormationParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeoFormationParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.formation != null && Object.hasOwnProperty.call(message, "formation"))
                        $root.havocai.messages.v0.CooperativeOffset.encode(message.formation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.musterPoint != null && Object.hasOwnProperty.call(message, "musterPoint"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.musterPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.targetSpeed != null && Object.hasOwnProperty.call(message, "targetSpeed"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.targetSpeed);
                    if (message.altitude != null && Object.hasOwnProperty.call(message, "altitude"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.altitude);
                    return writer;
                };

                /**
                 * Encodes the specified GeoFormationParams message, length delimited. Does not implicitly {@link havocai.messages.v0.GeoFormationParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @static
                 * @param {havocai.messages.v0.IGeoFormationParams} message GeoFormationParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeoFormationParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GeoFormationParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.GeoFormationParams} GeoFormationParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeoFormationParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.GeoFormationParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.formation = $root.havocai.messages.v0.CooperativeOffset.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.musterPoint = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.targetSpeed = reader.float();
                                break;
                            }
                        case 5: {
                                message.altitude = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GeoFormationParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.GeoFormationParams} GeoFormationParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeoFormationParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GeoFormationParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeoFormationParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.formation != null && message.hasOwnProperty("formation")) {
                        let error = $root.havocai.messages.v0.CooperativeOffset.verify(message.formation);
                        if (error)
                            return "formation." + error;
                    }
                    if (message.musterPoint != null && message.hasOwnProperty("musterPoint")) {
                        properties._musterPoint = 1;
                        {
                            let error = $root.havocai.messages.v0.GeoPoint.verify(message.musterPoint);
                            if (error)
                                return "musterPoint." + error;
                        }
                    }
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        if (typeof message.targetSpeed !== "number")
                            return "targetSpeed: number expected";
                    if (message.altitude != null && message.hasOwnProperty("altitude")) {
                        properties._altitude = 1;
                        if (typeof message.altitude !== "number")
                            return "altitude: number expected";
                    }
                    return null;
                };

                /**
                 * Creates a GeoFormationParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.GeoFormationParams} GeoFormationParams
                 */
                GeoFormationParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.GeoFormationParams)
                        return object;
                    let message = new $root.havocai.messages.v0.GeoFormationParams();
                    if (object.formation != null) {
                        if (typeof object.formation !== "object")
                            throw TypeError(".havocai.messages.v0.GeoFormationParams.formation: object expected");
                        message.formation = $root.havocai.messages.v0.CooperativeOffset.fromObject(object.formation);
                    }
                    if (object.musterPoint != null) {
                        if (typeof object.musterPoint !== "object")
                            throw TypeError(".havocai.messages.v0.GeoFormationParams.musterPoint: object expected");
                        message.musterPoint = $root.havocai.messages.v0.GeoPoint.fromObject(object.musterPoint);
                    }
                    if (object.targetSpeed != null)
                        message.targetSpeed = Number(object.targetSpeed);
                    if (object.altitude != null)
                        message.altitude = Number(object.altitude);
                    return message;
                };

                /**
                 * Creates a plain object from a GeoFormationParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @static
                 * @param {havocai.messages.v0.GeoFormationParams} message GeoFormationParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GeoFormationParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.formation = null;
                        object.targetSpeed = 0;
                    }
                    if (message.formation != null && message.hasOwnProperty("formation"))
                        object.formation = $root.havocai.messages.v0.CooperativeOffset.toObject(message.formation, options);
                    if (message.musterPoint != null && message.hasOwnProperty("musterPoint")) {
                        object.musterPoint = $root.havocai.messages.v0.GeoPoint.toObject(message.musterPoint, options);
                        if (options.oneofs)
                            object._musterPoint = "musterPoint";
                    }
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        object.targetSpeed = options.json && !isFinite(message.targetSpeed) ? String(message.targetSpeed) : message.targetSpeed;
                    if (message.altitude != null && message.hasOwnProperty("altitude")) {
                        object.altitude = options.json && !isFinite(message.altitude) ? String(message.altitude) : message.altitude;
                        if (options.oneofs)
                            object._altitude = "altitude";
                    }
                    return object;
                };

                /**
                 * Converts this GeoFormationParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GeoFormationParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for GeoFormationParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.GeoFormationParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                GeoFormationParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.GeoFormationParams";
                };

                return GeoFormationParams;
            })();

            v0.EscortParams = (function() {

                /**
                 * Properties of an EscortParams.
                 * @memberof havocai.messages.v0
                 * @interface IEscortParams
                 * @property {havocai.messages.v0.ICooperativeOffset|null} [formation] EscortParams formation
                 * @property {havocai.messages.v0.IResourceRef|null} [targetTrack] EscortParams targetTrack
                 * @property {number|null} [targetSpeed] EscortParams targetSpeed
                 * @property {number|null} [altitude] EscortParams altitude
                 */

                /**
                 * Constructs a new EscortParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents an EscortParams.
                 * @implements IEscortParams
                 * @constructor
                 * @param {havocai.messages.v0.IEscortParams=} [properties] Properties to set
                 */
                function EscortParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EscortParams formation.
                 * @member {havocai.messages.v0.ICooperativeOffset|null|undefined} formation
                 * @memberof havocai.messages.v0.EscortParams
                 * @instance
                 */
                EscortParams.prototype.formation = null;

                /**
                 * EscortParams targetTrack.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} targetTrack
                 * @memberof havocai.messages.v0.EscortParams
                 * @instance
                 */
                EscortParams.prototype.targetTrack = null;

                /**
                 * EscortParams targetSpeed.
                 * @member {number} targetSpeed
                 * @memberof havocai.messages.v0.EscortParams
                 * @instance
                 */
                EscortParams.prototype.targetSpeed = 0;

                /**
                 * EscortParams altitude.
                 * @member {number|null|undefined} altitude
                 * @memberof havocai.messages.v0.EscortParams
                 * @instance
                 */
                EscortParams.prototype.altitude = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * EscortParams _altitude.
                 * @member {"altitude"|undefined} _altitude
                 * @memberof havocai.messages.v0.EscortParams
                 * @instance
                 */
                Object.defineProperty(EscortParams.prototype, "_altitude", {
                    get: $util.oneOfGetter($oneOfFields = ["altitude"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new EscortParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.EscortParams
                 * @static
                 * @param {havocai.messages.v0.IEscortParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.EscortParams} EscortParams instance
                 */
                EscortParams.create = function create(properties) {
                    return new EscortParams(properties);
                };

                /**
                 * Encodes the specified EscortParams message. Does not implicitly {@link havocai.messages.v0.EscortParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.EscortParams
                 * @static
                 * @param {havocai.messages.v0.IEscortParams} message EscortParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EscortParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.formation != null && Object.hasOwnProperty.call(message, "formation"))
                        $root.havocai.messages.v0.CooperativeOffset.encode(message.formation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.targetTrack != null && Object.hasOwnProperty.call(message, "targetTrack"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.targetTrack, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.targetSpeed != null && Object.hasOwnProperty.call(message, "targetSpeed"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.targetSpeed);
                    if (message.altitude != null && Object.hasOwnProperty.call(message, "altitude"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.altitude);
                    return writer;
                };

                /**
                 * Encodes the specified EscortParams message, length delimited. Does not implicitly {@link havocai.messages.v0.EscortParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.EscortParams
                 * @static
                 * @param {havocai.messages.v0.IEscortParams} message EscortParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EscortParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EscortParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.EscortParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.EscortParams} EscortParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EscortParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.EscortParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.formation = $root.havocai.messages.v0.CooperativeOffset.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.targetTrack = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.targetSpeed = reader.float();
                                break;
                            }
                        case 5: {
                                message.altitude = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EscortParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.EscortParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.EscortParams} EscortParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EscortParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EscortParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.EscortParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EscortParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.formation != null && message.hasOwnProperty("formation")) {
                        let error = $root.havocai.messages.v0.CooperativeOffset.verify(message.formation);
                        if (error)
                            return "formation." + error;
                    }
                    if (message.targetTrack != null && message.hasOwnProperty("targetTrack")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.targetTrack);
                        if (error)
                            return "targetTrack." + error;
                    }
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        if (typeof message.targetSpeed !== "number")
                            return "targetSpeed: number expected";
                    if (message.altitude != null && message.hasOwnProperty("altitude")) {
                        properties._altitude = 1;
                        if (typeof message.altitude !== "number")
                            return "altitude: number expected";
                    }
                    return null;
                };

                /**
                 * Creates an EscortParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.EscortParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.EscortParams} EscortParams
                 */
                EscortParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.EscortParams)
                        return object;
                    let message = new $root.havocai.messages.v0.EscortParams();
                    if (object.formation != null) {
                        if (typeof object.formation !== "object")
                            throw TypeError(".havocai.messages.v0.EscortParams.formation: object expected");
                        message.formation = $root.havocai.messages.v0.CooperativeOffset.fromObject(object.formation);
                    }
                    if (object.targetTrack != null) {
                        if (typeof object.targetTrack !== "object")
                            throw TypeError(".havocai.messages.v0.EscortParams.targetTrack: object expected");
                        message.targetTrack = $root.havocai.messages.v0.ResourceRef.fromObject(object.targetTrack);
                    }
                    if (object.targetSpeed != null)
                        message.targetSpeed = Number(object.targetSpeed);
                    if (object.altitude != null)
                        message.altitude = Number(object.altitude);
                    return message;
                };

                /**
                 * Creates a plain object from an EscortParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.EscortParams
                 * @static
                 * @param {havocai.messages.v0.EscortParams} message EscortParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EscortParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.formation = null;
                        object.targetTrack = null;
                        object.targetSpeed = 0;
                    }
                    if (message.formation != null && message.hasOwnProperty("formation"))
                        object.formation = $root.havocai.messages.v0.CooperativeOffset.toObject(message.formation, options);
                    if (message.targetTrack != null && message.hasOwnProperty("targetTrack"))
                        object.targetTrack = $root.havocai.messages.v0.ResourceRef.toObject(message.targetTrack, options);
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        object.targetSpeed = options.json && !isFinite(message.targetSpeed) ? String(message.targetSpeed) : message.targetSpeed;
                    if (message.altitude != null && message.hasOwnProperty("altitude")) {
                        object.altitude = options.json && !isFinite(message.altitude) ? String(message.altitude) : message.altitude;
                        if (options.oneofs)
                            object._altitude = "altitude";
                    }
                    return object;
                };

                /**
                 * Converts this EscortParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.EscortParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EscortParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for EscortParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.EscortParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EscortParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.EscortParams";
                };

                return EscortParams;
            })();

            v0.EngageParams = (function() {

                /**
                 * Properties of an EngageParams.
                 * @memberof havocai.messages.v0
                 * @interface IEngageParams
                 * @property {havocai.messages.v0.IResourceRef|null} [zone] EngageParams zone
                 * @property {havocai.messages.v0.IPolygon|null} [polygon] EngageParams polygon
                 * @property {havocai.messages.v0.IResourceRef|null} [track] EngageParams track
                 * @property {havocai.messages.v0.ITrackCriteria|null} [trackCriteria] EngageParams trackCriteria
                 * @property {number|null} [targetSpeed] EngageParams targetSpeed
                 * @property {number|null} [engagementRatio] EngageParams engagementRatio
                 * @property {havocai.messages.v0.EngagementMode|null} [engagementMode] EngageParams engagementMode
                 * @property {number|null} [standoffDistance] EngageParams standoffDistance
                 * @property {number|null} [engagementDistance] EngageParams engagementDistance
                 * @property {number|null} [altitude] EngageParams altitude
                 */

                /**
                 * Constructs a new EngageParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents an EngageParams.
                 * @implements IEngageParams
                 * @constructor
                 * @param {havocai.messages.v0.IEngageParams=} [properties] Properties to set
                 */
                function EngageParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EngageParams zone.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} zone
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                EngageParams.prototype.zone = null;

                /**
                 * EngageParams polygon.
                 * @member {havocai.messages.v0.IPolygon|null|undefined} polygon
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                EngageParams.prototype.polygon = null;

                /**
                 * EngageParams track.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} track
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                EngageParams.prototype.track = null;

                /**
                 * EngageParams trackCriteria.
                 * @member {havocai.messages.v0.ITrackCriteria|null|undefined} trackCriteria
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                EngageParams.prototype.trackCriteria = null;

                /**
                 * EngageParams targetSpeed.
                 * @member {number} targetSpeed
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                EngageParams.prototype.targetSpeed = 0;

                /**
                 * EngageParams engagementRatio.
                 * @member {number} engagementRatio
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                EngageParams.prototype.engagementRatio = 0;

                /**
                 * EngageParams engagementMode.
                 * @member {havocai.messages.v0.EngagementMode} engagementMode
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                EngageParams.prototype.engagementMode = 0;

                /**
                 * EngageParams standoffDistance.
                 * @member {number|null|undefined} standoffDistance
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                EngageParams.prototype.standoffDistance = null;

                /**
                 * EngageParams engagementDistance.
                 * @member {number|null|undefined} engagementDistance
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                EngageParams.prototype.engagementDistance = null;

                /**
                 * EngageParams altitude.
                 * @member {number|null|undefined} altitude
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                EngageParams.prototype.altitude = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * EngageParams engagementArea.
                 * @member {"zone"|"polygon"|undefined} engagementArea
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                Object.defineProperty(EngageParams.prototype, "engagementArea", {
                    get: $util.oneOfGetter($oneOfFields = ["zone", "polygon"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * EngageParams target.
                 * @member {"track"|"trackCriteria"|undefined} target
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                Object.defineProperty(EngageParams.prototype, "target", {
                    get: $util.oneOfGetter($oneOfFields = ["track", "trackCriteria"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * EngageParams _standoffDistance.
                 * @member {"standoffDistance"|undefined} _standoffDistance
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                Object.defineProperty(EngageParams.prototype, "_standoffDistance", {
                    get: $util.oneOfGetter($oneOfFields = ["standoffDistance"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * EngageParams _engagementDistance.
                 * @member {"engagementDistance"|undefined} _engagementDistance
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                Object.defineProperty(EngageParams.prototype, "_engagementDistance", {
                    get: $util.oneOfGetter($oneOfFields = ["engagementDistance"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * EngageParams _altitude.
                 * @member {"altitude"|undefined} _altitude
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 */
                Object.defineProperty(EngageParams.prototype, "_altitude", {
                    get: $util.oneOfGetter($oneOfFields = ["altitude"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new EngageParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.EngageParams
                 * @static
                 * @param {havocai.messages.v0.IEngageParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.EngageParams} EngageParams instance
                 */
                EngageParams.create = function create(properties) {
                    return new EngageParams(properties);
                };

                /**
                 * Encodes the specified EngageParams message. Does not implicitly {@link havocai.messages.v0.EngageParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.EngageParams
                 * @static
                 * @param {havocai.messages.v0.IEngageParams} message EngageParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EngageParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.zone != null && Object.hasOwnProperty.call(message, "zone"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.zone, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.polygon != null && Object.hasOwnProperty.call(message, "polygon"))
                        $root.havocai.messages.v0.Polygon.encode(message.polygon, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.track != null && Object.hasOwnProperty.call(message, "track"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.track, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.trackCriteria != null && Object.hasOwnProperty.call(message, "trackCriteria"))
                        $root.havocai.messages.v0.TrackCriteria.encode(message.trackCriteria, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.targetSpeed != null && Object.hasOwnProperty.call(message, "targetSpeed"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.targetSpeed);
                    if (message.engagementRatio != null && Object.hasOwnProperty.call(message, "engagementRatio"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.engagementRatio);
                    if (message.engagementMode != null && Object.hasOwnProperty.call(message, "engagementMode"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.engagementMode);
                    if (message.standoffDistance != null && Object.hasOwnProperty.call(message, "standoffDistance"))
                        writer.uint32(/* id 8, wireType 1 =*/65).double(message.standoffDistance);
                    if (message.engagementDistance != null && Object.hasOwnProperty.call(message, "engagementDistance"))
                        writer.uint32(/* id 9, wireType 1 =*/73).double(message.engagementDistance);
                    if (message.altitude != null && Object.hasOwnProperty.call(message, "altitude"))
                        writer.uint32(/* id 10, wireType 1 =*/81).double(message.altitude);
                    return writer;
                };

                /**
                 * Encodes the specified EngageParams message, length delimited. Does not implicitly {@link havocai.messages.v0.EngageParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.EngageParams
                 * @static
                 * @param {havocai.messages.v0.IEngageParams} message EngageParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EngageParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EngageParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.EngageParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.EngageParams} EngageParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EngageParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.EngageParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.zone = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.polygon = $root.havocai.messages.v0.Polygon.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.track = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.trackCriteria = $root.havocai.messages.v0.TrackCriteria.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.targetSpeed = reader.float();
                                break;
                            }
                        case 6: {
                                message.engagementRatio = reader.uint32();
                                break;
                            }
                        case 7: {
                                message.engagementMode = reader.int32();
                                break;
                            }
                        case 8: {
                                message.standoffDistance = reader.double();
                                break;
                            }
                        case 9: {
                                message.engagementDistance = reader.double();
                                break;
                            }
                        case 10: {
                                message.altitude = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EngageParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.EngageParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.EngageParams} EngageParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EngageParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EngageParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.EngageParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EngageParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.zone != null && message.hasOwnProperty("zone")) {
                        properties.engagementArea = 1;
                        {
                            let error = $root.havocai.messages.v0.ResourceRef.verify(message.zone);
                            if (error)
                                return "zone." + error;
                        }
                    }
                    if (message.polygon != null && message.hasOwnProperty("polygon")) {
                        if (properties.engagementArea === 1)
                            return "engagementArea: multiple values";
                        properties.engagementArea = 1;
                        {
                            let error = $root.havocai.messages.v0.Polygon.verify(message.polygon);
                            if (error)
                                return "polygon." + error;
                        }
                    }
                    if (message.track != null && message.hasOwnProperty("track")) {
                        properties.target = 1;
                        {
                            let error = $root.havocai.messages.v0.ResourceRef.verify(message.track);
                            if (error)
                                return "track." + error;
                        }
                    }
                    if (message.trackCriteria != null && message.hasOwnProperty("trackCriteria")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            let error = $root.havocai.messages.v0.TrackCriteria.verify(message.trackCriteria);
                            if (error)
                                return "trackCriteria." + error;
                        }
                    }
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        if (typeof message.targetSpeed !== "number")
                            return "targetSpeed: number expected";
                    if (message.engagementRatio != null && message.hasOwnProperty("engagementRatio"))
                        if (!$util.isInteger(message.engagementRatio))
                            return "engagementRatio: integer expected";
                    if (message.engagementMode != null && message.hasOwnProperty("engagementMode"))
                        switch (message.engagementMode) {
                        default:
                            return "engagementMode: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.standoffDistance != null && message.hasOwnProperty("standoffDistance")) {
                        properties._standoffDistance = 1;
                        if (typeof message.standoffDistance !== "number")
                            return "standoffDistance: number expected";
                    }
                    if (message.engagementDistance != null && message.hasOwnProperty("engagementDistance")) {
                        properties._engagementDistance = 1;
                        if (typeof message.engagementDistance !== "number")
                            return "engagementDistance: number expected";
                    }
                    if (message.altitude != null && message.hasOwnProperty("altitude")) {
                        properties._altitude = 1;
                        if (typeof message.altitude !== "number")
                            return "altitude: number expected";
                    }
                    return null;
                };

                /**
                 * Creates an EngageParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.EngageParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.EngageParams} EngageParams
                 */
                EngageParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.EngageParams)
                        return object;
                    let message = new $root.havocai.messages.v0.EngageParams();
                    if (object.zone != null) {
                        if (typeof object.zone !== "object")
                            throw TypeError(".havocai.messages.v0.EngageParams.zone: object expected");
                        message.zone = $root.havocai.messages.v0.ResourceRef.fromObject(object.zone);
                    }
                    if (object.polygon != null) {
                        if (typeof object.polygon !== "object")
                            throw TypeError(".havocai.messages.v0.EngageParams.polygon: object expected");
                        message.polygon = $root.havocai.messages.v0.Polygon.fromObject(object.polygon);
                    }
                    if (object.track != null) {
                        if (typeof object.track !== "object")
                            throw TypeError(".havocai.messages.v0.EngageParams.track: object expected");
                        message.track = $root.havocai.messages.v0.ResourceRef.fromObject(object.track);
                    }
                    if (object.trackCriteria != null) {
                        if (typeof object.trackCriteria !== "object")
                            throw TypeError(".havocai.messages.v0.EngageParams.trackCriteria: object expected");
                        message.trackCriteria = $root.havocai.messages.v0.TrackCriteria.fromObject(object.trackCriteria);
                    }
                    if (object.targetSpeed != null)
                        message.targetSpeed = Number(object.targetSpeed);
                    if (object.engagementRatio != null)
                        message.engagementRatio = object.engagementRatio >>> 0;
                    switch (object.engagementMode) {
                    default:
                        if (typeof object.engagementMode === "number") {
                            message.engagementMode = object.engagementMode;
                            break;
                        }
                        break;
                    case "ENGAGEMENT_MODE_UNKNOWN":
                    case 0:
                        message.engagementMode = 0;
                        break;
                    case "ENGAGEMENT_MODE_INDEPENDENT":
                    case 1:
                        message.engagementMode = 1;
                        break;
                    case "ENGAGEMENT_MODE_COORDINATED":
                    case 2:
                        message.engagementMode = 2;
                        break;
                    }
                    if (object.standoffDistance != null)
                        message.standoffDistance = Number(object.standoffDistance);
                    if (object.engagementDistance != null)
                        message.engagementDistance = Number(object.engagementDistance);
                    if (object.altitude != null)
                        message.altitude = Number(object.altitude);
                    return message;
                };

                /**
                 * Creates a plain object from an EngageParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.EngageParams
                 * @static
                 * @param {havocai.messages.v0.EngageParams} message EngageParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EngageParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.targetSpeed = 0;
                        object.engagementRatio = 0;
                        object.engagementMode = options.enums === String ? "ENGAGEMENT_MODE_UNKNOWN" : 0;
                    }
                    if (message.zone != null && message.hasOwnProperty("zone")) {
                        object.zone = $root.havocai.messages.v0.ResourceRef.toObject(message.zone, options);
                        if (options.oneofs)
                            object.engagementArea = "zone";
                    }
                    if (message.polygon != null && message.hasOwnProperty("polygon")) {
                        object.polygon = $root.havocai.messages.v0.Polygon.toObject(message.polygon, options);
                        if (options.oneofs)
                            object.engagementArea = "polygon";
                    }
                    if (message.track != null && message.hasOwnProperty("track")) {
                        object.track = $root.havocai.messages.v0.ResourceRef.toObject(message.track, options);
                        if (options.oneofs)
                            object.target = "track";
                    }
                    if (message.trackCriteria != null && message.hasOwnProperty("trackCriteria")) {
                        object.trackCriteria = $root.havocai.messages.v0.TrackCriteria.toObject(message.trackCriteria, options);
                        if (options.oneofs)
                            object.target = "trackCriteria";
                    }
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        object.targetSpeed = options.json && !isFinite(message.targetSpeed) ? String(message.targetSpeed) : message.targetSpeed;
                    if (message.engagementRatio != null && message.hasOwnProperty("engagementRatio"))
                        object.engagementRatio = message.engagementRatio;
                    if (message.engagementMode != null && message.hasOwnProperty("engagementMode"))
                        object.engagementMode = options.enums === String ? $root.havocai.messages.v0.EngagementMode[message.engagementMode] === undefined ? message.engagementMode : $root.havocai.messages.v0.EngagementMode[message.engagementMode] : message.engagementMode;
                    if (message.standoffDistance != null && message.hasOwnProperty("standoffDistance")) {
                        object.standoffDistance = options.json && !isFinite(message.standoffDistance) ? String(message.standoffDistance) : message.standoffDistance;
                        if (options.oneofs)
                            object._standoffDistance = "standoffDistance";
                    }
                    if (message.engagementDistance != null && message.hasOwnProperty("engagementDistance")) {
                        object.engagementDistance = options.json && !isFinite(message.engagementDistance) ? String(message.engagementDistance) : message.engagementDistance;
                        if (options.oneofs)
                            object._engagementDistance = "engagementDistance";
                    }
                    if (message.altitude != null && message.hasOwnProperty("altitude")) {
                        object.altitude = options.json && !isFinite(message.altitude) ? String(message.altitude) : message.altitude;
                        if (options.oneofs)
                            object._altitude = "altitude";
                    }
                    return object;
                };

                /**
                 * Converts this EngageParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.EngageParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EngageParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for EngageParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.EngageParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EngageParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.EngageParams";
                };

                return EngageParams;
            })();

            v0.DriftParams = (function() {

                /**
                 * Properties of a DriftParams.
                 * @memberof havocai.messages.v0
                 * @interface IDriftParams
                 * @property {number|null} [driftRadius] DriftParams driftRadius
                 * @property {havocai.messages.v0.IGeoPoint|null} [driftReferencePosition] DriftParams driftReferencePosition
                 * @property {number|null} [speed] DriftParams speed
                 */

                /**
                 * Constructs a new DriftParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a DriftParams.
                 * @implements IDriftParams
                 * @constructor
                 * @param {havocai.messages.v0.IDriftParams=} [properties] Properties to set
                 */
                function DriftParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DriftParams driftRadius.
                 * @member {number} driftRadius
                 * @memberof havocai.messages.v0.DriftParams
                 * @instance
                 */
                DriftParams.prototype.driftRadius = 0;

                /**
                 * DriftParams driftReferencePosition.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} driftReferencePosition
                 * @memberof havocai.messages.v0.DriftParams
                 * @instance
                 */
                DriftParams.prototype.driftReferencePosition = null;

                /**
                 * DriftParams speed.
                 * @member {number} speed
                 * @memberof havocai.messages.v0.DriftParams
                 * @instance
                 */
                DriftParams.prototype.speed = 0;

                /**
                 * Creates a new DriftParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.DriftParams
                 * @static
                 * @param {havocai.messages.v0.IDriftParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.DriftParams} DriftParams instance
                 */
                DriftParams.create = function create(properties) {
                    return new DriftParams(properties);
                };

                /**
                 * Encodes the specified DriftParams message. Does not implicitly {@link havocai.messages.v0.DriftParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.DriftParams
                 * @static
                 * @param {havocai.messages.v0.IDriftParams} message DriftParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DriftParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.driftRadius != null && Object.hasOwnProperty.call(message, "driftRadius"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.driftRadius);
                    if (message.driftReferencePosition != null && Object.hasOwnProperty.call(message, "driftReferencePosition"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.driftReferencePosition, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.speed);
                    return writer;
                };

                /**
                 * Encodes the specified DriftParams message, length delimited. Does not implicitly {@link havocai.messages.v0.DriftParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.DriftParams
                 * @static
                 * @param {havocai.messages.v0.IDriftParams} message DriftParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DriftParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DriftParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.DriftParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.DriftParams} DriftParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DriftParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.DriftParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.driftRadius = reader.float();
                                break;
                            }
                        case 2: {
                                message.driftReferencePosition = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.speed = reader.float();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DriftParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.DriftParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.DriftParams} DriftParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DriftParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DriftParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.DriftParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DriftParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.driftRadius != null && message.hasOwnProperty("driftRadius"))
                        if (typeof message.driftRadius !== "number")
                            return "driftRadius: number expected";
                    if (message.driftReferencePosition != null && message.hasOwnProperty("driftReferencePosition")) {
                        let error = $root.havocai.messages.v0.GeoPoint.verify(message.driftReferencePosition);
                        if (error)
                            return "driftReferencePosition." + error;
                    }
                    if (message.speed != null && message.hasOwnProperty("speed"))
                        if (typeof message.speed !== "number")
                            return "speed: number expected";
                    return null;
                };

                /**
                 * Creates a DriftParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.DriftParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.DriftParams} DriftParams
                 */
                DriftParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.DriftParams)
                        return object;
                    let message = new $root.havocai.messages.v0.DriftParams();
                    if (object.driftRadius != null)
                        message.driftRadius = Number(object.driftRadius);
                    if (object.driftReferencePosition != null) {
                        if (typeof object.driftReferencePosition !== "object")
                            throw TypeError(".havocai.messages.v0.DriftParams.driftReferencePosition: object expected");
                        message.driftReferencePosition = $root.havocai.messages.v0.GeoPoint.fromObject(object.driftReferencePosition);
                    }
                    if (object.speed != null)
                        message.speed = Number(object.speed);
                    return message;
                };

                /**
                 * Creates a plain object from a DriftParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.DriftParams
                 * @static
                 * @param {havocai.messages.v0.DriftParams} message DriftParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DriftParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.driftRadius = 0;
                        object.driftReferencePosition = null;
                        object.speed = 0;
                    }
                    if (message.driftRadius != null && message.hasOwnProperty("driftRadius"))
                        object.driftRadius = options.json && !isFinite(message.driftRadius) ? String(message.driftRadius) : message.driftRadius;
                    if (message.driftReferencePosition != null && message.hasOwnProperty("driftReferencePosition"))
                        object.driftReferencePosition = $root.havocai.messages.v0.GeoPoint.toObject(message.driftReferencePosition, options);
                    if (message.speed != null && message.hasOwnProperty("speed"))
                        object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
                    return object;
                };

                /**
                 * Converts this DriftParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.DriftParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DriftParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for DriftParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.DriftParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                DriftParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.DriftParams";
                };

                return DriftParams;
            })();

            v0.TrackCriteria = (function() {

                /**
                 * Properties of a TrackCriteria.
                 * @memberof havocai.messages.v0
                 * @interface ITrackCriteria
                 * @property {Array.<havocai.messages.v0.TrackType>|null} [trackTypes] TrackCriteria trackTypes
                 * @property {Array.<havocai.messages.v0.Affiliation>|null} [trackAffiliations] TrackCriteria trackAffiliations
                 * @property {number|null} [trackAffiliationConfidence] TrackCriteria trackAffiliationConfidence
                 */

                /**
                 * Constructs a new TrackCriteria.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a TrackCriteria.
                 * @implements ITrackCriteria
                 * @constructor
                 * @param {havocai.messages.v0.ITrackCriteria=} [properties] Properties to set
                 */
                function TrackCriteria(properties) {
                    this.trackTypes = [];
                    this.trackAffiliations = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TrackCriteria trackTypes.
                 * @member {Array.<havocai.messages.v0.TrackType>} trackTypes
                 * @memberof havocai.messages.v0.TrackCriteria
                 * @instance
                 */
                TrackCriteria.prototype.trackTypes = $util.emptyArray;

                /**
                 * TrackCriteria trackAffiliations.
                 * @member {Array.<havocai.messages.v0.Affiliation>} trackAffiliations
                 * @memberof havocai.messages.v0.TrackCriteria
                 * @instance
                 */
                TrackCriteria.prototype.trackAffiliations = $util.emptyArray;

                /**
                 * TrackCriteria trackAffiliationConfidence.
                 * @member {number} trackAffiliationConfidence
                 * @memberof havocai.messages.v0.TrackCriteria
                 * @instance
                 */
                TrackCriteria.prototype.trackAffiliationConfidence = 0;

                /**
                 * Creates a new TrackCriteria instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.TrackCriteria
                 * @static
                 * @param {havocai.messages.v0.ITrackCriteria=} [properties] Properties to set
                 * @returns {havocai.messages.v0.TrackCriteria} TrackCriteria instance
                 */
                TrackCriteria.create = function create(properties) {
                    return new TrackCriteria(properties);
                };

                /**
                 * Encodes the specified TrackCriteria message. Does not implicitly {@link havocai.messages.v0.TrackCriteria.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.TrackCriteria
                 * @static
                 * @param {havocai.messages.v0.ITrackCriteria} message TrackCriteria message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrackCriteria.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.trackTypes != null && message.trackTypes.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.trackTypes.length; ++i)
                            writer.int32(message.trackTypes[i]);
                        writer.ldelim();
                    }
                    if (message.trackAffiliations != null && message.trackAffiliations.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (let i = 0; i < message.trackAffiliations.length; ++i)
                            writer.int32(message.trackAffiliations[i]);
                        writer.ldelim();
                    }
                    if (message.trackAffiliationConfidence != null && Object.hasOwnProperty.call(message, "trackAffiliationConfidence"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.trackAffiliationConfidence);
                    return writer;
                };

                /**
                 * Encodes the specified TrackCriteria message, length delimited. Does not implicitly {@link havocai.messages.v0.TrackCriteria.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.TrackCriteria
                 * @static
                 * @param {havocai.messages.v0.ITrackCriteria} message TrackCriteria message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrackCriteria.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TrackCriteria message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.TrackCriteria
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.TrackCriteria} TrackCriteria
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrackCriteria.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.TrackCriteria();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.trackTypes && message.trackTypes.length))
                                    message.trackTypes = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.trackTypes.push(reader.int32());
                                } else
                                    message.trackTypes.push(reader.int32());
                                break;
                            }
                        case 2: {
                                if (!(message.trackAffiliations && message.trackAffiliations.length))
                                    message.trackAffiliations = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.trackAffiliations.push(reader.int32());
                                } else
                                    message.trackAffiliations.push(reader.int32());
                                break;
                            }
                        case 3: {
                                message.trackAffiliationConfidence = reader.float();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TrackCriteria message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.TrackCriteria
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.TrackCriteria} TrackCriteria
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrackCriteria.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TrackCriteria message.
                 * @function verify
                 * @memberof havocai.messages.v0.TrackCriteria
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TrackCriteria.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.trackTypes != null && message.hasOwnProperty("trackTypes")) {
                        if (!Array.isArray(message.trackTypes))
                            return "trackTypes: array expected";
                        for (let i = 0; i < message.trackTypes.length; ++i)
                            switch (message.trackTypes[i]) {
                            default:
                                return "trackTypes: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 98:
                            case 99:
                                break;
                            }
                    }
                    if (message.trackAffiliations != null && message.hasOwnProperty("trackAffiliations")) {
                        if (!Array.isArray(message.trackAffiliations))
                            return "trackAffiliations: array expected";
                        for (let i = 0; i < message.trackAffiliations.length; ++i)
                            switch (message.trackAffiliations[i]) {
                            default:
                                return "trackAffiliations: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            }
                    }
                    if (message.trackAffiliationConfidence != null && message.hasOwnProperty("trackAffiliationConfidence"))
                        if (typeof message.trackAffiliationConfidence !== "number")
                            return "trackAffiliationConfidence: number expected";
                    return null;
                };

                /**
                 * Creates a TrackCriteria message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.TrackCriteria
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.TrackCriteria} TrackCriteria
                 */
                TrackCriteria.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.TrackCriteria)
                        return object;
                    let message = new $root.havocai.messages.v0.TrackCriteria();
                    if (object.trackTypes) {
                        if (!Array.isArray(object.trackTypes))
                            throw TypeError(".havocai.messages.v0.TrackCriteria.trackTypes: array expected");
                        message.trackTypes = [];
                        for (let i = 0; i < object.trackTypes.length; ++i)
                            switch (object.trackTypes[i]) {
                            default:
                                if (typeof object.trackTypes[i] === "number") {
                                    message.trackTypes[i] = object.trackTypes[i];
                                    break;
                                }
                            case "TRACK_TYPE_UNKNOWN":
                            case 0:
                                message.trackTypes[i] = 0;
                                break;
                            case "TRACK_TYPE_AIS":
                            case 1:
                                message.trackTypes[i] = 1;
                                break;
                            case "TRACK_TYPE_RADAR":
                            case 2:
                                message.trackTypes[i] = 2;
                                break;
                            case "TRACK_TYPE_EO":
                            case 3:
                                message.trackTypes[i] = 3;
                                break;
                            case "TRACK_TYPE_FUSED":
                            case 4:
                                message.trackTypes[i] = 4;
                                break;
                            case "TRACK_TYPE_USER_CREATED":
                            case 5:
                                message.trackTypes[i] = 5;
                                break;
                            case "TRACK_TYPE_EXTERNAL_SYSTEM":
                            case 6:
                                message.trackTypes[i] = 6;
                                break;
                            case "TRACK_TYPE_RF":
                            case 7:
                                message.trackTypes[i] = 7;
                                break;
                            case "TRACK_TYPE_PERSON":
                            case 8:
                                message.trackTypes[i] = 8;
                                break;
                            case "TRACK_TYPE_MISSILE":
                            case 9:
                                message.trackTypes[i] = 9;
                                break;
                            case "TRACK_TYPE_TORPEDO":
                            case 10:
                                message.trackTypes[i] = 10;
                                break;
                            case "TRACK_TYPE_RUBBER_DUCKIE":
                            case 98:
                                message.trackTypes[i] = 98;
                                break;
                            case "TRACK_TYPE_NERF_DART":
                            case 99:
                                message.trackTypes[i] = 99;
                                break;
                            }
                    }
                    if (object.trackAffiliations) {
                        if (!Array.isArray(object.trackAffiliations))
                            throw TypeError(".havocai.messages.v0.TrackCriteria.trackAffiliations: array expected");
                        message.trackAffiliations = [];
                        for (let i = 0; i < object.trackAffiliations.length; ++i)
                            switch (object.trackAffiliations[i]) {
                            default:
                                if (typeof object.trackAffiliations[i] === "number") {
                                    message.trackAffiliations[i] = object.trackAffiliations[i];
                                    break;
                                }
                            case "AFFILIATION_UNKNOWN":
                            case 0:
                                message.trackAffiliations[i] = 0;
                                break;
                            case "AFFILIATION_ASSUMED_FRIENDLY":
                            case 1:
                                message.trackAffiliations[i] = 1;
                                break;
                            case "AFFILIATION_FRIENDLY":
                            case 2:
                                message.trackAffiliations[i] = 2;
                                break;
                            case "AFFILIATION_NEUTRAL":
                            case 3:
                                message.trackAffiliations[i] = 3;
                                break;
                            case "AFFILIATION_SUSPECT":
                            case 4:
                                message.trackAffiliations[i] = 4;
                                break;
                            case "AFFILIATION_HOSTILE":
                            case 5:
                                message.trackAffiliations[i] = 5;
                                break;
                            }
                    }
                    if (object.trackAffiliationConfidence != null)
                        message.trackAffiliationConfidence = Number(object.trackAffiliationConfidence);
                    return message;
                };

                /**
                 * Creates a plain object from a TrackCriteria message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.TrackCriteria
                 * @static
                 * @param {havocai.messages.v0.TrackCriteria} message TrackCriteria
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TrackCriteria.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.trackTypes = [];
                        object.trackAffiliations = [];
                    }
                    if (options.defaults)
                        object.trackAffiliationConfidence = 0;
                    if (message.trackTypes && message.trackTypes.length) {
                        object.trackTypes = [];
                        for (let j = 0; j < message.trackTypes.length; ++j)
                            object.trackTypes[j] = options.enums === String ? $root.havocai.messages.v0.TrackType[message.trackTypes[j]] === undefined ? message.trackTypes[j] : $root.havocai.messages.v0.TrackType[message.trackTypes[j]] : message.trackTypes[j];
                    }
                    if (message.trackAffiliations && message.trackAffiliations.length) {
                        object.trackAffiliations = [];
                        for (let j = 0; j < message.trackAffiliations.length; ++j)
                            object.trackAffiliations[j] = options.enums === String ? $root.havocai.messages.v0.Affiliation[message.trackAffiliations[j]] === undefined ? message.trackAffiliations[j] : $root.havocai.messages.v0.Affiliation[message.trackAffiliations[j]] : message.trackAffiliations[j];
                    }
                    if (message.trackAffiliationConfidence != null && message.hasOwnProperty("trackAffiliationConfidence"))
                        object.trackAffiliationConfidence = options.json && !isFinite(message.trackAffiliationConfidence) ? String(message.trackAffiliationConfidence) : message.trackAffiliationConfidence;
                    return object;
                };

                /**
                 * Converts this TrackCriteria to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.TrackCriteria
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TrackCriteria.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TrackCriteria
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.TrackCriteria
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TrackCriteria.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.TrackCriteria";
                };

                return TrackCriteria;
            })();

            /**
             * Affiliation enum.
             * @name havocai.messages.v0.Affiliation
             * @enum {number}
             * @property {number} AFFILIATION_UNKNOWN=0 AFFILIATION_UNKNOWN value
             * @property {number} AFFILIATION_ASSUMED_FRIENDLY=1 AFFILIATION_ASSUMED_FRIENDLY value
             * @property {number} AFFILIATION_FRIENDLY=2 AFFILIATION_FRIENDLY value
             * @property {number} AFFILIATION_NEUTRAL=3 AFFILIATION_NEUTRAL value
             * @property {number} AFFILIATION_SUSPECT=4 AFFILIATION_SUSPECT value
             * @property {number} AFFILIATION_HOSTILE=5 AFFILIATION_HOSTILE value
             */
            v0.Affiliation = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "AFFILIATION_UNKNOWN"] = 0;
                values[valuesById[1] = "AFFILIATION_ASSUMED_FRIENDLY"] = 1;
                values[valuesById[2] = "AFFILIATION_FRIENDLY"] = 2;
                values[valuesById[3] = "AFFILIATION_NEUTRAL"] = 3;
                values[valuesById[4] = "AFFILIATION_SUSPECT"] = 4;
                values[valuesById[5] = "AFFILIATION_HOSTILE"] = 5;
                return values;
            })();

            /**
             * BoatManeuver enum.
             * @name havocai.messages.v0.BoatManeuver
             * @enum {number}
             * @property {number} BOAT_MANEUVER_UNKNOWN=0 BOAT_MANEUVER_UNKNOWN value
             * @property {number} BOAT_MANEUVER_MOVE=1 BOAT_MANEUVER_MOVE value
             * @property {number} BOAT_MANEUVER_WAIT=2 BOAT_MANEUVER_WAIT value
             */
            v0.BoatManeuver = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "BOAT_MANEUVER_UNKNOWN"] = 0;
                values[valuesById[1] = "BOAT_MANEUVER_MOVE"] = 1;
                values[valuesById[2] = "BOAT_MANEUVER_WAIT"] = 2;
                return values;
            })();

            /**
             * Command enum.
             * @name havocai.messages.v0.Command
             * @enum {number}
             * @property {number} COMMAND_UNKNOWN=0 COMMAND_UNKNOWN value
             * @property {number} COMMAND_CANCEL=1 COMMAND_CANCEL value
             * @property {number} COMMAND_GO=2 COMMAND_GO value
             * @property {number} COMMAND_AUTHORIZE=3 COMMAND_AUTHORIZE value
             * @property {number} COMMAND_CUSTOM=4 COMMAND_CUSTOM value
             * @property {number} COMMAND_AUTHORIZE_TASK=5 COMMAND_AUTHORIZE_TASK value
             * @property {number} COMMAND_EXECUTE_TASK=6 COMMAND_EXECUTE_TASK value
             * @property {number} COMMAND_TRIGGER_PAYLOAD=7 COMMAND_TRIGGER_PAYLOAD value
             */
            v0.Command = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COMMAND_UNKNOWN"] = 0;
                values[valuesById[1] = "COMMAND_CANCEL"] = 1;
                values[valuesById[2] = "COMMAND_GO"] = 2;
                values[valuesById[3] = "COMMAND_AUTHORIZE"] = 3;
                values[valuesById[4] = "COMMAND_CUSTOM"] = 4;
                values[valuesById[5] = "COMMAND_AUTHORIZE_TASK"] = 5;
                values[valuesById[6] = "COMMAND_EXECUTE_TASK"] = 6;
                values[valuesById[7] = "COMMAND_TRIGGER_PAYLOAD"] = 7;
                return values;
            })();

            /**
             * ComponentKey enum.
             * @name havocai.messages.v0.ComponentKey
             * @enum {number}
             * @property {number} COMPONENT_KEY_UNKNOWN=0 COMPONENT_KEY_UNKNOWN value
             * @property {number} COMPONENT_KEY_BATTERY=1 COMPONENT_KEY_BATTERY value
             * @property {number} COMPONENT_KEY_COMMS=2 COMPONENT_KEY_COMMS value
             * @property {number} COMPONENT_KEY_SENSORS=3 COMPONENT_KEY_SENSORS value
             * @property {number} COMPONENT_KEY_GPS=4 COMPONENT_KEY_GPS value
             * @property {number} COMPONENT_KEY_MISSION_MANAGER=5 COMPONENT_KEY_MISSION_MANAGER value
             */
            v0.ComponentKey = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COMPONENT_KEY_UNKNOWN"] = 0;
                values[valuesById[1] = "COMPONENT_KEY_BATTERY"] = 1;
                values[valuesById[2] = "COMPONENT_KEY_COMMS"] = 2;
                values[valuesById[3] = "COMPONENT_KEY_SENSORS"] = 3;
                values[valuesById[4] = "COMPONENT_KEY_GPS"] = 4;
                values[valuesById[5] = "COMPONENT_KEY_MISSION_MANAGER"] = 5;
                return values;
            })();

            /**
             * CooperativeConfig enum.
             * @name havocai.messages.v0.CooperativeConfig
             * @enum {number}
             * @property {number} COOPERATIVE_CONFIG_UNKNOWN=0 COOPERATIVE_CONFIG_UNKNOWN value
             * @property {number} COOPERATIVE_CONFIG_CIRCLE=1 COOPERATIVE_CONFIG_CIRCLE value
             * @property {number} COOPERATIVE_CONFIG_LINE=2 COOPERATIVE_CONFIG_LINE value
             * @property {number} COOPERATIVE_CONFIG_BLOCKADE=3 COOPERATIVE_CONFIG_BLOCKADE value
             * @property {number} COOPERATIVE_CONFIG_ELLIPSE=4 COOPERATIVE_CONFIG_ELLIPSE value
             */
            v0.CooperativeConfig = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COOPERATIVE_CONFIG_UNKNOWN"] = 0;
                values[valuesById[1] = "COOPERATIVE_CONFIG_CIRCLE"] = 1;
                values[valuesById[2] = "COOPERATIVE_CONFIG_LINE"] = 2;
                values[valuesById[3] = "COOPERATIVE_CONFIG_BLOCKADE"] = 3;
                values[valuesById[4] = "COOPERATIVE_CONFIG_ELLIPSE"] = 4;
                return values;
            })();

            /**
             * CredibilityRating enum.
             * @name havocai.messages.v0.CredibilityRating
             * @enum {number}
             * @property {number} CREDIBILITY_UNKNOWN=0 CREDIBILITY_UNKNOWN value
             * @property {number} CREDIBILITY_IMPROBABLE=1 CREDIBILITY_IMPROBABLE value
             * @property {number} CREDIBILITY_DOUBTFUL=2 CREDIBILITY_DOUBTFUL value
             * @property {number} CREDIBILITY_POSSIBLE=3 CREDIBILITY_POSSIBLE value
             * @property {number} CREDIBILITY_PROBABLE=4 CREDIBILITY_PROBABLE value
             * @property {number} CREDIBILITY_CONFIRMED=5 CREDIBILITY_CONFIRMED value
             */
            v0.CredibilityRating = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CREDIBILITY_UNKNOWN"] = 0;
                values[valuesById[1] = "CREDIBILITY_IMPROBABLE"] = 1;
                values[valuesById[2] = "CREDIBILITY_DOUBTFUL"] = 2;
                values[valuesById[3] = "CREDIBILITY_POSSIBLE"] = 3;
                values[valuesById[4] = "CREDIBILITY_PROBABLE"] = 4;
                values[valuesById[5] = "CREDIBILITY_CONFIRMED"] = 5;
                return values;
            })();

            /**
             * Encoding enum.
             * @name havocai.messages.v0.Encoding
             * @enum {number}
             * @property {number} ENCODING_JSON=0 ENCODING_JSON value
             * @property {number} ENCODING_PROTOBUF=1 ENCODING_PROTOBUF value
             */
            v0.Encoding = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ENCODING_JSON"] = 0;
                values[valuesById[1] = "ENCODING_PROTOBUF"] = 1;
                return values;
            })();

            /**
             * TrackType enum.
             * @name havocai.messages.v0.TrackType
             * @enum {number}
             * @property {number} TRACK_TYPE_UNKNOWN=0 TRACK_TYPE_UNKNOWN value
             * @property {number} TRACK_TYPE_AIS=1 TRACK_TYPE_AIS value
             * @property {number} TRACK_TYPE_RADAR=2 TRACK_TYPE_RADAR value
             * @property {number} TRACK_TYPE_EO=3 TRACK_TYPE_EO value
             * @property {number} TRACK_TYPE_FUSED=4 TRACK_TYPE_FUSED value
             * @property {number} TRACK_TYPE_USER_CREATED=5 TRACK_TYPE_USER_CREATED value
             * @property {number} TRACK_TYPE_EXTERNAL_SYSTEM=6 TRACK_TYPE_EXTERNAL_SYSTEM value
             * @property {number} TRACK_TYPE_RF=7 TRACK_TYPE_RF value
             * @property {number} TRACK_TYPE_PERSON=8 TRACK_TYPE_PERSON value
             * @property {number} TRACK_TYPE_MISSILE=9 TRACK_TYPE_MISSILE value
             * @property {number} TRACK_TYPE_TORPEDO=10 TRACK_TYPE_TORPEDO value
             * @property {number} TRACK_TYPE_RUBBER_DUCKIE=98 TRACK_TYPE_RUBBER_DUCKIE value
             * @property {number} TRACK_TYPE_NERF_DART=99 TRACK_TYPE_NERF_DART value
             */
            v0.TrackType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TRACK_TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "TRACK_TYPE_AIS"] = 1;
                values[valuesById[2] = "TRACK_TYPE_RADAR"] = 2;
                values[valuesById[3] = "TRACK_TYPE_EO"] = 3;
                values[valuesById[4] = "TRACK_TYPE_FUSED"] = 4;
                values[valuesById[5] = "TRACK_TYPE_USER_CREATED"] = 5;
                values[valuesById[6] = "TRACK_TYPE_EXTERNAL_SYSTEM"] = 6;
                values[valuesById[7] = "TRACK_TYPE_RF"] = 7;
                values[valuesById[8] = "TRACK_TYPE_PERSON"] = 8;
                values[valuesById[9] = "TRACK_TYPE_MISSILE"] = 9;
                values[valuesById[10] = "TRACK_TYPE_TORPEDO"] = 10;
                values[valuesById[98] = "TRACK_TYPE_RUBBER_DUCKIE"] = 98;
                values[valuesById[99] = "TRACK_TYPE_NERF_DART"] = 99;
                return values;
            })();

            /**
             * ErrorLevel enum.
             * @name havocai.messages.v0.ErrorLevel
             * @enum {number}
             * @property {number} ERROR_LEVEL_UNKNOWN=0 ERROR_LEVEL_UNKNOWN value
             * @property {number} ERROR_LEVEL_WARNING=1 ERROR_LEVEL_WARNING value
             * @property {number} ERROR_LEVEL_MINOR=2 ERROR_LEVEL_MINOR value
             * @property {number} ERROR_LEVEL_MAJOR=3 ERROR_LEVEL_MAJOR value
             * @property {number} ERROR_LEVEL_CRITICAL=4 ERROR_LEVEL_CRITICAL value
             */
            v0.ErrorLevel = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ERROR_LEVEL_UNKNOWN"] = 0;
                values[valuesById[1] = "ERROR_LEVEL_WARNING"] = 1;
                values[valuesById[2] = "ERROR_LEVEL_MINOR"] = 2;
                values[valuesById[3] = "ERROR_LEVEL_MAJOR"] = 3;
                values[valuesById[4] = "ERROR_LEVEL_CRITICAL"] = 4;
                return values;
            })();

            /**
             * EventType enum.
             * @name havocai.messages.v0.EventType
             * @enum {number}
             * @property {number} EVENT_TYPE_UNKNOWN=0 EVENT_TYPE_UNKNOWN value
             * @property {number} EVENT_TYPE_NOTIFICATION=1 EVENT_TYPE_NOTIFICATION value
             * @property {number} EVENT_TYPE_RESOURCE_CREATED=2 EVENT_TYPE_RESOURCE_CREATED value
             * @property {number} EVENT_TYPE_RESOURCE_UPDATED=3 EVENT_TYPE_RESOURCE_UPDATED value
             * @property {number} EVENT_TYPE_RESOURCE_DELETED=4 EVENT_TYPE_RESOURCE_DELETED value
             */
            v0.EventType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "EVENT_TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "EVENT_TYPE_NOTIFICATION"] = 1;
                values[valuesById[2] = "EVENT_TYPE_RESOURCE_CREATED"] = 2;
                values[valuesById[3] = "EVENT_TYPE_RESOURCE_UPDATED"] = 3;
                values[valuesById[4] = "EVENT_TYPE_RESOURCE_DELETED"] = 4;
                return values;
            })();

            /**
             * GeoFenceType enum.
             * @name havocai.messages.v0.GeoFenceType
             * @enum {number}
             * @property {number} GEO_FENCE_TYPE_UNKNOWN=0 GEO_FENCE_TYPE_UNKNOWN value
             * @property {number} GEO_FENCE_TYPE_RESTRICTED=1 GEO_FENCE_TYPE_RESTRICTED value
             * @property {number} GEO_FENCE_TYPE_REQUIRED=2 GEO_FENCE_TYPE_REQUIRED value
             * @property {number} GEO_FENCE_TYPE_PERMITTED=3 GEO_FENCE_TYPE_PERMITTED value
             * @property {number} GEO_FENCE_TYPE_PREFERRED=4 GEO_FENCE_TYPE_PREFERRED value
             */
            v0.GeoFenceType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "GEO_FENCE_TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "GEO_FENCE_TYPE_RESTRICTED"] = 1;
                values[valuesById[2] = "GEO_FENCE_TYPE_REQUIRED"] = 2;
                values[valuesById[3] = "GEO_FENCE_TYPE_PERMITTED"] = 3;
                values[valuesById[4] = "GEO_FENCE_TYPE_PREFERRED"] = 4;
                return values;
            })();

            /**
             * Health enum.
             * @name havocai.messages.v0.Health
             * @enum {number}
             * @property {number} HEALTH_UNKNOWN=0 HEALTH_UNKNOWN value
             * @property {number} HEALTH_HEALTHY=1 HEALTH_HEALTHY value
             * @property {number} HEALTH_DEGRADED=2 HEALTH_DEGRADED value
             * @property {number} HEALTH_FATAL=3 HEALTH_FATAL value
             */
            v0.Health = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "HEALTH_UNKNOWN"] = 0;
                values[valuesById[1] = "HEALTH_HEALTHY"] = 1;
                values[valuesById[2] = "HEALTH_DEGRADED"] = 2;
                values[valuesById[3] = "HEALTH_FATAL"] = 3;
                return values;
            })();

            /**
             * MetricKey enum.
             * @name havocai.messages.v0.MetricKey
             * @enum {number}
             * @property {number} METRIC_KEY_UNKNOWN=0 METRIC_KEY_UNKNOWN value
             * @property {number} METRIC_KEY_VOLTAGE=1 METRIC_KEY_VOLTAGE value
             * @property {number} METRIC_KEY_POWER=2 METRIC_KEY_POWER value
             * @property {number} METRIC_KEY_ENERGY_CAPACITY=3 METRIC_KEY_ENERGY_CAPACITY value
             * @property {number} METRIC_KEY_ENERGY_REMAINING=4 METRIC_KEY_ENERGY_REMAINING value
             * @property {number} METRIC_KEY_BATTERY_CHARGE=5 METRIC_KEY_BATTERY_CHARGE value
             * @property {number} METRIC_KEY_SENSOR_RANGE=6 METRIC_KEY_SENSOR_RANGE value
             * @property {number} METRIC_KEY_BATTERY_CURRENT=7 METRIC_KEY_BATTERY_CURRENT value
             * @property {number} METRIC_KEY_BATTERY_TEMPERATURE=8 METRIC_KEY_BATTERY_TEMPERATURE value
             */
            v0.MetricKey = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "METRIC_KEY_UNKNOWN"] = 0;
                values[valuesById[1] = "METRIC_KEY_VOLTAGE"] = 1;
                values[valuesById[2] = "METRIC_KEY_POWER"] = 2;
                values[valuesById[3] = "METRIC_KEY_ENERGY_CAPACITY"] = 3;
                values[valuesById[4] = "METRIC_KEY_ENERGY_REMAINING"] = 4;
                values[valuesById[5] = "METRIC_KEY_BATTERY_CHARGE"] = 5;
                values[valuesById[6] = "METRIC_KEY_SENSOR_RANGE"] = 6;
                values[valuesById[7] = "METRIC_KEY_BATTERY_CURRENT"] = 7;
                values[valuesById[8] = "METRIC_KEY_BATTERY_TEMPERATURE"] = 8;
                return values;
            })();

            /**
             * MetricType enum.
             * @name havocai.messages.v0.MetricType
             * @enum {number}
             * @property {number} METRIC_TYPE_UNKNOWN=0 METRIC_TYPE_UNKNOWN value
             * @property {number} METRIC_TYPE_BOOL=1 METRIC_TYPE_BOOL value
             * @property {number} METRIC_TYPE_NUMBER=2 METRIC_TYPE_NUMBER value
             * @property {number} METRIC_TYPE_PERCENTAGE=3 METRIC_TYPE_PERCENTAGE value
             */
            v0.MetricType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "METRIC_TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "METRIC_TYPE_BOOL"] = 1;
                values[valuesById[2] = "METRIC_TYPE_NUMBER"] = 2;
                values[valuesById[3] = "METRIC_TYPE_PERCENTAGE"] = 3;
                return values;
            })();

            /**
             * PlayKey enum.
             * @name havocai.messages.v0.PlayKey
             * @enum {number}
             * @property {number} PLAY_KEY_UNKNOWN=0 PLAY_KEY_UNKNOWN value
             * @property {number} PLAY_KEY_NONE=1 PLAY_KEY_NONE value
             * @property {number} PLAY_KEY_DIRECT=2 PLAY_KEY_DIRECT value
             * @property {number} PLAY_KEY_CONTESTED_LOGISTICS=3 PLAY_KEY_CONTESTED_LOGISTICS value
             * @property {number} PLAY_KEY_PAYLOAD_ORCHESTRATION=4 PLAY_KEY_PAYLOAD_ORCHESTRATION value
             * @property {number} PLAY_KEY_FIND_FIX_INVESTIGATE=5 PLAY_KEY_FIND_FIX_INVESTIGATE value
             * @property {number} PLAY_KEY_FIND_FIX_INVESTIGATE_EPISCI=6 PLAY_KEY_FIND_FIX_INVESTIGATE_EPISCI value
             * @property {number} PLAY_KEY_CHECKOUT=7 PLAY_KEY_CHECKOUT value
             * @property {number} PLAY_KEY_BEACH_LAUNCH=8 PLAY_KEY_BEACH_LAUNCH value
             * @property {number} PLAY_KEY_AVAST=9 PLAY_KEY_AVAST value
             * @property {number} PLAY_KEY_JAZZ=10 PLAY_KEY_JAZZ value
             * @property {number} PLAY_KEY_CHARIOT_RAMP_CONTROL=11 PLAY_KEY_CHARIOT_RAMP_CONTROL value
             * @property {number} PLAY_KEY_CHARIOT_RESUPPLY=12 PLAY_KEY_CHARIOT_RESUPPLY value
             * @property {number} PLAY_KEY_ENGAGE_TRACK=13 PLAY_KEY_ENGAGE_TRACK value
             * @property {number} PLAY_KEY_DYNAMIC=14 PLAY_KEY_DYNAMIC value
             */
            v0.PlayKey = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "PLAY_KEY_UNKNOWN"] = 0;
                values[valuesById[1] = "PLAY_KEY_NONE"] = 1;
                values[valuesById[2] = "PLAY_KEY_DIRECT"] = 2;
                values[valuesById[3] = "PLAY_KEY_CONTESTED_LOGISTICS"] = 3;
                values[valuesById[4] = "PLAY_KEY_PAYLOAD_ORCHESTRATION"] = 4;
                values[valuesById[5] = "PLAY_KEY_FIND_FIX_INVESTIGATE"] = 5;
                values[valuesById[6] = "PLAY_KEY_FIND_FIX_INVESTIGATE_EPISCI"] = 6;
                values[valuesById[7] = "PLAY_KEY_CHECKOUT"] = 7;
                values[valuesById[8] = "PLAY_KEY_BEACH_LAUNCH"] = 8;
                values[valuesById[9] = "PLAY_KEY_AVAST"] = 9;
                values[valuesById[10] = "PLAY_KEY_JAZZ"] = 10;
                values[valuesById[11] = "PLAY_KEY_CHARIOT_RAMP_CONTROL"] = 11;
                values[valuesById[12] = "PLAY_KEY_CHARIOT_RESUPPLY"] = 12;
                values[valuesById[13] = "PLAY_KEY_ENGAGE_TRACK"] = 13;
                values[valuesById[14] = "PLAY_KEY_DYNAMIC"] = 14;
                return values;
            })();

            /**
             * DataSource enum.
             * @name havocai.messages.v0.DataSource
             * @enum {number}
             * @property {number} DATA_SOURCE_UNKNOWN=0 DATA_SOURCE_UNKNOWN value
             * @property {number} DATA_SOURCE_API=1 DATA_SOURCE_API value
             * @property {number} DATA_SOURCE_TAK=2 DATA_SOURCE_TAK value
             * @property {number} DATA_SOURCE_LATTICE=3 DATA_SOURCE_LATTICE value
             */
            v0.DataSource = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DATA_SOURCE_UNKNOWN"] = 0;
                values[valuesById[1] = "DATA_SOURCE_API"] = 1;
                values[valuesById[2] = "DATA_SOURCE_TAK"] = 2;
                values[valuesById[3] = "DATA_SOURCE_LATTICE"] = 3;
                return values;
            })();

            /**
             * PlayState enum.
             * @name havocai.messages.v0.PlayState
             * @enum {number}
             * @property {number} PLAY_STATE_UNKNOWN=0 PLAY_STATE_UNKNOWN value
             * @property {number} PLAY_STATE_IDLE=1 PLAY_STATE_IDLE value
             * @property {number} PLAY_STATE_PENDING=2 PLAY_STATE_PENDING value
             * @property {number} PLAY_STATE_ACTIVE=3 PLAY_STATE_ACTIVE value
             * @property {number} PLAY_STATE_COMPLETE=4 PLAY_STATE_COMPLETE value
             * @property {number} PLAY_STATE_CANCELED=5 PLAY_STATE_CANCELED value
             * @property {number} PLAY_STATE_FAILED=6 PLAY_STATE_FAILED value
             */
            v0.PlayState = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "PLAY_STATE_UNKNOWN"] = 0;
                values[valuesById[1] = "PLAY_STATE_IDLE"] = 1;
                values[valuesById[2] = "PLAY_STATE_PENDING"] = 2;
                values[valuesById[3] = "PLAY_STATE_ACTIVE"] = 3;
                values[valuesById[4] = "PLAY_STATE_COMPLETE"] = 4;
                values[valuesById[5] = "PLAY_STATE_CANCELED"] = 5;
                values[valuesById[6] = "PLAY_STATE_FAILED"] = 6;
                return values;
            })();

            /**
             * TaskState enum.
             * @name havocai.messages.v0.TaskState
             * @enum {number}
             * @property {number} TASK_STATE_UNKNOWN=0 TASK_STATE_UNKNOWN value
             * @property {number} TASK_STATE_ACTIVE=1 TASK_STATE_ACTIVE value
             * @property {number} TASK_STATE_AWAITING_CONDITIONAL=2 TASK_STATE_AWAITING_CONDITIONAL value
             * @property {number} TASK_STATE_COMPLETE=3 TASK_STATE_COMPLETE value
             * @property {number} TASK_STATE_CANCELED=4 TASK_STATE_CANCELED value
             * @property {number} TASK_STATE_FAILED=5 TASK_STATE_FAILED value
             */
            v0.TaskState = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TASK_STATE_UNKNOWN"] = 0;
                values[valuesById[1] = "TASK_STATE_ACTIVE"] = 1;
                values[valuesById[2] = "TASK_STATE_AWAITING_CONDITIONAL"] = 2;
                values[valuesById[3] = "TASK_STATE_COMPLETE"] = 3;
                values[valuesById[4] = "TASK_STATE_CANCELED"] = 4;
                values[valuesById[5] = "TASK_STATE_FAILED"] = 5;
                return values;
            })();

            /**
             * ResourceKind enum.
             * @name havocai.messages.v0.ResourceKind
             * @enum {number}
             * @property {number} RESOURCE_KIND_UNKNOWN=0 RESOURCE_KIND_UNKNOWN value
             * @property {number} RESOURCE_KIND_SECTOR=1 RESOURCE_KIND_SECTOR value
             * @property {number} RESOURCE_KIND_ZONE=2 RESOURCE_KIND_ZONE value
             * @property {number} RESOURCE_KIND_TEAM=3 RESOURCE_KIND_TEAM value
             * @property {number} RESOURCE_KIND_BOAT=4 RESOURCE_KIND_BOAT value
             * @property {number} RESOURCE_KIND_TRACK=6 RESOURCE_KIND_TRACK value
             * @property {number} RESOURCE_KIND_PLAY_DEFINITION=7 RESOURCE_KIND_PLAY_DEFINITION value
             * @property {number} RESOURCE_KIND_PLAY_EXECUTION=8 RESOURCE_KIND_PLAY_EXECUTION value
             * @property {number} RESOURCE_KIND_PLAY_RUNNER=9 RESOURCE_KIND_PLAY_RUNNER value
             * @property {number} RESOURCE_KIND_SIMULATION=10 RESOURCE_KIND_SIMULATION value
             */
            v0.ResourceKind = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "RESOURCE_KIND_UNKNOWN"] = 0;
                values[valuesById[1] = "RESOURCE_KIND_SECTOR"] = 1;
                values[valuesById[2] = "RESOURCE_KIND_ZONE"] = 2;
                values[valuesById[3] = "RESOURCE_KIND_TEAM"] = 3;
                values[valuesById[4] = "RESOURCE_KIND_BOAT"] = 4;
                values[valuesById[6] = "RESOURCE_KIND_TRACK"] = 6;
                values[valuesById[7] = "RESOURCE_KIND_PLAY_DEFINITION"] = 7;
                values[valuesById[8] = "RESOURCE_KIND_PLAY_EXECUTION"] = 8;
                values[valuesById[9] = "RESOURCE_KIND_PLAY_RUNNER"] = 9;
                values[valuesById[10] = "RESOURCE_KIND_SIMULATION"] = 10;
                return values;
            })();

            /**
             * TaskKey enum.
             * @name havocai.messages.v0.TaskKey
             * @enum {number}
             * @property {number} TASK_KEY_UNKNOWN=0 TASK_KEY_UNKNOWN value
             * @property {number} TASK_KEY_NONE=1 TASK_KEY_NONE value
             * @property {number} TASK_KEY_DIRECT_MOVE_GOAL=2 TASK_KEY_DIRECT_MOVE_GOAL value
             * @property {number} TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_STAGING=3 TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_STAGING value
             * @property {number} TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_STAGING=4 TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_STAGING value
             * @property {number} TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_LANDING=5 TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_LANDING value
             * @property {number} TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_LANDING=6 TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_LANDING value
             * @property {number} TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_EGRESS=7 TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_EGRESS value
             * @property {number} TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_EGRESS=8 TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_EGRESS value
             * @property {number} TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_STAGING=9 TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_STAGING value
             * @property {number} TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_STAGING=10 TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_STAGING value
             * @property {number} TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_LANDING=11 TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_LANDING value
             * @property {number} TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_LANDING=12 TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_LANDING value
             * @property {number} TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_EGRESS=13 TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_EGRESS value
             * @property {number} TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_EGRESS=14 TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_EGRESS value
             * @property {number} TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP=15 TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP value
             * @property {number} TASK_KEY_PAYLOAD_ORCHESTRATION_MOVE_TRACK=16 TASK_KEY_PAYLOAD_ORCHESTRATION_MOVE_TRACK value
             * @property {number} TASK_KEY_FIND_FIX_INVESTIGATE_FIND_TRACK=17 TASK_KEY_FIND_FIX_INVESTIGATE_FIND_TRACK value
             * @property {number} TASK_KEY_FIND_FIX_INVESTIGATE_INVESTIGATE_TRACK=18 TASK_KEY_FIND_FIX_INVESTIGATE_INVESTIGATE_TRACK value
             * @property {number} TASK_KEY_CHECKOUT_WAIT=19 TASK_KEY_CHECKOUT_WAIT value
             * @property {number} TASK_KEY_CHECKOUT_TEST_DRIVE=20 TASK_KEY_CHECKOUT_TEST_DRIVE value
             * @property {number} TASK_KEY_BEACH_LAUNCH_WAIT=21 TASK_KEY_BEACH_LAUNCH_WAIT value
             * @property {number} TASK_KEY_BEACH_LAUNCH_DEPLOY=22 TASK_KEY_BEACH_LAUNCH_DEPLOY value
             * @property {number} TASK_KEY_BEACH_LAUNCH_MOVE_EGRESS=23 TASK_KEY_BEACH_LAUNCH_MOVE_EGRESS value
             * @property {number} TASK_KEY_AVAST_WAIT=24 TASK_KEY_AVAST_WAIT value
             * @property {number} TASK_KEY_JAZZ_ACTIVE=25 TASK_KEY_JAZZ_ACTIVE value
             * @property {number} TASK_KEY_CHARIOT_RAMP_CONTROL_ACTIVE=26 TASK_KEY_CHARIOT_RAMP_CONTROL_ACTIVE value
             * @property {number} TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_STAGING=27 TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_STAGING value
             * @property {number} TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_SHORE=28 TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_SHORE value
             * @property {number} TASK_KEY_CHARIOT_RESUPPLY_LANDING_CONFIRMATION=29 TASK_KEY_CHARIOT_RESUPPLY_LANDING_CONFIRMATION value
             * @property {number} TASK_KEY_CHARIOT_RESUPPLY_DEPART_CONFIRMATION=30 TASK_KEY_CHARIOT_RESUPPLY_DEPART_CONFIRMATION value
             * @property {number} TASK_KEY_CHARIOT_RESUPPLY_MOVE_OFF_SHORE=31 TASK_KEY_CHARIOT_RESUPPLY_MOVE_OFF_SHORE value
             * @property {number} TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_EGRESS=32 TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_EGRESS value
             * @property {number} TASK_KEY_ENGAGE_TRACK=33 TASK_KEY_ENGAGE_TRACK value
             */
            v0.TaskKey = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TASK_KEY_UNKNOWN"] = 0;
                values[valuesById[1] = "TASK_KEY_NONE"] = 1;
                values[valuesById[2] = "TASK_KEY_DIRECT_MOVE_GOAL"] = 2;
                values[valuesById[3] = "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_STAGING"] = 3;
                values[valuesById[4] = "TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_STAGING"] = 4;
                values[valuesById[5] = "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_LANDING"] = 5;
                values[valuesById[6] = "TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_LANDING"] = 6;
                values[valuesById[7] = "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_EGRESS"] = 7;
                values[valuesById[8] = "TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_EGRESS"] = 8;
                values[valuesById[9] = "TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_STAGING"] = 9;
                values[valuesById[10] = "TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_STAGING"] = 10;
                values[valuesById[11] = "TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_LANDING"] = 11;
                values[valuesById[12] = "TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_LANDING"] = 12;
                values[valuesById[13] = "TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_EGRESS"] = 13;
                values[valuesById[14] = "TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_EGRESS"] = 14;
                values[valuesById[15] = "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP"] = 15;
                values[valuesById[16] = "TASK_KEY_PAYLOAD_ORCHESTRATION_MOVE_TRACK"] = 16;
                values[valuesById[17] = "TASK_KEY_FIND_FIX_INVESTIGATE_FIND_TRACK"] = 17;
                values[valuesById[18] = "TASK_KEY_FIND_FIX_INVESTIGATE_INVESTIGATE_TRACK"] = 18;
                values[valuesById[19] = "TASK_KEY_CHECKOUT_WAIT"] = 19;
                values[valuesById[20] = "TASK_KEY_CHECKOUT_TEST_DRIVE"] = 20;
                values[valuesById[21] = "TASK_KEY_BEACH_LAUNCH_WAIT"] = 21;
                values[valuesById[22] = "TASK_KEY_BEACH_LAUNCH_DEPLOY"] = 22;
                values[valuesById[23] = "TASK_KEY_BEACH_LAUNCH_MOVE_EGRESS"] = 23;
                values[valuesById[24] = "TASK_KEY_AVAST_WAIT"] = 24;
                values[valuesById[25] = "TASK_KEY_JAZZ_ACTIVE"] = 25;
                values[valuesById[26] = "TASK_KEY_CHARIOT_RAMP_CONTROL_ACTIVE"] = 26;
                values[valuesById[27] = "TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_STAGING"] = 27;
                values[valuesById[28] = "TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_SHORE"] = 28;
                values[valuesById[29] = "TASK_KEY_CHARIOT_RESUPPLY_LANDING_CONFIRMATION"] = 29;
                values[valuesById[30] = "TASK_KEY_CHARIOT_RESUPPLY_DEPART_CONFIRMATION"] = 30;
                values[valuesById[31] = "TASK_KEY_CHARIOT_RESUPPLY_MOVE_OFF_SHORE"] = 31;
                values[valuesById[32] = "TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_EGRESS"] = 32;
                values[valuesById[33] = "TASK_KEY_ENGAGE_TRACK"] = 33;
                return values;
            })();

            /**
             * WaypointType enum.
             * @name havocai.messages.v0.WaypointType
             * @enum {number}
             * @property {number} WAYPOINT_TYPE_UNKNOWN=0 WAYPOINT_TYPE_UNKNOWN value
             * @property {number} WAYPOINT_TYPE_LANDING=1 WAYPOINT_TYPE_LANDING value
             * @property {number} WAYPOINT_TYPE_EGRESS=2 WAYPOINT_TYPE_EGRESS value
             * @property {number} WAYPOINT_TYPE_STAGING=3 WAYPOINT_TYPE_STAGING value
             */
            v0.WaypointType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "WAYPOINT_TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "WAYPOINT_TYPE_LANDING"] = 1;
                values[valuesById[2] = "WAYPOINT_TYPE_EGRESS"] = 2;
                values[valuesById[3] = "WAYPOINT_TYPE_STAGING"] = 3;
                return values;
            })();

            /**
             * MarkerType enum.
             * @name havocai.messages.v0.MarkerType
             * @enum {number}
             * @property {number} MARKER_TYPE_UNKNOWN=0 MARKER_TYPE_UNKNOWN value
             * @property {number} MARKER_TYPE_LANDING=1 MARKER_TYPE_LANDING value
             * @property {number} MARKER_TYPE_EGRESS=2 MARKER_TYPE_EGRESS value
             * @property {number} MARKER_TYPE_STAGING=3 MARKER_TYPE_STAGING value
             * @property {number} MARKER_TYPE_LANDMARK=4 MARKER_TYPE_LANDMARK value
             * @property {number} MARKER_TYPE_HAZARD=5 MARKER_TYPE_HAZARD value
             */
            v0.MarkerType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MARKER_TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "MARKER_TYPE_LANDING"] = 1;
                values[valuesById[2] = "MARKER_TYPE_EGRESS"] = 2;
                values[valuesById[3] = "MARKER_TYPE_STAGING"] = 3;
                values[valuesById[4] = "MARKER_TYPE_LANDMARK"] = 4;
                values[valuesById[5] = "MARKER_TYPE_HAZARD"] = 5;
                return values;
            })();

            /**
             * ZoneType enum.
             * @name havocai.messages.v0.ZoneType
             * @enum {number}
             * @property {number} ZONE_TYPE_UNKNOWN=0 ZONE_TYPE_UNKNOWN value
             * @property {number} ZONE_TYPE_BEACH=1 ZONE_TYPE_BEACH value
             * @property {number} ZONE_TYPE_OVERLAY=2 ZONE_TYPE_OVERLAY value
             * @property {number} ZONE_TYPE_ENGAGEMENT=3 ZONE_TYPE_ENGAGEMENT value
             * @property {number} ZONE_TYPE_ROUTE=4 ZONE_TYPE_ROUTE value
             */
            v0.ZoneType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ZONE_TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "ZONE_TYPE_BEACH"] = 1;
                values[valuesById[2] = "ZONE_TYPE_OVERLAY"] = 2;
                values[valuesById[3] = "ZONE_TYPE_ENGAGEMENT"] = 3;
                values[valuesById[4] = "ZONE_TYPE_ROUTE"] = 4;
                return values;
            })();

            /**
             * VehicleType enum.
             * @name havocai.messages.v0.VehicleType
             * @enum {number}
             * @property {number} VEHICLE_TYPE_UNKNOWN=0 VEHICLE_TYPE_UNKNOWN value
             * @property {number} VEHICLE_TYPE_BOAT=1 VEHICLE_TYPE_BOAT value
             * @property {number} VEHICLE_TYPE_ROVER=2 VEHICLE_TYPE_ROVER value
             * @property {number} VEHICLE_TYPE_BARGE=3 VEHICLE_TYPE_BARGE value
             * @property {number} VEHICLE_TYPE_AERIAL_OTHER=4 VEHICLE_TYPE_AERIAL_OTHER value
             * @property {number} VEHICLE_TYPE_AERIAL_MULTIROTOR=5 VEHICLE_TYPE_AERIAL_MULTIROTOR value
             * @property {number} VEHICLE_TYPE_AERIAL_FIXED_WING=6 VEHICLE_TYPE_AERIAL_FIXED_WING value
             * @property {number} VEHICLE_TYPE_AERIAL_HELICOPTER=7 VEHICLE_TYPE_AERIAL_HELICOPTER value
             * @property {number} VEHICLE_TYPE_AERIAL_AIRSHIP=8 VEHICLE_TYPE_AERIAL_AIRSHIP value
             * @property {number} VEHICLE_TYPE_GROUND_OTHER=9 VEHICLE_TYPE_GROUND_OTHER value
             * @property {number} VEHICLE_TYPE_GROUND_WHEELED=10 VEHICLE_TYPE_GROUND_WHEELED value
             * @property {number} VEHICLE_TYPE_GROUND_TRACKED=11 VEHICLE_TYPE_GROUND_TRACKED value
             * @property {number} VEHICLE_TYPE_GROUND_LEGGED=12 VEHICLE_TYPE_GROUND_LEGGED value
             * @property {number} VEHICLE_TYPE_SURFACE_OTHER=13 VEHICLE_TYPE_SURFACE_OTHER value
             * @property {number} VEHICLE_TYPE_SURFACE_VESSEL=14 VEHICLE_TYPE_SURFACE_VESSEL value
             * @property {number} VEHICLE_TYPE_SURFACE_HOVERCRAFT=15 VEHICLE_TYPE_SURFACE_HOVERCRAFT value
             * @property {number} VEHICLE_TYPE_SURFACE_AMPHIBIOUS=16 VEHICLE_TYPE_SURFACE_AMPHIBIOUS value
             * @property {number} VEHICLE_TYPE_UNDERWATER_OTHER=17 VEHICLE_TYPE_UNDERWATER_OTHER value
             * @property {number} VEHICLE_TYPE_SURFACE_RUBBER_DUCKIE=99 VEHICLE_TYPE_SURFACE_RUBBER_DUCKIE value
             */
            v0.VehicleType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "VEHICLE_TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "VEHICLE_TYPE_BOAT"] = 1;
                values[valuesById[2] = "VEHICLE_TYPE_ROVER"] = 2;
                values[valuesById[3] = "VEHICLE_TYPE_BARGE"] = 3;
                values[valuesById[4] = "VEHICLE_TYPE_AERIAL_OTHER"] = 4;
                values[valuesById[5] = "VEHICLE_TYPE_AERIAL_MULTIROTOR"] = 5;
                values[valuesById[6] = "VEHICLE_TYPE_AERIAL_FIXED_WING"] = 6;
                values[valuesById[7] = "VEHICLE_TYPE_AERIAL_HELICOPTER"] = 7;
                values[valuesById[8] = "VEHICLE_TYPE_AERIAL_AIRSHIP"] = 8;
                values[valuesById[9] = "VEHICLE_TYPE_GROUND_OTHER"] = 9;
                values[valuesById[10] = "VEHICLE_TYPE_GROUND_WHEELED"] = 10;
                values[valuesById[11] = "VEHICLE_TYPE_GROUND_TRACKED"] = 11;
                values[valuesById[12] = "VEHICLE_TYPE_GROUND_LEGGED"] = 12;
                values[valuesById[13] = "VEHICLE_TYPE_SURFACE_OTHER"] = 13;
                values[valuesById[14] = "VEHICLE_TYPE_SURFACE_VESSEL"] = 14;
                values[valuesById[15] = "VEHICLE_TYPE_SURFACE_HOVERCRAFT"] = 15;
                values[valuesById[16] = "VEHICLE_TYPE_SURFACE_AMPHIBIOUS"] = 16;
                values[valuesById[17] = "VEHICLE_TYPE_UNDERWATER_OTHER"] = 17;
                values[valuesById[99] = "VEHICLE_TYPE_SURFACE_RUBBER_DUCKIE"] = 99;
                return values;
            })();

            /**
             * SearchStrategy enum.
             * @name havocai.messages.v0.SearchStrategy
             * @enum {number}
             * @property {number} SEARCH_STRATEGY_UNKNOWN=0 SEARCH_STRATEGY_UNKNOWN value
             * @property {number} SEARCH_STRATEGY_RANDOM=1 SEARCH_STRATEGY_RANDOM value
             * @property {number} SEARCH_STRATEGY_SWEEP=2 SEARCH_STRATEGY_SWEEP value
             * @property {number} SEARCH_STRATEGY_SPIRAL=3 SEARCH_STRATEGY_SPIRAL value
             */
            v0.SearchStrategy = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SEARCH_STRATEGY_UNKNOWN"] = 0;
                values[valuesById[1] = "SEARCH_STRATEGY_RANDOM"] = 1;
                values[valuesById[2] = "SEARCH_STRATEGY_SWEEP"] = 2;
                values[valuesById[3] = "SEARCH_STRATEGY_SPIRAL"] = 3;
                return values;
            })();

            /**
             * ActuatorPositionGoal enum.
             * @name havocai.messages.v0.ActuatorPositionGoal
             * @enum {number}
             * @property {number} ACTUATOR_POSITION_GOAL_UNKNOWN=0 ACTUATOR_POSITION_GOAL_UNKNOWN value
             * @property {number} ACTUATOR_POSITION_GOAL_EXTENDED=1 ACTUATOR_POSITION_GOAL_EXTENDED value
             * @property {number} ACTUATOR_POSITION_GOAL_RETRACTED=2 ACTUATOR_POSITION_GOAL_RETRACTED value
             */
            v0.ActuatorPositionGoal = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ACTUATOR_POSITION_GOAL_UNKNOWN"] = 0;
                values[valuesById[1] = "ACTUATOR_POSITION_GOAL_EXTENDED"] = 1;
                values[valuesById[2] = "ACTUATOR_POSITION_GOAL_RETRACTED"] = 2;
                return values;
            })();

            /**
             * VehicleInterfaceStateType enum.
             * @name havocai.messages.v0.VehicleInterfaceStateType
             * @enum {number}
             * @property {number} VEHICLE_INTERFACE_STATE_TYPE_UNSPECIFIED=0 VEHICLE_INTERFACE_STATE_TYPE_UNSPECIFIED value
             * @property {number} VEHICLE_INTERFACE_STATE_TYPE_DISARMED=1 VEHICLE_INTERFACE_STATE_TYPE_DISARMED value
             * @property {number} VEHICLE_INTERFACE_STATE_TYPE_FREE_FLOAT=2 VEHICLE_INTERFACE_STATE_TYPE_FREE_FLOAT value
             * @property {number} VEHICLE_INTERFACE_STATE_TYPE_ROUTE_FOLLOWING=3 VEHICLE_INTERFACE_STATE_TYPE_ROUTE_FOLLOWING value
             * @property {number} VEHICLE_INTERFACE_STATE_TYPE_CONTROLLED_DRIFT=4 VEHICLE_INTERFACE_STATE_TYPE_CONTROLLED_DRIFT value
             * @property {number} VEHICLE_INTERFACE_STATE_TYPE_VECTOR=5 VEHICLE_INTERFACE_STATE_TYPE_VECTOR value
             * @property {number} VEHICLE_INTERFACE_STATE_TYPE_FOLLOW_TARGET=6 VEHICLE_INTERFACE_STATE_TYPE_FOLLOW_TARGET value
             * @property {number} VEHICLE_INTERFACE_STATE_TYPE_REMOTELY_OPERATED=7 VEHICLE_INTERFACE_STATE_TYPE_REMOTELY_OPERATED value
             */
            v0.VehicleInterfaceStateType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "VEHICLE_INTERFACE_STATE_TYPE_UNSPECIFIED"] = 0;
                values[valuesById[1] = "VEHICLE_INTERFACE_STATE_TYPE_DISARMED"] = 1;
                values[valuesById[2] = "VEHICLE_INTERFACE_STATE_TYPE_FREE_FLOAT"] = 2;
                values[valuesById[3] = "VEHICLE_INTERFACE_STATE_TYPE_ROUTE_FOLLOWING"] = 3;
                values[valuesById[4] = "VEHICLE_INTERFACE_STATE_TYPE_CONTROLLED_DRIFT"] = 4;
                values[valuesById[5] = "VEHICLE_INTERFACE_STATE_TYPE_VECTOR"] = 5;
                values[valuesById[6] = "VEHICLE_INTERFACE_STATE_TYPE_FOLLOW_TARGET"] = 6;
                values[valuesById[7] = "VEHICLE_INTERFACE_STATE_TYPE_REMOTELY_OPERATED"] = 7;
                return values;
            })();

            /**
             * TaskType enum.
             * @name havocai.messages.v0.TaskType
             * @enum {number}
             * @property {number} TASK_TYPE_UNSPECIFIED=0 TASK_TYPE_UNSPECIFIED value
             * @property {number} TASK_TYPE_ROUTE=1 TASK_TYPE_ROUTE value
             * @property {number} TASK_TYPE_SEARCH=2 TASK_TYPE_SEARCH value
             * @property {number} TASK_TYPE_ENGAGE=3 TASK_TYPE_ENGAGE value
             * @property {number} TASK_TYPE_COOPERATIVE_FORMATION=4 TASK_TYPE_COOPERATIVE_FORMATION value
             * @property {number} TASK_TYPE_GEO_FORMATION=5 TASK_TYPE_GEO_FORMATION value
             * @property {number} TASK_TYPE_ESCORT=6 TASK_TYPE_ESCORT value
             * @property {number} TASK_TYPE_CHECKOUT=7 TASK_TYPE_CHECKOUT value
             * @property {number} TASK_TYPE_PATROL=8 TASK_TYPE_PATROL value
             * @property {number} TASK_TYPE_DRIFT=9 TASK_TYPE_DRIFT value
             */
            v0.TaskType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TASK_TYPE_UNSPECIFIED"] = 0;
                values[valuesById[1] = "TASK_TYPE_ROUTE"] = 1;
                values[valuesById[2] = "TASK_TYPE_SEARCH"] = 2;
                values[valuesById[3] = "TASK_TYPE_ENGAGE"] = 3;
                values[valuesById[4] = "TASK_TYPE_COOPERATIVE_FORMATION"] = 4;
                values[valuesById[5] = "TASK_TYPE_GEO_FORMATION"] = 5;
                values[valuesById[6] = "TASK_TYPE_ESCORT"] = 6;
                values[valuesById[7] = "TASK_TYPE_CHECKOUT"] = 7;
                values[valuesById[8] = "TASK_TYPE_PATROL"] = 8;
                values[valuesById[9] = "TASK_TYPE_DRIFT"] = 9;
                return values;
            })();

            /**
             * EngagementMode enum.
             * @name havocai.messages.v0.EngagementMode
             * @enum {number}
             * @property {number} ENGAGEMENT_MODE_UNKNOWN=0 ENGAGEMENT_MODE_UNKNOWN value
             * @property {number} ENGAGEMENT_MODE_INDEPENDENT=1 ENGAGEMENT_MODE_INDEPENDENT value
             * @property {number} ENGAGEMENT_MODE_COORDINATED=2 ENGAGEMENT_MODE_COORDINATED value
             */
            v0.EngagementMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ENGAGEMENT_MODE_UNKNOWN"] = 0;
                values[valuesById[1] = "ENGAGEMENT_MODE_INDEPENDENT"] = 1;
                values[valuesById[2] = "ENGAGEMENT_MODE_COORDINATED"] = 2;
                return values;
            })();

            /**
             * Feature enum.
             * @name havocai.messages.v0.Feature
             * @enum {number}
             * @property {number} FEATURE_UNKNOWN=0 FEATURE_UNKNOWN value
             * @property {number} FEATURE_VIDEO_STREAMING=1 FEATURE_VIDEO_STREAMING value
             */
            v0.Feature = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "FEATURE_UNKNOWN"] = 0;
                values[valuesById[1] = "FEATURE_VIDEO_STREAMING"] = 1;
                return values;
            })();

            /**
             * VehicleSizeClass enum.
             * @name havocai.messages.v0.VehicleSizeClass
             * @enum {number}
             * @property {number} VEHICLE_SIZE_CLASS_UNKNOWN=0 VEHICLE_SIZE_CLASS_UNKNOWN value
             * @property {number} VEHICLE_SIZE_CLASS_SMALL=1 VEHICLE_SIZE_CLASS_SMALL value
             * @property {number} VEHICLE_SIZE_CLASS_MEDIUM=2 VEHICLE_SIZE_CLASS_MEDIUM value
             * @property {number} VEHICLE_SIZE_CLASS_LARGE=3 VEHICLE_SIZE_CLASS_LARGE value
             */
            v0.VehicleSizeClass = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "VEHICLE_SIZE_CLASS_UNKNOWN"] = 0;
                values[valuesById[1] = "VEHICLE_SIZE_CLASS_SMALL"] = 1;
                values[valuesById[2] = "VEHICLE_SIZE_CLASS_MEDIUM"] = 2;
                values[valuesById[3] = "VEHICLE_SIZE_CLASS_LARGE"] = 3;
                return values;
            })();

            /**
             * RotationDirection enum.
             * @name havocai.messages.v0.RotationDirection
             * @enum {number}
             * @property {number} ROTATION_DIRECTION_UNKNOWN=0 ROTATION_DIRECTION_UNKNOWN value
             * @property {number} ROTATION_DIRECTION_CLOCKWISE=1 ROTATION_DIRECTION_CLOCKWISE value
             * @property {number} ROTATION_DIRECTION_COUNTERCLOCKWISE=2 ROTATION_DIRECTION_COUNTERCLOCKWISE value
             */
            v0.RotationDirection = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ROTATION_DIRECTION_UNKNOWN"] = 0;
                values[valuesById[1] = "ROTATION_DIRECTION_CLOCKWISE"] = 1;
                values[valuesById[2] = "ROTATION_DIRECTION_COUNTERCLOCKWISE"] = 2;
                return values;
            })();

            /**
             * CDRState enum.
             * @name havocai.messages.v0.CDRState
             * @enum {number}
             * @property {number} CDR_STATE_UNKNOWN=0 CDR_STATE_UNKNOWN value
             * @property {number} CDR_STATE_DISABLED=1 CDR_STATE_DISABLED value
             * @property {number} CDR_STATE_INACTIVE=2 CDR_STATE_INACTIVE value
             * @property {number} CDR_STATE_ACTIVE=3 CDR_STATE_ACTIVE value
             */
            v0.CDRState = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CDR_STATE_UNKNOWN"] = 0;
                values[valuesById[1] = "CDR_STATE_DISABLED"] = 1;
                values[valuesById[2] = "CDR_STATE_INACTIVE"] = 2;
                values[valuesById[3] = "CDR_STATE_ACTIVE"] = 3;
                return values;
            })();

            v0.PlayData = (function() {

                /**
                 * Properties of a PlayData.
                 * @memberof havocai.messages.v0
                 * @interface IPlayData
                 * @property {string|null} [id] PlayData id
                 * @property {havocai.messages.v0.PlayKey|null} [key] PlayData key
                 * @property {havocai.messages.v0.DataSource|null} [dataSource] PlayData dataSource
                 * @property {Array.<havocai.messages.v0.IGeoFence>|null} [geoFences] PlayData geoFences
                 * @property {number|null} [minBoats] PlayData minBoats
                 * @property {number|null} [minCapacity] PlayData minCapacity
                 * @property {boolean|null} [respectGeoFences] PlayData respectGeoFences
                 * @property {havocai.messages.v0.ITaskParams|null} [defaultParams] PlayData defaultParams
                 * @property {Array.<havocai.messages.v0.ITaskParams>|null} [taskParams] PlayData taskParams
                 * @property {havocai.messages.v0.IDirectParams|null} [direct] PlayData direct
                 * @property {havocai.messages.v0.IContestedLogisticsParams|null} [contestedLogistics] PlayData contestedLogistics
                 * @property {havocai.messages.v0.IPayloadOrchestrationParams|null} [payloadOrchestration] PlayData payloadOrchestration
                 * @property {havocai.messages.v0.IFindFixInvestigateParams|null} [findFixInvestigate] PlayData findFixInvestigate
                 * @property {havocai.messages.v0.ICheckoutParams|null} [checkout] PlayData checkout
                 * @property {havocai.messages.v0.IBeachLaunchParams|null} [beachLaunch] PlayData beachLaunch
                 * @property {havocai.messages.v0.IAvastParams|null} [avast] PlayData avast
                 * @property {havocai.messages.v0.IJazzParams|null} [jazz] PlayData jazz
                 * @property {havocai.messages.v0.IChariotRampControlParams|null} [chariotRampControl] PlayData chariotRampControl
                 * @property {havocai.messages.v0.IChariotResupplyParams|null} [chariotResupply] PlayData chariotResupply
                 * @property {havocai.messages.v0.IEngageTrackParams|null} [engageTrack] PlayData engageTrack
                 */

                /**
                 * Constructs a new PlayData.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PlayData.
                 * @implements IPlayData
                 * @constructor
                 * @param {havocai.messages.v0.IPlayData=} [properties] Properties to set
                 */
                function PlayData(properties) {
                    this.geoFences = [];
                    this.taskParams = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlayData id.
                 * @member {string} id
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.id = "";

                /**
                 * PlayData key.
                 * @member {havocai.messages.v0.PlayKey} key
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.key = 0;

                /**
                 * PlayData dataSource.
                 * @member {havocai.messages.v0.DataSource} dataSource
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.dataSource = 0;

                /**
                 * PlayData geoFences.
                 * @member {Array.<havocai.messages.v0.IGeoFence>} geoFences
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.geoFences = $util.emptyArray;

                /**
                 * PlayData minBoats.
                 * @member {number} minBoats
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.minBoats = 0;

                /**
                 * PlayData minCapacity.
                 * @member {number} minCapacity
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.minCapacity = 0;

                /**
                 * PlayData respectGeoFences.
                 * @member {boolean} respectGeoFences
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.respectGeoFences = false;

                /**
                 * PlayData defaultParams.
                 * @member {havocai.messages.v0.ITaskParams|null|undefined} defaultParams
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.defaultParams = null;

                /**
                 * PlayData taskParams.
                 * @member {Array.<havocai.messages.v0.ITaskParams>} taskParams
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.taskParams = $util.emptyArray;

                /**
                 * PlayData direct.
                 * @member {havocai.messages.v0.IDirectParams|null|undefined} direct
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.direct = null;

                /**
                 * PlayData contestedLogistics.
                 * @member {havocai.messages.v0.IContestedLogisticsParams|null|undefined} contestedLogistics
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.contestedLogistics = null;

                /**
                 * PlayData payloadOrchestration.
                 * @member {havocai.messages.v0.IPayloadOrchestrationParams|null|undefined} payloadOrchestration
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.payloadOrchestration = null;

                /**
                 * PlayData findFixInvestigate.
                 * @member {havocai.messages.v0.IFindFixInvestigateParams|null|undefined} findFixInvestigate
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.findFixInvestigate = null;

                /**
                 * PlayData checkout.
                 * @member {havocai.messages.v0.ICheckoutParams|null|undefined} checkout
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.checkout = null;

                /**
                 * PlayData beachLaunch.
                 * @member {havocai.messages.v0.IBeachLaunchParams|null|undefined} beachLaunch
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.beachLaunch = null;

                /**
                 * PlayData avast.
                 * @member {havocai.messages.v0.IAvastParams|null|undefined} avast
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.avast = null;

                /**
                 * PlayData jazz.
                 * @member {havocai.messages.v0.IJazzParams|null|undefined} jazz
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.jazz = null;

                /**
                 * PlayData chariotRampControl.
                 * @member {havocai.messages.v0.IChariotRampControlParams|null|undefined} chariotRampControl
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.chariotRampControl = null;

                /**
                 * PlayData chariotResupply.
                 * @member {havocai.messages.v0.IChariotResupplyParams|null|undefined} chariotResupply
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.chariotResupply = null;

                /**
                 * PlayData engageTrack.
                 * @member {havocai.messages.v0.IEngageTrackParams|null|undefined} engageTrack
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                PlayData.prototype.engageTrack = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * PlayData playParams.
                 * @member {"direct"|"contestedLogistics"|"payloadOrchestration"|"findFixInvestigate"|"checkout"|"beachLaunch"|"avast"|"jazz"|"chariotRampControl"|"chariotResupply"|"engageTrack"|undefined} playParams
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 */
                Object.defineProperty(PlayData.prototype, "playParams", {
                    get: $util.oneOfGetter($oneOfFields = ["direct", "contestedLogistics", "payloadOrchestration", "findFixInvestigate", "checkout", "beachLaunch", "avast", "jazz", "chariotRampControl", "chariotResupply", "engageTrack"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new PlayData instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PlayData
                 * @static
                 * @param {havocai.messages.v0.IPlayData=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PlayData} PlayData instance
                 */
                PlayData.create = function create(properties) {
                    return new PlayData(properties);
                };

                /**
                 * Encodes the specified PlayData message. Does not implicitly {@link havocai.messages.v0.PlayData.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PlayData
                 * @static
                 * @param {havocai.messages.v0.IPlayData} message PlayData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.key);
                    if (message.geoFences != null && message.geoFences.length)
                        for (let i = 0; i < message.geoFences.length; ++i)
                            $root.havocai.messages.v0.GeoFence.encode(message.geoFences[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.minBoats != null && Object.hasOwnProperty.call(message, "minBoats"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.minBoats);
                    if (message.minCapacity != null && Object.hasOwnProperty.call(message, "minCapacity"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.minCapacity);
                    if (message.respectGeoFences != null && Object.hasOwnProperty.call(message, "respectGeoFences"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.respectGeoFences);
                    if (message.defaultParams != null && Object.hasOwnProperty.call(message, "defaultParams"))
                        $root.havocai.messages.v0.TaskParams.encode(message.defaultParams, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.taskParams != null && message.taskParams.length)
                        for (let i = 0; i < message.taskParams.length; ++i)
                            $root.havocai.messages.v0.TaskParams.encode(message.taskParams[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.direct != null && Object.hasOwnProperty.call(message, "direct"))
                        $root.havocai.messages.v0.DirectParams.encode(message.direct, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.contestedLogistics != null && Object.hasOwnProperty.call(message, "contestedLogistics"))
                        $root.havocai.messages.v0.ContestedLogisticsParams.encode(message.contestedLogistics, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.payloadOrchestration != null && Object.hasOwnProperty.call(message, "payloadOrchestration"))
                        $root.havocai.messages.v0.PayloadOrchestrationParams.encode(message.payloadOrchestration, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.findFixInvestigate != null && Object.hasOwnProperty.call(message, "findFixInvestigate"))
                        $root.havocai.messages.v0.FindFixInvestigateParams.encode(message.findFixInvestigate, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.checkout != null && Object.hasOwnProperty.call(message, "checkout"))
                        $root.havocai.messages.v0.CheckoutParams.encode(message.checkout, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.beachLaunch != null && Object.hasOwnProperty.call(message, "beachLaunch"))
                        $root.havocai.messages.v0.BeachLaunchParams.encode(message.beachLaunch, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if (message.avast != null && Object.hasOwnProperty.call(message, "avast"))
                        $root.havocai.messages.v0.AvastParams.encode(message.avast, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.jazz != null && Object.hasOwnProperty.call(message, "jazz"))
                        $root.havocai.messages.v0.JazzParams.encode(message.jazz, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.chariotRampControl != null && Object.hasOwnProperty.call(message, "chariotRampControl"))
                        $root.havocai.messages.v0.ChariotRampControlParams.encode(message.chariotRampControl, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.chariotResupply != null && Object.hasOwnProperty.call(message, "chariotResupply"))
                        $root.havocai.messages.v0.ChariotResupplyParams.encode(message.chariotResupply, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if (message.engageTrack != null && Object.hasOwnProperty.call(message, "engageTrack"))
                        $root.havocai.messages.v0.EngageTrackParams.encode(message.engageTrack, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 19, wireType 2 =*/154).string(message.id);
                    if (message.dataSource != null && Object.hasOwnProperty.call(message, "dataSource"))
                        writer.uint32(/* id 20, wireType 0 =*/160).int32(message.dataSource);
                    return writer;
                };

                /**
                 * Encodes the specified PlayData message, length delimited. Does not implicitly {@link havocai.messages.v0.PlayData.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PlayData
                 * @static
                 * @param {havocai.messages.v0.IPlayData} message PlayData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlayData message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PlayData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PlayData} PlayData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayData.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PlayData();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 19: {
                                message.id = reader.string();
                                break;
                            }
                        case 1: {
                                message.key = reader.int32();
                                break;
                            }
                        case 20: {
                                message.dataSource = reader.int32();
                                break;
                            }
                        case 2: {
                                if (!(message.geoFences && message.geoFences.length))
                                    message.geoFences = [];
                                message.geoFences.push($root.havocai.messages.v0.GeoFence.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                message.minBoats = reader.uint32();
                                break;
                            }
                        case 4: {
                                message.minCapacity = reader.uint32();
                                break;
                            }
                        case 5: {
                                message.respectGeoFences = reader.bool();
                                break;
                            }
                        case 6: {
                                message.defaultParams = $root.havocai.messages.v0.TaskParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 7: {
                                if (!(message.taskParams && message.taskParams.length))
                                    message.taskParams = [];
                                message.taskParams.push($root.havocai.messages.v0.TaskParams.decode(reader, reader.uint32()));
                                break;
                            }
                        case 8: {
                                message.direct = $root.havocai.messages.v0.DirectParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 9: {
                                message.contestedLogistics = $root.havocai.messages.v0.ContestedLogisticsParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 10: {
                                message.payloadOrchestration = $root.havocai.messages.v0.PayloadOrchestrationParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 11: {
                                message.findFixInvestigate = $root.havocai.messages.v0.FindFixInvestigateParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 12: {
                                message.checkout = $root.havocai.messages.v0.CheckoutParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 13: {
                                message.beachLaunch = $root.havocai.messages.v0.BeachLaunchParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 14: {
                                message.avast = $root.havocai.messages.v0.AvastParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 15: {
                                message.jazz = $root.havocai.messages.v0.JazzParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 16: {
                                message.chariotRampControl = $root.havocai.messages.v0.ChariotRampControlParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 17: {
                                message.chariotResupply = $root.havocai.messages.v0.ChariotResupplyParams.decode(reader, reader.uint32());
                                break;
                            }
                        case 18: {
                                message.engageTrack = $root.havocai.messages.v0.EngageTrackParams.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlayData message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PlayData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PlayData} PlayData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlayData message.
                 * @function verify
                 * @memberof havocai.messages.v0.PlayData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        switch (message.key) {
                        default:
                            return "key: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                            break;
                        }
                    if (message.dataSource != null && message.hasOwnProperty("dataSource"))
                        switch (message.dataSource) {
                        default:
                            return "dataSource: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.geoFences != null && message.hasOwnProperty("geoFences")) {
                        if (!Array.isArray(message.geoFences))
                            return "geoFences: array expected";
                        for (let i = 0; i < message.geoFences.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoFence.verify(message.geoFences[i]);
                            if (error)
                                return "geoFences." + error;
                        }
                    }
                    if (message.minBoats != null && message.hasOwnProperty("minBoats"))
                        if (!$util.isInteger(message.minBoats))
                            return "minBoats: integer expected";
                    if (message.minCapacity != null && message.hasOwnProperty("minCapacity"))
                        if (!$util.isInteger(message.minCapacity))
                            return "minCapacity: integer expected";
                    if (message.respectGeoFences != null && message.hasOwnProperty("respectGeoFences"))
                        if (typeof message.respectGeoFences !== "boolean")
                            return "respectGeoFences: boolean expected";
                    if (message.defaultParams != null && message.hasOwnProperty("defaultParams")) {
                        let error = $root.havocai.messages.v0.TaskParams.verify(message.defaultParams);
                        if (error)
                            return "defaultParams." + error;
                    }
                    if (message.taskParams != null && message.hasOwnProperty("taskParams")) {
                        if (!Array.isArray(message.taskParams))
                            return "taskParams: array expected";
                        for (let i = 0; i < message.taskParams.length; ++i) {
                            let error = $root.havocai.messages.v0.TaskParams.verify(message.taskParams[i]);
                            if (error)
                                return "taskParams." + error;
                        }
                    }
                    if (message.direct != null && message.hasOwnProperty("direct")) {
                        properties.playParams = 1;
                        {
                            let error = $root.havocai.messages.v0.DirectParams.verify(message.direct);
                            if (error)
                                return "direct." + error;
                        }
                    }
                    if (message.contestedLogistics != null && message.hasOwnProperty("contestedLogistics")) {
                        if (properties.playParams === 1)
                            return "playParams: multiple values";
                        properties.playParams = 1;
                        {
                            let error = $root.havocai.messages.v0.ContestedLogisticsParams.verify(message.contestedLogistics);
                            if (error)
                                return "contestedLogistics." + error;
                        }
                    }
                    if (message.payloadOrchestration != null && message.hasOwnProperty("payloadOrchestration")) {
                        if (properties.playParams === 1)
                            return "playParams: multiple values";
                        properties.playParams = 1;
                        {
                            let error = $root.havocai.messages.v0.PayloadOrchestrationParams.verify(message.payloadOrchestration);
                            if (error)
                                return "payloadOrchestration." + error;
                        }
                    }
                    if (message.findFixInvestigate != null && message.hasOwnProperty("findFixInvestigate")) {
                        if (properties.playParams === 1)
                            return "playParams: multiple values";
                        properties.playParams = 1;
                        {
                            let error = $root.havocai.messages.v0.FindFixInvestigateParams.verify(message.findFixInvestigate);
                            if (error)
                                return "findFixInvestigate." + error;
                        }
                    }
                    if (message.checkout != null && message.hasOwnProperty("checkout")) {
                        if (properties.playParams === 1)
                            return "playParams: multiple values";
                        properties.playParams = 1;
                        {
                            let error = $root.havocai.messages.v0.CheckoutParams.verify(message.checkout);
                            if (error)
                                return "checkout." + error;
                        }
                    }
                    if (message.beachLaunch != null && message.hasOwnProperty("beachLaunch")) {
                        if (properties.playParams === 1)
                            return "playParams: multiple values";
                        properties.playParams = 1;
                        {
                            let error = $root.havocai.messages.v0.BeachLaunchParams.verify(message.beachLaunch);
                            if (error)
                                return "beachLaunch." + error;
                        }
                    }
                    if (message.avast != null && message.hasOwnProperty("avast")) {
                        if (properties.playParams === 1)
                            return "playParams: multiple values";
                        properties.playParams = 1;
                        {
                            let error = $root.havocai.messages.v0.AvastParams.verify(message.avast);
                            if (error)
                                return "avast." + error;
                        }
                    }
                    if (message.jazz != null && message.hasOwnProperty("jazz")) {
                        if (properties.playParams === 1)
                            return "playParams: multiple values";
                        properties.playParams = 1;
                        {
                            let error = $root.havocai.messages.v0.JazzParams.verify(message.jazz);
                            if (error)
                                return "jazz." + error;
                        }
                    }
                    if (message.chariotRampControl != null && message.hasOwnProperty("chariotRampControl")) {
                        if (properties.playParams === 1)
                            return "playParams: multiple values";
                        properties.playParams = 1;
                        {
                            let error = $root.havocai.messages.v0.ChariotRampControlParams.verify(message.chariotRampControl);
                            if (error)
                                return "chariotRampControl." + error;
                        }
                    }
                    if (message.chariotResupply != null && message.hasOwnProperty("chariotResupply")) {
                        if (properties.playParams === 1)
                            return "playParams: multiple values";
                        properties.playParams = 1;
                        {
                            let error = $root.havocai.messages.v0.ChariotResupplyParams.verify(message.chariotResupply);
                            if (error)
                                return "chariotResupply." + error;
                        }
                    }
                    if (message.engageTrack != null && message.hasOwnProperty("engageTrack")) {
                        if (properties.playParams === 1)
                            return "playParams: multiple values";
                        properties.playParams = 1;
                        {
                            let error = $root.havocai.messages.v0.EngageTrackParams.verify(message.engageTrack);
                            if (error)
                                return "engageTrack." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a PlayData message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PlayData
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PlayData} PlayData
                 */
                PlayData.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PlayData)
                        return object;
                    let message = new $root.havocai.messages.v0.PlayData();
                    if (object.id != null)
                        message.id = String(object.id);
                    switch (object.key) {
                    default:
                        if (typeof object.key === "number") {
                            message.key = object.key;
                            break;
                        }
                        break;
                    case "PLAY_KEY_UNKNOWN":
                    case 0:
                        message.key = 0;
                        break;
                    case "PLAY_KEY_NONE":
                    case 1:
                        message.key = 1;
                        break;
                    case "PLAY_KEY_DIRECT":
                    case 2:
                        message.key = 2;
                        break;
                    case "PLAY_KEY_CONTESTED_LOGISTICS":
                    case 3:
                        message.key = 3;
                        break;
                    case "PLAY_KEY_PAYLOAD_ORCHESTRATION":
                    case 4:
                        message.key = 4;
                        break;
                    case "PLAY_KEY_FIND_FIX_INVESTIGATE":
                    case 5:
                        message.key = 5;
                        break;
                    case "PLAY_KEY_FIND_FIX_INVESTIGATE_EPISCI":
                    case 6:
                        message.key = 6;
                        break;
                    case "PLAY_KEY_CHECKOUT":
                    case 7:
                        message.key = 7;
                        break;
                    case "PLAY_KEY_BEACH_LAUNCH":
                    case 8:
                        message.key = 8;
                        break;
                    case "PLAY_KEY_AVAST":
                    case 9:
                        message.key = 9;
                        break;
                    case "PLAY_KEY_JAZZ":
                    case 10:
                        message.key = 10;
                        break;
                    case "PLAY_KEY_CHARIOT_RAMP_CONTROL":
                    case 11:
                        message.key = 11;
                        break;
                    case "PLAY_KEY_CHARIOT_RESUPPLY":
                    case 12:
                        message.key = 12;
                        break;
                    case "PLAY_KEY_ENGAGE_TRACK":
                    case 13:
                        message.key = 13;
                        break;
                    case "PLAY_KEY_DYNAMIC":
                    case 14:
                        message.key = 14;
                        break;
                    }
                    switch (object.dataSource) {
                    default:
                        if (typeof object.dataSource === "number") {
                            message.dataSource = object.dataSource;
                            break;
                        }
                        break;
                    case "DATA_SOURCE_UNKNOWN":
                    case 0:
                        message.dataSource = 0;
                        break;
                    case "DATA_SOURCE_API":
                    case 1:
                        message.dataSource = 1;
                        break;
                    case "DATA_SOURCE_TAK":
                    case 2:
                        message.dataSource = 2;
                        break;
                    case "DATA_SOURCE_LATTICE":
                    case 3:
                        message.dataSource = 3;
                        break;
                    }
                    if (object.geoFences) {
                        if (!Array.isArray(object.geoFences))
                            throw TypeError(".havocai.messages.v0.PlayData.geoFences: array expected");
                        message.geoFences = [];
                        for (let i = 0; i < object.geoFences.length; ++i) {
                            if (typeof object.geoFences[i] !== "object")
                                throw TypeError(".havocai.messages.v0.PlayData.geoFences: object expected");
                            message.geoFences[i] = $root.havocai.messages.v0.GeoFence.fromObject(object.geoFences[i]);
                        }
                    }
                    if (object.minBoats != null)
                        message.minBoats = object.minBoats >>> 0;
                    if (object.minCapacity != null)
                        message.minCapacity = object.minCapacity >>> 0;
                    if (object.respectGeoFences != null)
                        message.respectGeoFences = Boolean(object.respectGeoFences);
                    if (object.defaultParams != null) {
                        if (typeof object.defaultParams !== "object")
                            throw TypeError(".havocai.messages.v0.PlayData.defaultParams: object expected");
                        message.defaultParams = $root.havocai.messages.v0.TaskParams.fromObject(object.defaultParams);
                    }
                    if (object.taskParams) {
                        if (!Array.isArray(object.taskParams))
                            throw TypeError(".havocai.messages.v0.PlayData.taskParams: array expected");
                        message.taskParams = [];
                        for (let i = 0; i < object.taskParams.length; ++i) {
                            if (typeof object.taskParams[i] !== "object")
                                throw TypeError(".havocai.messages.v0.PlayData.taskParams: object expected");
                            message.taskParams[i] = $root.havocai.messages.v0.TaskParams.fromObject(object.taskParams[i]);
                        }
                    }
                    if (object.direct != null) {
                        if (typeof object.direct !== "object")
                            throw TypeError(".havocai.messages.v0.PlayData.direct: object expected");
                        message.direct = $root.havocai.messages.v0.DirectParams.fromObject(object.direct);
                    }
                    if (object.contestedLogistics != null) {
                        if (typeof object.contestedLogistics !== "object")
                            throw TypeError(".havocai.messages.v0.PlayData.contestedLogistics: object expected");
                        message.contestedLogistics = $root.havocai.messages.v0.ContestedLogisticsParams.fromObject(object.contestedLogistics);
                    }
                    if (object.payloadOrchestration != null) {
                        if (typeof object.payloadOrchestration !== "object")
                            throw TypeError(".havocai.messages.v0.PlayData.payloadOrchestration: object expected");
                        message.payloadOrchestration = $root.havocai.messages.v0.PayloadOrchestrationParams.fromObject(object.payloadOrchestration);
                    }
                    if (object.findFixInvestigate != null) {
                        if (typeof object.findFixInvestigate !== "object")
                            throw TypeError(".havocai.messages.v0.PlayData.findFixInvestigate: object expected");
                        message.findFixInvestigate = $root.havocai.messages.v0.FindFixInvestigateParams.fromObject(object.findFixInvestigate);
                    }
                    if (object.checkout != null) {
                        if (typeof object.checkout !== "object")
                            throw TypeError(".havocai.messages.v0.PlayData.checkout: object expected");
                        message.checkout = $root.havocai.messages.v0.CheckoutParams.fromObject(object.checkout);
                    }
                    if (object.beachLaunch != null) {
                        if (typeof object.beachLaunch !== "object")
                            throw TypeError(".havocai.messages.v0.PlayData.beachLaunch: object expected");
                        message.beachLaunch = $root.havocai.messages.v0.BeachLaunchParams.fromObject(object.beachLaunch);
                    }
                    if (object.avast != null) {
                        if (typeof object.avast !== "object")
                            throw TypeError(".havocai.messages.v0.PlayData.avast: object expected");
                        message.avast = $root.havocai.messages.v0.AvastParams.fromObject(object.avast);
                    }
                    if (object.jazz != null) {
                        if (typeof object.jazz !== "object")
                            throw TypeError(".havocai.messages.v0.PlayData.jazz: object expected");
                        message.jazz = $root.havocai.messages.v0.JazzParams.fromObject(object.jazz);
                    }
                    if (object.chariotRampControl != null) {
                        if (typeof object.chariotRampControl !== "object")
                            throw TypeError(".havocai.messages.v0.PlayData.chariotRampControl: object expected");
                        message.chariotRampControl = $root.havocai.messages.v0.ChariotRampControlParams.fromObject(object.chariotRampControl);
                    }
                    if (object.chariotResupply != null) {
                        if (typeof object.chariotResupply !== "object")
                            throw TypeError(".havocai.messages.v0.PlayData.chariotResupply: object expected");
                        message.chariotResupply = $root.havocai.messages.v0.ChariotResupplyParams.fromObject(object.chariotResupply);
                    }
                    if (object.engageTrack != null) {
                        if (typeof object.engageTrack !== "object")
                            throw TypeError(".havocai.messages.v0.PlayData.engageTrack: object expected");
                        message.engageTrack = $root.havocai.messages.v0.EngageTrackParams.fromObject(object.engageTrack);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlayData message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PlayData
                 * @static
                 * @param {havocai.messages.v0.PlayData} message PlayData
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.geoFences = [];
                        object.taskParams = [];
                    }
                    if (options.defaults) {
                        object.key = options.enums === String ? "PLAY_KEY_UNKNOWN" : 0;
                        object.minBoats = 0;
                        object.minCapacity = 0;
                        object.respectGeoFences = false;
                        object.defaultParams = null;
                        object.id = "";
                        object.dataSource = options.enums === String ? "DATA_SOURCE_UNKNOWN" : 0;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.enums === String ? $root.havocai.messages.v0.PlayKey[message.key] === undefined ? message.key : $root.havocai.messages.v0.PlayKey[message.key] : message.key;
                    if (message.geoFences && message.geoFences.length) {
                        object.geoFences = [];
                        for (let j = 0; j < message.geoFences.length; ++j)
                            object.geoFences[j] = $root.havocai.messages.v0.GeoFence.toObject(message.geoFences[j], options);
                    }
                    if (message.minBoats != null && message.hasOwnProperty("minBoats"))
                        object.minBoats = message.minBoats;
                    if (message.minCapacity != null && message.hasOwnProperty("minCapacity"))
                        object.minCapacity = message.minCapacity;
                    if (message.respectGeoFences != null && message.hasOwnProperty("respectGeoFences"))
                        object.respectGeoFences = message.respectGeoFences;
                    if (message.defaultParams != null && message.hasOwnProperty("defaultParams"))
                        object.defaultParams = $root.havocai.messages.v0.TaskParams.toObject(message.defaultParams, options);
                    if (message.taskParams && message.taskParams.length) {
                        object.taskParams = [];
                        for (let j = 0; j < message.taskParams.length; ++j)
                            object.taskParams[j] = $root.havocai.messages.v0.TaskParams.toObject(message.taskParams[j], options);
                    }
                    if (message.direct != null && message.hasOwnProperty("direct")) {
                        object.direct = $root.havocai.messages.v0.DirectParams.toObject(message.direct, options);
                        if (options.oneofs)
                            object.playParams = "direct";
                    }
                    if (message.contestedLogistics != null && message.hasOwnProperty("contestedLogistics")) {
                        object.contestedLogistics = $root.havocai.messages.v0.ContestedLogisticsParams.toObject(message.contestedLogistics, options);
                        if (options.oneofs)
                            object.playParams = "contestedLogistics";
                    }
                    if (message.payloadOrchestration != null && message.hasOwnProperty("payloadOrchestration")) {
                        object.payloadOrchestration = $root.havocai.messages.v0.PayloadOrchestrationParams.toObject(message.payloadOrchestration, options);
                        if (options.oneofs)
                            object.playParams = "payloadOrchestration";
                    }
                    if (message.findFixInvestigate != null && message.hasOwnProperty("findFixInvestigate")) {
                        object.findFixInvestigate = $root.havocai.messages.v0.FindFixInvestigateParams.toObject(message.findFixInvestigate, options);
                        if (options.oneofs)
                            object.playParams = "findFixInvestigate";
                    }
                    if (message.checkout != null && message.hasOwnProperty("checkout")) {
                        object.checkout = $root.havocai.messages.v0.CheckoutParams.toObject(message.checkout, options);
                        if (options.oneofs)
                            object.playParams = "checkout";
                    }
                    if (message.beachLaunch != null && message.hasOwnProperty("beachLaunch")) {
                        object.beachLaunch = $root.havocai.messages.v0.BeachLaunchParams.toObject(message.beachLaunch, options);
                        if (options.oneofs)
                            object.playParams = "beachLaunch";
                    }
                    if (message.avast != null && message.hasOwnProperty("avast")) {
                        object.avast = $root.havocai.messages.v0.AvastParams.toObject(message.avast, options);
                        if (options.oneofs)
                            object.playParams = "avast";
                    }
                    if (message.jazz != null && message.hasOwnProperty("jazz")) {
                        object.jazz = $root.havocai.messages.v0.JazzParams.toObject(message.jazz, options);
                        if (options.oneofs)
                            object.playParams = "jazz";
                    }
                    if (message.chariotRampControl != null && message.hasOwnProperty("chariotRampControl")) {
                        object.chariotRampControl = $root.havocai.messages.v0.ChariotRampControlParams.toObject(message.chariotRampControl, options);
                        if (options.oneofs)
                            object.playParams = "chariotRampControl";
                    }
                    if (message.chariotResupply != null && message.hasOwnProperty("chariotResupply")) {
                        object.chariotResupply = $root.havocai.messages.v0.ChariotResupplyParams.toObject(message.chariotResupply, options);
                        if (options.oneofs)
                            object.playParams = "chariotResupply";
                    }
                    if (message.engageTrack != null && message.hasOwnProperty("engageTrack")) {
                        object.engageTrack = $root.havocai.messages.v0.EngageTrackParams.toObject(message.engageTrack, options);
                        if (options.oneofs)
                            object.playParams = "engageTrack";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.dataSource != null && message.hasOwnProperty("dataSource"))
                        object.dataSource = options.enums === String ? $root.havocai.messages.v0.DataSource[message.dataSource] === undefined ? message.dataSource : $root.havocai.messages.v0.DataSource[message.dataSource] : message.dataSource;
                    return object;
                };

                /**
                 * Converts this PlayData to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PlayData
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlayData
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PlayData
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlayData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PlayData";
                };

                return PlayData;
            })();

            v0.PlayStatus = (function() {

                /**
                 * Properties of a PlayStatus.
                 * @memberof havocai.messages.v0
                 * @interface IPlayStatus
                 * @property {havocai.messages.v0.PlayState|null} [state] PlayStatus state
                 * @property {number|Long|null} [requestTime] PlayStatus requestTime
                 * @property {havocai.messages.v0.IPlayData|null} [data] PlayStatus data
                 * @property {Array.<havocai.messages.v0.ITask>|null} [tasks] PlayStatus tasks
                 */

                /**
                 * Constructs a new PlayStatus.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PlayStatus.
                 * @implements IPlayStatus
                 * @constructor
                 * @param {havocai.messages.v0.IPlayStatus=} [properties] Properties to set
                 */
                function PlayStatus(properties) {
                    this.tasks = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlayStatus state.
                 * @member {havocai.messages.v0.PlayState} state
                 * @memberof havocai.messages.v0.PlayStatus
                 * @instance
                 */
                PlayStatus.prototype.state = 0;

                /**
                 * PlayStatus requestTime.
                 * @member {number|Long} requestTime
                 * @memberof havocai.messages.v0.PlayStatus
                 * @instance
                 */
                PlayStatus.prototype.requestTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * PlayStatus data.
                 * @member {havocai.messages.v0.IPlayData|null|undefined} data
                 * @memberof havocai.messages.v0.PlayStatus
                 * @instance
                 */
                PlayStatus.prototype.data = null;

                /**
                 * PlayStatus tasks.
                 * @member {Array.<havocai.messages.v0.ITask>} tasks
                 * @memberof havocai.messages.v0.PlayStatus
                 * @instance
                 */
                PlayStatus.prototype.tasks = $util.emptyArray;

                /**
                 * Creates a new PlayStatus instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PlayStatus
                 * @static
                 * @param {havocai.messages.v0.IPlayStatus=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PlayStatus} PlayStatus instance
                 */
                PlayStatus.create = function create(properties) {
                    return new PlayStatus(properties);
                };

                /**
                 * Encodes the specified PlayStatus message. Does not implicitly {@link havocai.messages.v0.PlayStatus.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PlayStatus
                 * @static
                 * @param {havocai.messages.v0.IPlayStatus} message PlayStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                    if (message.requestTime != null && Object.hasOwnProperty.call(message, "requestTime"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.requestTime);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        $root.havocai.messages.v0.PlayData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.tasks != null && message.tasks.length)
                        for (let i = 0; i < message.tasks.length; ++i)
                            $root.havocai.messages.v0.Task.encode(message.tasks[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PlayStatus message, length delimited. Does not implicitly {@link havocai.messages.v0.PlayStatus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PlayStatus
                 * @static
                 * @param {havocai.messages.v0.IPlayStatus} message PlayStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlayStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PlayStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PlayStatus} PlayStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayStatus.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PlayStatus();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.state = reader.int32();
                                break;
                            }
                        case 2: {
                                message.requestTime = reader.int64();
                                break;
                            }
                        case 3: {
                                message.data = $root.havocai.messages.v0.PlayData.decode(reader, reader.uint32());
                                break;
                            }
                        case 15: {
                                if (!(message.tasks && message.tasks.length))
                                    message.tasks = [];
                                message.tasks.push($root.havocai.messages.v0.Task.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlayStatus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PlayStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PlayStatus} PlayStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlayStatus message.
                 * @function verify
                 * @memberof havocai.messages.v0.PlayStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.requestTime != null && message.hasOwnProperty("requestTime"))
                        if (!$util.isInteger(message.requestTime) && !(message.requestTime && $util.isInteger(message.requestTime.low) && $util.isInteger(message.requestTime.high)))
                            return "requestTime: integer|Long expected";
                    if (message.data != null && message.hasOwnProperty("data")) {
                        let error = $root.havocai.messages.v0.PlayData.verify(message.data);
                        if (error)
                            return "data." + error;
                    }
                    if (message.tasks != null && message.hasOwnProperty("tasks")) {
                        if (!Array.isArray(message.tasks))
                            return "tasks: array expected";
                        for (let i = 0; i < message.tasks.length; ++i) {
                            let error = $root.havocai.messages.v0.Task.verify(message.tasks[i]);
                            if (error)
                                return "tasks." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a PlayStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PlayStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PlayStatus} PlayStatus
                 */
                PlayStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PlayStatus)
                        return object;
                    let message = new $root.havocai.messages.v0.PlayStatus();
                    switch (object.state) {
                    default:
                        if (typeof object.state === "number") {
                            message.state = object.state;
                            break;
                        }
                        break;
                    case "PLAY_STATE_UNKNOWN":
                    case 0:
                        message.state = 0;
                        break;
                    case "PLAY_STATE_IDLE":
                    case 1:
                        message.state = 1;
                        break;
                    case "PLAY_STATE_PENDING":
                    case 2:
                        message.state = 2;
                        break;
                    case "PLAY_STATE_ACTIVE":
                    case 3:
                        message.state = 3;
                        break;
                    case "PLAY_STATE_COMPLETE":
                    case 4:
                        message.state = 4;
                        break;
                    case "PLAY_STATE_CANCELED":
                    case 5:
                        message.state = 5;
                        break;
                    case "PLAY_STATE_FAILED":
                    case 6:
                        message.state = 6;
                        break;
                    }
                    if (object.requestTime != null)
                        if ($util.Long)
                            (message.requestTime = $util.Long.fromValue(object.requestTime)).unsigned = false;
                        else if (typeof object.requestTime === "string")
                            message.requestTime = parseInt(object.requestTime, 10);
                        else if (typeof object.requestTime === "number")
                            message.requestTime = object.requestTime;
                        else if (typeof object.requestTime === "object")
                            message.requestTime = new $util.LongBits(object.requestTime.low >>> 0, object.requestTime.high >>> 0).toNumber();
                    if (object.data != null) {
                        if (typeof object.data !== "object")
                            throw TypeError(".havocai.messages.v0.PlayStatus.data: object expected");
                        message.data = $root.havocai.messages.v0.PlayData.fromObject(object.data);
                    }
                    if (object.tasks) {
                        if (!Array.isArray(object.tasks))
                            throw TypeError(".havocai.messages.v0.PlayStatus.tasks: array expected");
                        message.tasks = [];
                        for (let i = 0; i < object.tasks.length; ++i) {
                            if (typeof object.tasks[i] !== "object")
                                throw TypeError(".havocai.messages.v0.PlayStatus.tasks: object expected");
                            message.tasks[i] = $root.havocai.messages.v0.Task.fromObject(object.tasks[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlayStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PlayStatus
                 * @static
                 * @param {havocai.messages.v0.PlayStatus} message PlayStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.tasks = [];
                    if (options.defaults) {
                        object.state = options.enums === String ? "PLAY_STATE_UNKNOWN" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.requestTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.requestTime = options.longs === String ? "0" : 0;
                        object.data = null;
                    }
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = options.enums === String ? $root.havocai.messages.v0.PlayState[message.state] === undefined ? message.state : $root.havocai.messages.v0.PlayState[message.state] : message.state;
                    if (message.requestTime != null && message.hasOwnProperty("requestTime"))
                        if (typeof message.requestTime === "number")
                            object.requestTime = options.longs === String ? String(message.requestTime) : message.requestTime;
                        else
                            object.requestTime = options.longs === String ? $util.Long.prototype.toString.call(message.requestTime) : options.longs === Number ? new $util.LongBits(message.requestTime.low >>> 0, message.requestTime.high >>> 0).toNumber() : message.requestTime;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = $root.havocai.messages.v0.PlayData.toObject(message.data, options);
                    if (message.tasks && message.tasks.length) {
                        object.tasks = [];
                        for (let j = 0; j < message.tasks.length; ++j)
                            object.tasks[j] = $root.havocai.messages.v0.Task.toObject(message.tasks[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this PlayStatus to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PlayStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlayStatus
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PlayStatus
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlayStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PlayStatus";
                };

                return PlayStatus;
            })();

            v0.DirectParams = (function() {

                /**
                 * Properties of a DirectParams.
                 * @memberof havocai.messages.v0
                 * @interface IDirectParams
                 * @property {havocai.messages.v0.IGeoPoint|null} [goalLocation] DirectParams goalLocation
                 */

                /**
                 * Constructs a new DirectParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a DirectParams.
                 * @implements IDirectParams
                 * @constructor
                 * @param {havocai.messages.v0.IDirectParams=} [properties] Properties to set
                 */
                function DirectParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DirectParams goalLocation.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} goalLocation
                 * @memberof havocai.messages.v0.DirectParams
                 * @instance
                 */
                DirectParams.prototype.goalLocation = null;

                /**
                 * Creates a new DirectParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.DirectParams
                 * @static
                 * @param {havocai.messages.v0.IDirectParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.DirectParams} DirectParams instance
                 */
                DirectParams.create = function create(properties) {
                    return new DirectParams(properties);
                };

                /**
                 * Encodes the specified DirectParams message. Does not implicitly {@link havocai.messages.v0.DirectParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.DirectParams
                 * @static
                 * @param {havocai.messages.v0.IDirectParams} message DirectParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DirectParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.goalLocation != null && Object.hasOwnProperty.call(message, "goalLocation"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.goalLocation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified DirectParams message, length delimited. Does not implicitly {@link havocai.messages.v0.DirectParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.DirectParams
                 * @static
                 * @param {havocai.messages.v0.IDirectParams} message DirectParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DirectParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DirectParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.DirectParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.DirectParams} DirectParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DirectParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.DirectParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.goalLocation = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DirectParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.DirectParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.DirectParams} DirectParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DirectParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DirectParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.DirectParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DirectParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.goalLocation != null && message.hasOwnProperty("goalLocation")) {
                        let error = $root.havocai.messages.v0.GeoPoint.verify(message.goalLocation);
                        if (error)
                            return "goalLocation." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DirectParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.DirectParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.DirectParams} DirectParams
                 */
                DirectParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.DirectParams)
                        return object;
                    let message = new $root.havocai.messages.v0.DirectParams();
                    if (object.goalLocation != null) {
                        if (typeof object.goalLocation !== "object")
                            throw TypeError(".havocai.messages.v0.DirectParams.goalLocation: object expected");
                        message.goalLocation = $root.havocai.messages.v0.GeoPoint.fromObject(object.goalLocation);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DirectParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.DirectParams
                 * @static
                 * @param {havocai.messages.v0.DirectParams} message DirectParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DirectParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.goalLocation = null;
                    if (message.goalLocation != null && message.hasOwnProperty("goalLocation"))
                        object.goalLocation = $root.havocai.messages.v0.GeoPoint.toObject(message.goalLocation, options);
                    return object;
                };

                /**
                 * Converts this DirectParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.DirectParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DirectParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for DirectParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.DirectParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                DirectParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.DirectParams";
                };

                return DirectParams;
            })();

            v0.ContestedLogisticsParams = (function() {

                /**
                 * Properties of a ContestedLogisticsParams.
                 * @memberof havocai.messages.v0
                 * @interface IContestedLogisticsParams
                 * @property {havocai.messages.v0.IResourceRef|null} [pickupZone] ContestedLogisticsParams pickupZone
                 * @property {havocai.messages.v0.IResourceRef|null} [dropoffZone] ContestedLogisticsParams dropoffZone
                 */

                /**
                 * Constructs a new ContestedLogisticsParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a ContestedLogisticsParams.
                 * @implements IContestedLogisticsParams
                 * @constructor
                 * @param {havocai.messages.v0.IContestedLogisticsParams=} [properties] Properties to set
                 */
                function ContestedLogisticsParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ContestedLogisticsParams pickupZone.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} pickupZone
                 * @memberof havocai.messages.v0.ContestedLogisticsParams
                 * @instance
                 */
                ContestedLogisticsParams.prototype.pickupZone = null;

                /**
                 * ContestedLogisticsParams dropoffZone.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} dropoffZone
                 * @memberof havocai.messages.v0.ContestedLogisticsParams
                 * @instance
                 */
                ContestedLogisticsParams.prototype.dropoffZone = null;

                /**
                 * Creates a new ContestedLogisticsParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.ContestedLogisticsParams
                 * @static
                 * @param {havocai.messages.v0.IContestedLogisticsParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.ContestedLogisticsParams} ContestedLogisticsParams instance
                 */
                ContestedLogisticsParams.create = function create(properties) {
                    return new ContestedLogisticsParams(properties);
                };

                /**
                 * Encodes the specified ContestedLogisticsParams message. Does not implicitly {@link havocai.messages.v0.ContestedLogisticsParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.ContestedLogisticsParams
                 * @static
                 * @param {havocai.messages.v0.IContestedLogisticsParams} message ContestedLogisticsParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ContestedLogisticsParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pickupZone != null && Object.hasOwnProperty.call(message, "pickupZone"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.pickupZone, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.dropoffZone != null && Object.hasOwnProperty.call(message, "dropoffZone"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.dropoffZone, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ContestedLogisticsParams message, length delimited. Does not implicitly {@link havocai.messages.v0.ContestedLogisticsParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.ContestedLogisticsParams
                 * @static
                 * @param {havocai.messages.v0.IContestedLogisticsParams} message ContestedLogisticsParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ContestedLogisticsParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ContestedLogisticsParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.ContestedLogisticsParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.ContestedLogisticsParams} ContestedLogisticsParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ContestedLogisticsParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.ContestedLogisticsParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.pickupZone = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.dropoffZone = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ContestedLogisticsParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.ContestedLogisticsParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.ContestedLogisticsParams} ContestedLogisticsParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ContestedLogisticsParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ContestedLogisticsParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.ContestedLogisticsParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ContestedLogisticsParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pickupZone != null && message.hasOwnProperty("pickupZone")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.pickupZone);
                        if (error)
                            return "pickupZone." + error;
                    }
                    if (message.dropoffZone != null && message.hasOwnProperty("dropoffZone")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.dropoffZone);
                        if (error)
                            return "dropoffZone." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ContestedLogisticsParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.ContestedLogisticsParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.ContestedLogisticsParams} ContestedLogisticsParams
                 */
                ContestedLogisticsParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.ContestedLogisticsParams)
                        return object;
                    let message = new $root.havocai.messages.v0.ContestedLogisticsParams();
                    if (object.pickupZone != null) {
                        if (typeof object.pickupZone !== "object")
                            throw TypeError(".havocai.messages.v0.ContestedLogisticsParams.pickupZone: object expected");
                        message.pickupZone = $root.havocai.messages.v0.ResourceRef.fromObject(object.pickupZone);
                    }
                    if (object.dropoffZone != null) {
                        if (typeof object.dropoffZone !== "object")
                            throw TypeError(".havocai.messages.v0.ContestedLogisticsParams.dropoffZone: object expected");
                        message.dropoffZone = $root.havocai.messages.v0.ResourceRef.fromObject(object.dropoffZone);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ContestedLogisticsParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.ContestedLogisticsParams
                 * @static
                 * @param {havocai.messages.v0.ContestedLogisticsParams} message ContestedLogisticsParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ContestedLogisticsParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.pickupZone = null;
                        object.dropoffZone = null;
                    }
                    if (message.pickupZone != null && message.hasOwnProperty("pickupZone"))
                        object.pickupZone = $root.havocai.messages.v0.ResourceRef.toObject(message.pickupZone, options);
                    if (message.dropoffZone != null && message.hasOwnProperty("dropoffZone"))
                        object.dropoffZone = $root.havocai.messages.v0.ResourceRef.toObject(message.dropoffZone, options);
                    return object;
                };

                /**
                 * Converts this ContestedLogisticsParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.ContestedLogisticsParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ContestedLogisticsParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ContestedLogisticsParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.ContestedLogisticsParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ContestedLogisticsParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.ContestedLogisticsParams";
                };

                return ContestedLogisticsParams;
            })();

            v0.PayloadOrchestrationParams = (function() {

                /**
                 * Properties of a PayloadOrchestrationParams.
                 * @memberof havocai.messages.v0
                 * @interface IPayloadOrchestrationParams
                 * @property {havocai.messages.v0.IResourceRef|null} [track] PayloadOrchestrationParams track
                 * @property {havocai.messages.v0.ICooperativeOffset|null} [formation] PayloadOrchestrationParams formation
                 */

                /**
                 * Constructs a new PayloadOrchestrationParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PayloadOrchestrationParams.
                 * @implements IPayloadOrchestrationParams
                 * @constructor
                 * @param {havocai.messages.v0.IPayloadOrchestrationParams=} [properties] Properties to set
                 */
                function PayloadOrchestrationParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PayloadOrchestrationParams track.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} track
                 * @memberof havocai.messages.v0.PayloadOrchestrationParams
                 * @instance
                 */
                PayloadOrchestrationParams.prototype.track = null;

                /**
                 * PayloadOrchestrationParams formation.
                 * @member {havocai.messages.v0.ICooperativeOffset|null|undefined} formation
                 * @memberof havocai.messages.v0.PayloadOrchestrationParams
                 * @instance
                 */
                PayloadOrchestrationParams.prototype.formation = null;

                /**
                 * Creates a new PayloadOrchestrationParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PayloadOrchestrationParams
                 * @static
                 * @param {havocai.messages.v0.IPayloadOrchestrationParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PayloadOrchestrationParams} PayloadOrchestrationParams instance
                 */
                PayloadOrchestrationParams.create = function create(properties) {
                    return new PayloadOrchestrationParams(properties);
                };

                /**
                 * Encodes the specified PayloadOrchestrationParams message. Does not implicitly {@link havocai.messages.v0.PayloadOrchestrationParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PayloadOrchestrationParams
                 * @static
                 * @param {havocai.messages.v0.IPayloadOrchestrationParams} message PayloadOrchestrationParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PayloadOrchestrationParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.track != null && Object.hasOwnProperty.call(message, "track"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.track, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.formation != null && Object.hasOwnProperty.call(message, "formation"))
                        $root.havocai.messages.v0.CooperativeOffset.encode(message.formation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PayloadOrchestrationParams message, length delimited. Does not implicitly {@link havocai.messages.v0.PayloadOrchestrationParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PayloadOrchestrationParams
                 * @static
                 * @param {havocai.messages.v0.IPayloadOrchestrationParams} message PayloadOrchestrationParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PayloadOrchestrationParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PayloadOrchestrationParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PayloadOrchestrationParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PayloadOrchestrationParams} PayloadOrchestrationParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PayloadOrchestrationParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PayloadOrchestrationParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.track = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.formation = $root.havocai.messages.v0.CooperativeOffset.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PayloadOrchestrationParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PayloadOrchestrationParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PayloadOrchestrationParams} PayloadOrchestrationParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PayloadOrchestrationParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PayloadOrchestrationParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.PayloadOrchestrationParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PayloadOrchestrationParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.track != null && message.hasOwnProperty("track")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.track);
                        if (error)
                            return "track." + error;
                    }
                    if (message.formation != null && message.hasOwnProperty("formation")) {
                        let error = $root.havocai.messages.v0.CooperativeOffset.verify(message.formation);
                        if (error)
                            return "formation." + error;
                    }
                    return null;
                };

                /**
                 * Creates a PayloadOrchestrationParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PayloadOrchestrationParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PayloadOrchestrationParams} PayloadOrchestrationParams
                 */
                PayloadOrchestrationParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PayloadOrchestrationParams)
                        return object;
                    let message = new $root.havocai.messages.v0.PayloadOrchestrationParams();
                    if (object.track != null) {
                        if (typeof object.track !== "object")
                            throw TypeError(".havocai.messages.v0.PayloadOrchestrationParams.track: object expected");
                        message.track = $root.havocai.messages.v0.ResourceRef.fromObject(object.track);
                    }
                    if (object.formation != null) {
                        if (typeof object.formation !== "object")
                            throw TypeError(".havocai.messages.v0.PayloadOrchestrationParams.formation: object expected");
                        message.formation = $root.havocai.messages.v0.CooperativeOffset.fromObject(object.formation);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PayloadOrchestrationParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PayloadOrchestrationParams
                 * @static
                 * @param {havocai.messages.v0.PayloadOrchestrationParams} message PayloadOrchestrationParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PayloadOrchestrationParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.track = null;
                        object.formation = null;
                    }
                    if (message.track != null && message.hasOwnProperty("track"))
                        object.track = $root.havocai.messages.v0.ResourceRef.toObject(message.track, options);
                    if (message.formation != null && message.hasOwnProperty("formation"))
                        object.formation = $root.havocai.messages.v0.CooperativeOffset.toObject(message.formation, options);
                    return object;
                };

                /**
                 * Converts this PayloadOrchestrationParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PayloadOrchestrationParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PayloadOrchestrationParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PayloadOrchestrationParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PayloadOrchestrationParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PayloadOrchestrationParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PayloadOrchestrationParams";
                };

                return PayloadOrchestrationParams;
            })();

            v0.FindFixInvestigateParams = (function() {

                /**
                 * Properties of a FindFixInvestigateParams.
                 * @memberof havocai.messages.v0
                 * @interface IFindFixInvestigateParams
                 * @property {Array.<havocai.messages.v0.IGeoPoint>|null} [searchArea] FindFixInvestigateParams searchArea
                 * @property {havocai.messages.v0.IResourceRef|null} [track] FindFixInvestigateParams track
                 * @property {havocai.messages.v0.SearchStrategy|null} [searchStrategy] FindFixInvestigateParams searchStrategy
                 * @property {number|null} [searchSensorRadius] FindFixInvestigateParams searchSensorRadius
                 */

                /**
                 * Constructs a new FindFixInvestigateParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a FindFixInvestigateParams.
                 * @implements IFindFixInvestigateParams
                 * @constructor
                 * @param {havocai.messages.v0.IFindFixInvestigateParams=} [properties] Properties to set
                 */
                function FindFixInvestigateParams(properties) {
                    this.searchArea = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FindFixInvestigateParams searchArea.
                 * @member {Array.<havocai.messages.v0.IGeoPoint>} searchArea
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @instance
                 */
                FindFixInvestigateParams.prototype.searchArea = $util.emptyArray;

                /**
                 * FindFixInvestigateParams track.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} track
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @instance
                 */
                FindFixInvestigateParams.prototype.track = null;

                /**
                 * FindFixInvestigateParams searchStrategy.
                 * @member {havocai.messages.v0.SearchStrategy} searchStrategy
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @instance
                 */
                FindFixInvestigateParams.prototype.searchStrategy = 0;

                /**
                 * FindFixInvestigateParams searchSensorRadius.
                 * @member {number} searchSensorRadius
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @instance
                 */
                FindFixInvestigateParams.prototype.searchSensorRadius = 0;

                /**
                 * Creates a new FindFixInvestigateParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @static
                 * @param {havocai.messages.v0.IFindFixInvestigateParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.FindFixInvestigateParams} FindFixInvestigateParams instance
                 */
                FindFixInvestigateParams.create = function create(properties) {
                    return new FindFixInvestigateParams(properties);
                };

                /**
                 * Encodes the specified FindFixInvestigateParams message. Does not implicitly {@link havocai.messages.v0.FindFixInvestigateParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @static
                 * @param {havocai.messages.v0.IFindFixInvestigateParams} message FindFixInvestigateParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FindFixInvestigateParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.searchArea != null && message.searchArea.length)
                        for (let i = 0; i < message.searchArea.length; ++i)
                            $root.havocai.messages.v0.GeoPoint.encode(message.searchArea[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.track != null && Object.hasOwnProperty.call(message, "track"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.track, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.searchStrategy != null && Object.hasOwnProperty.call(message, "searchStrategy"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.searchStrategy);
                    if (message.searchSensorRadius != null && Object.hasOwnProperty.call(message, "searchSensorRadius"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.searchSensorRadius);
                    return writer;
                };

                /**
                 * Encodes the specified FindFixInvestigateParams message, length delimited. Does not implicitly {@link havocai.messages.v0.FindFixInvestigateParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @static
                 * @param {havocai.messages.v0.IFindFixInvestigateParams} message FindFixInvestigateParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FindFixInvestigateParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FindFixInvestigateParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.FindFixInvestigateParams} FindFixInvestigateParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FindFixInvestigateParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.FindFixInvestigateParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.searchArea && message.searchArea.length))
                                    message.searchArea = [];
                                message.searchArea.push($root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32()));
                                break;
                            }
                        case 2: {
                                message.track = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.searchStrategy = reader.int32();
                                break;
                            }
                        case 4: {
                                message.searchSensorRadius = reader.float();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FindFixInvestigateParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.FindFixInvestigateParams} FindFixInvestigateParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FindFixInvestigateParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FindFixInvestigateParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FindFixInvestigateParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.searchArea != null && message.hasOwnProperty("searchArea")) {
                        if (!Array.isArray(message.searchArea))
                            return "searchArea: array expected";
                        for (let i = 0; i < message.searchArea.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoPoint.verify(message.searchArea[i]);
                            if (error)
                                return "searchArea." + error;
                        }
                    }
                    if (message.track != null && message.hasOwnProperty("track")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.track);
                        if (error)
                            return "track." + error;
                    }
                    if (message.searchStrategy != null && message.hasOwnProperty("searchStrategy"))
                        switch (message.searchStrategy) {
                        default:
                            return "searchStrategy: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.searchSensorRadius != null && message.hasOwnProperty("searchSensorRadius"))
                        if (typeof message.searchSensorRadius !== "number")
                            return "searchSensorRadius: number expected";
                    return null;
                };

                /**
                 * Creates a FindFixInvestigateParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.FindFixInvestigateParams} FindFixInvestigateParams
                 */
                FindFixInvestigateParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.FindFixInvestigateParams)
                        return object;
                    let message = new $root.havocai.messages.v0.FindFixInvestigateParams();
                    if (object.searchArea) {
                        if (!Array.isArray(object.searchArea))
                            throw TypeError(".havocai.messages.v0.FindFixInvestigateParams.searchArea: array expected");
                        message.searchArea = [];
                        for (let i = 0; i < object.searchArea.length; ++i) {
                            if (typeof object.searchArea[i] !== "object")
                                throw TypeError(".havocai.messages.v0.FindFixInvestigateParams.searchArea: object expected");
                            message.searchArea[i] = $root.havocai.messages.v0.GeoPoint.fromObject(object.searchArea[i]);
                        }
                    }
                    if (object.track != null) {
                        if (typeof object.track !== "object")
                            throw TypeError(".havocai.messages.v0.FindFixInvestigateParams.track: object expected");
                        message.track = $root.havocai.messages.v0.ResourceRef.fromObject(object.track);
                    }
                    switch (object.searchStrategy) {
                    default:
                        if (typeof object.searchStrategy === "number") {
                            message.searchStrategy = object.searchStrategy;
                            break;
                        }
                        break;
                    case "SEARCH_STRATEGY_UNKNOWN":
                    case 0:
                        message.searchStrategy = 0;
                        break;
                    case "SEARCH_STRATEGY_RANDOM":
                    case 1:
                        message.searchStrategy = 1;
                        break;
                    case "SEARCH_STRATEGY_SWEEP":
                    case 2:
                        message.searchStrategy = 2;
                        break;
                    case "SEARCH_STRATEGY_SPIRAL":
                    case 3:
                        message.searchStrategy = 3;
                        break;
                    }
                    if (object.searchSensorRadius != null)
                        message.searchSensorRadius = Number(object.searchSensorRadius);
                    return message;
                };

                /**
                 * Creates a plain object from a FindFixInvestigateParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @static
                 * @param {havocai.messages.v0.FindFixInvestigateParams} message FindFixInvestigateParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FindFixInvestigateParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.searchArea = [];
                    if (options.defaults) {
                        object.track = null;
                        object.searchStrategy = options.enums === String ? "SEARCH_STRATEGY_UNKNOWN" : 0;
                        object.searchSensorRadius = 0;
                    }
                    if (message.searchArea && message.searchArea.length) {
                        object.searchArea = [];
                        for (let j = 0; j < message.searchArea.length; ++j)
                            object.searchArea[j] = $root.havocai.messages.v0.GeoPoint.toObject(message.searchArea[j], options);
                    }
                    if (message.track != null && message.hasOwnProperty("track"))
                        object.track = $root.havocai.messages.v0.ResourceRef.toObject(message.track, options);
                    if (message.searchStrategy != null && message.hasOwnProperty("searchStrategy"))
                        object.searchStrategy = options.enums === String ? $root.havocai.messages.v0.SearchStrategy[message.searchStrategy] === undefined ? message.searchStrategy : $root.havocai.messages.v0.SearchStrategy[message.searchStrategy] : message.searchStrategy;
                    if (message.searchSensorRadius != null && message.hasOwnProperty("searchSensorRadius"))
                        object.searchSensorRadius = options.json && !isFinite(message.searchSensorRadius) ? String(message.searchSensorRadius) : message.searchSensorRadius;
                    return object;
                };

                /**
                 * Converts this FindFixInvestigateParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FindFixInvestigateParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for FindFixInvestigateParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.FindFixInvestigateParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FindFixInvestigateParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.FindFixInvestigateParams";
                };

                return FindFixInvestigateParams;
            })();

            v0.CheckoutParams = (function() {

                /**
                 * Properties of a CheckoutParams.
                 * @memberof havocai.messages.v0
                 * @interface ICheckoutParams
                 */

                /**
                 * Constructs a new CheckoutParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a CheckoutParams.
                 * @implements ICheckoutParams
                 * @constructor
                 * @param {havocai.messages.v0.ICheckoutParams=} [properties] Properties to set
                 */
                function CheckoutParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new CheckoutParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.CheckoutParams
                 * @static
                 * @param {havocai.messages.v0.ICheckoutParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.CheckoutParams} CheckoutParams instance
                 */
                CheckoutParams.create = function create(properties) {
                    return new CheckoutParams(properties);
                };

                /**
                 * Encodes the specified CheckoutParams message. Does not implicitly {@link havocai.messages.v0.CheckoutParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.CheckoutParams
                 * @static
                 * @param {havocai.messages.v0.ICheckoutParams} message CheckoutParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CheckoutParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified CheckoutParams message, length delimited. Does not implicitly {@link havocai.messages.v0.CheckoutParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.CheckoutParams
                 * @static
                 * @param {havocai.messages.v0.ICheckoutParams} message CheckoutParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CheckoutParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CheckoutParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.CheckoutParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.CheckoutParams} CheckoutParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CheckoutParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.CheckoutParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CheckoutParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.CheckoutParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.CheckoutParams} CheckoutParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CheckoutParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CheckoutParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.CheckoutParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CheckoutParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a CheckoutParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.CheckoutParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.CheckoutParams} CheckoutParams
                 */
                CheckoutParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.CheckoutParams)
                        return object;
                    return new $root.havocai.messages.v0.CheckoutParams();
                };

                /**
                 * Creates a plain object from a CheckoutParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.CheckoutParams
                 * @static
                 * @param {havocai.messages.v0.CheckoutParams} message CheckoutParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CheckoutParams.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this CheckoutParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.CheckoutParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CheckoutParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for CheckoutParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.CheckoutParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                CheckoutParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.CheckoutParams";
                };

                return CheckoutParams;
            })();

            v0.BeachLaunchParams = (function() {

                /**
                 * Properties of a BeachLaunchParams.
                 * @memberof havocai.messages.v0
                 * @interface IBeachLaunchParams
                 * @property {havocai.messages.v0.IResourceRef|null} [launchZone] BeachLaunchParams launchZone
                 */

                /**
                 * Constructs a new BeachLaunchParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a BeachLaunchParams.
                 * @implements IBeachLaunchParams
                 * @constructor
                 * @param {havocai.messages.v0.IBeachLaunchParams=} [properties] Properties to set
                 */
                function BeachLaunchParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BeachLaunchParams launchZone.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} launchZone
                 * @memberof havocai.messages.v0.BeachLaunchParams
                 * @instance
                 */
                BeachLaunchParams.prototype.launchZone = null;

                /**
                 * Creates a new BeachLaunchParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.BeachLaunchParams
                 * @static
                 * @param {havocai.messages.v0.IBeachLaunchParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.BeachLaunchParams} BeachLaunchParams instance
                 */
                BeachLaunchParams.create = function create(properties) {
                    return new BeachLaunchParams(properties);
                };

                /**
                 * Encodes the specified BeachLaunchParams message. Does not implicitly {@link havocai.messages.v0.BeachLaunchParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.BeachLaunchParams
                 * @static
                 * @param {havocai.messages.v0.IBeachLaunchParams} message BeachLaunchParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BeachLaunchParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.launchZone != null && Object.hasOwnProperty.call(message, "launchZone"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.launchZone, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified BeachLaunchParams message, length delimited. Does not implicitly {@link havocai.messages.v0.BeachLaunchParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.BeachLaunchParams
                 * @static
                 * @param {havocai.messages.v0.IBeachLaunchParams} message BeachLaunchParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BeachLaunchParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BeachLaunchParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.BeachLaunchParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.BeachLaunchParams} BeachLaunchParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BeachLaunchParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.BeachLaunchParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.launchZone = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BeachLaunchParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.BeachLaunchParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.BeachLaunchParams} BeachLaunchParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BeachLaunchParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BeachLaunchParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.BeachLaunchParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BeachLaunchParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.launchZone != null && message.hasOwnProperty("launchZone")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.launchZone);
                        if (error)
                            return "launchZone." + error;
                    }
                    return null;
                };

                /**
                 * Creates a BeachLaunchParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.BeachLaunchParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.BeachLaunchParams} BeachLaunchParams
                 */
                BeachLaunchParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.BeachLaunchParams)
                        return object;
                    let message = new $root.havocai.messages.v0.BeachLaunchParams();
                    if (object.launchZone != null) {
                        if (typeof object.launchZone !== "object")
                            throw TypeError(".havocai.messages.v0.BeachLaunchParams.launchZone: object expected");
                        message.launchZone = $root.havocai.messages.v0.ResourceRef.fromObject(object.launchZone);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BeachLaunchParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.BeachLaunchParams
                 * @static
                 * @param {havocai.messages.v0.BeachLaunchParams} message BeachLaunchParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BeachLaunchParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.launchZone = null;
                    if (message.launchZone != null && message.hasOwnProperty("launchZone"))
                        object.launchZone = $root.havocai.messages.v0.ResourceRef.toObject(message.launchZone, options);
                    return object;
                };

                /**
                 * Converts this BeachLaunchParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.BeachLaunchParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BeachLaunchParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BeachLaunchParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.BeachLaunchParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BeachLaunchParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.BeachLaunchParams";
                };

                return BeachLaunchParams;
            })();

            v0.AvastParams = (function() {

                /**
                 * Properties of an AvastParams.
                 * @memberof havocai.messages.v0
                 * @interface IAvastParams
                 */

                /**
                 * Constructs a new AvastParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents an AvastParams.
                 * @implements IAvastParams
                 * @constructor
                 * @param {havocai.messages.v0.IAvastParams=} [properties] Properties to set
                 */
                function AvastParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new AvastParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.AvastParams
                 * @static
                 * @param {havocai.messages.v0.IAvastParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.AvastParams} AvastParams instance
                 */
                AvastParams.create = function create(properties) {
                    return new AvastParams(properties);
                };

                /**
                 * Encodes the specified AvastParams message. Does not implicitly {@link havocai.messages.v0.AvastParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.AvastParams
                 * @static
                 * @param {havocai.messages.v0.IAvastParams} message AvastParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AvastParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified AvastParams message, length delimited. Does not implicitly {@link havocai.messages.v0.AvastParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.AvastParams
                 * @static
                 * @param {havocai.messages.v0.IAvastParams} message AvastParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AvastParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AvastParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.AvastParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.AvastParams} AvastParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AvastParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.AvastParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AvastParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.AvastParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.AvastParams} AvastParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AvastParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AvastParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.AvastParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AvastParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an AvastParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.AvastParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.AvastParams} AvastParams
                 */
                AvastParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.AvastParams)
                        return object;
                    return new $root.havocai.messages.v0.AvastParams();
                };

                /**
                 * Creates a plain object from an AvastParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.AvastParams
                 * @static
                 * @param {havocai.messages.v0.AvastParams} message AvastParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AvastParams.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this AvastParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.AvastParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AvastParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for AvastParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.AvastParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                AvastParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.AvastParams";
                };

                return AvastParams;
            })();

            v0.JazzParams = (function() {

                /**
                 * Properties of a JazzParams.
                 * @memberof havocai.messages.v0
                 * @interface IJazzParams
                 * @property {string|null} [value] JazzParams value
                 */

                /**
                 * Constructs a new JazzParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a JazzParams.
                 * @implements IJazzParams
                 * @constructor
                 * @param {havocai.messages.v0.IJazzParams=} [properties] Properties to set
                 */
                function JazzParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * JazzParams value.
                 * @member {string} value
                 * @memberof havocai.messages.v0.JazzParams
                 * @instance
                 */
                JazzParams.prototype.value = "";

                /**
                 * Creates a new JazzParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.JazzParams
                 * @static
                 * @param {havocai.messages.v0.IJazzParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.JazzParams} JazzParams instance
                 */
                JazzParams.create = function create(properties) {
                    return new JazzParams(properties);
                };

                /**
                 * Encodes the specified JazzParams message. Does not implicitly {@link havocai.messages.v0.JazzParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.JazzParams
                 * @static
                 * @param {havocai.messages.v0.IJazzParams} message JazzParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                JazzParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                    return writer;
                };

                /**
                 * Encodes the specified JazzParams message, length delimited. Does not implicitly {@link havocai.messages.v0.JazzParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.JazzParams
                 * @static
                 * @param {havocai.messages.v0.IJazzParams} message JazzParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                JazzParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a JazzParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.JazzParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.JazzParams} JazzParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                JazzParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.JazzParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.value = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a JazzParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.JazzParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.JazzParams} JazzParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                JazzParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a JazzParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.JazzParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                JazzParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    return null;
                };

                /**
                 * Creates a JazzParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.JazzParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.JazzParams} JazzParams
                 */
                JazzParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.JazzParams)
                        return object;
                    let message = new $root.havocai.messages.v0.JazzParams();
                    if (object.value != null)
                        message.value = String(object.value);
                    return message;
                };

                /**
                 * Creates a plain object from a JazzParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.JazzParams
                 * @static
                 * @param {havocai.messages.v0.JazzParams} message JazzParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                JazzParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.value = "";
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };

                /**
                 * Converts this JazzParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.JazzParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                JazzParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for JazzParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.JazzParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                JazzParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.JazzParams";
                };

                return JazzParams;
            })();

            v0.ChariotRampControlParams = (function() {

                /**
                 * Properties of a ChariotRampControlParams.
                 * @memberof havocai.messages.v0
                 * @interface IChariotRampControlParams
                 * @property {havocai.messages.v0.ActuatorPositionGoal|null} [rampPosition] ChariotRampControlParams rampPosition
                 */

                /**
                 * Constructs a new ChariotRampControlParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a ChariotRampControlParams.
                 * @implements IChariotRampControlParams
                 * @constructor
                 * @param {havocai.messages.v0.IChariotRampControlParams=} [properties] Properties to set
                 */
                function ChariotRampControlParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChariotRampControlParams rampPosition.
                 * @member {havocai.messages.v0.ActuatorPositionGoal} rampPosition
                 * @memberof havocai.messages.v0.ChariotRampControlParams
                 * @instance
                 */
                ChariotRampControlParams.prototype.rampPosition = 0;

                /**
                 * Creates a new ChariotRampControlParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.ChariotRampControlParams
                 * @static
                 * @param {havocai.messages.v0.IChariotRampControlParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.ChariotRampControlParams} ChariotRampControlParams instance
                 */
                ChariotRampControlParams.create = function create(properties) {
                    return new ChariotRampControlParams(properties);
                };

                /**
                 * Encodes the specified ChariotRampControlParams message. Does not implicitly {@link havocai.messages.v0.ChariotRampControlParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.ChariotRampControlParams
                 * @static
                 * @param {havocai.messages.v0.IChariotRampControlParams} message ChariotRampControlParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChariotRampControlParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.rampPosition != null && Object.hasOwnProperty.call(message, "rampPosition"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rampPosition);
                    return writer;
                };

                /**
                 * Encodes the specified ChariotRampControlParams message, length delimited. Does not implicitly {@link havocai.messages.v0.ChariotRampControlParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.ChariotRampControlParams
                 * @static
                 * @param {havocai.messages.v0.IChariotRampControlParams} message ChariotRampControlParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChariotRampControlParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChariotRampControlParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.ChariotRampControlParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.ChariotRampControlParams} ChariotRampControlParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChariotRampControlParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.ChariotRampControlParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.rampPosition = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ChariotRampControlParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.ChariotRampControlParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.ChariotRampControlParams} ChariotRampControlParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChariotRampControlParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChariotRampControlParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.ChariotRampControlParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChariotRampControlParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.rampPosition != null && message.hasOwnProperty("rampPosition"))
                        switch (message.rampPosition) {
                        default:
                            return "rampPosition: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a ChariotRampControlParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.ChariotRampControlParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.ChariotRampControlParams} ChariotRampControlParams
                 */
                ChariotRampControlParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.ChariotRampControlParams)
                        return object;
                    let message = new $root.havocai.messages.v0.ChariotRampControlParams();
                    switch (object.rampPosition) {
                    default:
                        if (typeof object.rampPosition === "number") {
                            message.rampPosition = object.rampPosition;
                            break;
                        }
                        break;
                    case "ACTUATOR_POSITION_GOAL_UNKNOWN":
                    case 0:
                        message.rampPosition = 0;
                        break;
                    case "ACTUATOR_POSITION_GOAL_EXTENDED":
                    case 1:
                        message.rampPosition = 1;
                        break;
                    case "ACTUATOR_POSITION_GOAL_RETRACTED":
                    case 2:
                        message.rampPosition = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ChariotRampControlParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.ChariotRampControlParams
                 * @static
                 * @param {havocai.messages.v0.ChariotRampControlParams} message ChariotRampControlParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChariotRampControlParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.rampPosition = options.enums === String ? "ACTUATOR_POSITION_GOAL_UNKNOWN" : 0;
                    if (message.rampPosition != null && message.hasOwnProperty("rampPosition"))
                        object.rampPosition = options.enums === String ? $root.havocai.messages.v0.ActuatorPositionGoal[message.rampPosition] === undefined ? message.rampPosition : $root.havocai.messages.v0.ActuatorPositionGoal[message.rampPosition] : message.rampPosition;
                    return object;
                };

                /**
                 * Converts this ChariotRampControlParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.ChariotRampControlParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChariotRampControlParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ChariotRampControlParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.ChariotRampControlParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ChariotRampControlParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.ChariotRampControlParams";
                };

                return ChariotRampControlParams;
            })();

            v0.ChariotResupplyParams = (function() {

                /**
                 * Properties of a ChariotResupplyParams.
                 * @memberof havocai.messages.v0
                 * @interface IChariotResupplyParams
                 * @property {havocai.messages.v0.IResourceRef|null} [resupplyZone] ChariotResupplyParams resupplyZone
                 * @property {number|null} [shoreHeading] ChariotResupplyParams shoreHeading
                 */

                /**
                 * Constructs a new ChariotResupplyParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a ChariotResupplyParams.
                 * @implements IChariotResupplyParams
                 * @constructor
                 * @param {havocai.messages.v0.IChariotResupplyParams=} [properties] Properties to set
                 */
                function ChariotResupplyParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChariotResupplyParams resupplyZone.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} resupplyZone
                 * @memberof havocai.messages.v0.ChariotResupplyParams
                 * @instance
                 */
                ChariotResupplyParams.prototype.resupplyZone = null;

                /**
                 * ChariotResupplyParams shoreHeading.
                 * @member {number} shoreHeading
                 * @memberof havocai.messages.v0.ChariotResupplyParams
                 * @instance
                 */
                ChariotResupplyParams.prototype.shoreHeading = 0;

                /**
                 * Creates a new ChariotResupplyParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.ChariotResupplyParams
                 * @static
                 * @param {havocai.messages.v0.IChariotResupplyParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.ChariotResupplyParams} ChariotResupplyParams instance
                 */
                ChariotResupplyParams.create = function create(properties) {
                    return new ChariotResupplyParams(properties);
                };

                /**
                 * Encodes the specified ChariotResupplyParams message. Does not implicitly {@link havocai.messages.v0.ChariotResupplyParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.ChariotResupplyParams
                 * @static
                 * @param {havocai.messages.v0.IChariotResupplyParams} message ChariotResupplyParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChariotResupplyParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resupplyZone != null && Object.hasOwnProperty.call(message, "resupplyZone"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.resupplyZone, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.shoreHeading != null && Object.hasOwnProperty.call(message, "shoreHeading"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.shoreHeading);
                    return writer;
                };

                /**
                 * Encodes the specified ChariotResupplyParams message, length delimited. Does not implicitly {@link havocai.messages.v0.ChariotResupplyParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.ChariotResupplyParams
                 * @static
                 * @param {havocai.messages.v0.IChariotResupplyParams} message ChariotResupplyParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChariotResupplyParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChariotResupplyParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.ChariotResupplyParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.ChariotResupplyParams} ChariotResupplyParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChariotResupplyParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.ChariotResupplyParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.resupplyZone = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.shoreHeading = reader.float();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ChariotResupplyParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.ChariotResupplyParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.ChariotResupplyParams} ChariotResupplyParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChariotResupplyParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChariotResupplyParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.ChariotResupplyParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChariotResupplyParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resupplyZone != null && message.hasOwnProperty("resupplyZone")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.resupplyZone);
                        if (error)
                            return "resupplyZone." + error;
                    }
                    if (message.shoreHeading != null && message.hasOwnProperty("shoreHeading"))
                        if (typeof message.shoreHeading !== "number")
                            return "shoreHeading: number expected";
                    return null;
                };

                /**
                 * Creates a ChariotResupplyParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.ChariotResupplyParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.ChariotResupplyParams} ChariotResupplyParams
                 */
                ChariotResupplyParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.ChariotResupplyParams)
                        return object;
                    let message = new $root.havocai.messages.v0.ChariotResupplyParams();
                    if (object.resupplyZone != null) {
                        if (typeof object.resupplyZone !== "object")
                            throw TypeError(".havocai.messages.v0.ChariotResupplyParams.resupplyZone: object expected");
                        message.resupplyZone = $root.havocai.messages.v0.ResourceRef.fromObject(object.resupplyZone);
                    }
                    if (object.shoreHeading != null)
                        message.shoreHeading = Number(object.shoreHeading);
                    return message;
                };

                /**
                 * Creates a plain object from a ChariotResupplyParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.ChariotResupplyParams
                 * @static
                 * @param {havocai.messages.v0.ChariotResupplyParams} message ChariotResupplyParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChariotResupplyParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.resupplyZone = null;
                        object.shoreHeading = 0;
                    }
                    if (message.resupplyZone != null && message.hasOwnProperty("resupplyZone"))
                        object.resupplyZone = $root.havocai.messages.v0.ResourceRef.toObject(message.resupplyZone, options);
                    if (message.shoreHeading != null && message.hasOwnProperty("shoreHeading"))
                        object.shoreHeading = options.json && !isFinite(message.shoreHeading) ? String(message.shoreHeading) : message.shoreHeading;
                    return object;
                };

                /**
                 * Converts this ChariotResupplyParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.ChariotResupplyParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChariotResupplyParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ChariotResupplyParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.ChariotResupplyParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ChariotResupplyParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.ChariotResupplyParams";
                };

                return ChariotResupplyParams;
            })();

            v0.EngageTrackParams = (function() {

                /**
                 * Properties of an EngageTrackParams.
                 * @memberof havocai.messages.v0
                 * @interface IEngageTrackParams
                 * @property {havocai.messages.v0.IResourceRef|null} [track] EngageTrackParams track
                 * @property {number|null} [standoffRange] EngageTrackParams standoffRange
                 */

                /**
                 * Constructs a new EngageTrackParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents an EngageTrackParams.
                 * @implements IEngageTrackParams
                 * @constructor
                 * @param {havocai.messages.v0.IEngageTrackParams=} [properties] Properties to set
                 */
                function EngageTrackParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EngageTrackParams track.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} track
                 * @memberof havocai.messages.v0.EngageTrackParams
                 * @instance
                 */
                EngageTrackParams.prototype.track = null;

                /**
                 * EngageTrackParams standoffRange.
                 * @member {number} standoffRange
                 * @memberof havocai.messages.v0.EngageTrackParams
                 * @instance
                 */
                EngageTrackParams.prototype.standoffRange = 0;

                /**
                 * Creates a new EngageTrackParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.EngageTrackParams
                 * @static
                 * @param {havocai.messages.v0.IEngageTrackParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.EngageTrackParams} EngageTrackParams instance
                 */
                EngageTrackParams.create = function create(properties) {
                    return new EngageTrackParams(properties);
                };

                /**
                 * Encodes the specified EngageTrackParams message. Does not implicitly {@link havocai.messages.v0.EngageTrackParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.EngageTrackParams
                 * @static
                 * @param {havocai.messages.v0.IEngageTrackParams} message EngageTrackParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EngageTrackParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.track != null && Object.hasOwnProperty.call(message, "track"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.track, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.standoffRange != null && Object.hasOwnProperty.call(message, "standoffRange"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.standoffRange);
                    return writer;
                };

                /**
                 * Encodes the specified EngageTrackParams message, length delimited. Does not implicitly {@link havocai.messages.v0.EngageTrackParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.EngageTrackParams
                 * @static
                 * @param {havocai.messages.v0.IEngageTrackParams} message EngageTrackParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EngageTrackParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EngageTrackParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.EngageTrackParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.EngageTrackParams} EngageTrackParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EngageTrackParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.EngageTrackParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.track = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.standoffRange = reader.float();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EngageTrackParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.EngageTrackParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.EngageTrackParams} EngageTrackParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EngageTrackParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EngageTrackParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.EngageTrackParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EngageTrackParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.track != null && message.hasOwnProperty("track")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.track);
                        if (error)
                            return "track." + error;
                    }
                    if (message.standoffRange != null && message.hasOwnProperty("standoffRange"))
                        if (typeof message.standoffRange !== "number")
                            return "standoffRange: number expected";
                    return null;
                };

                /**
                 * Creates an EngageTrackParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.EngageTrackParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.EngageTrackParams} EngageTrackParams
                 */
                EngageTrackParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.EngageTrackParams)
                        return object;
                    let message = new $root.havocai.messages.v0.EngageTrackParams();
                    if (object.track != null) {
                        if (typeof object.track !== "object")
                            throw TypeError(".havocai.messages.v0.EngageTrackParams.track: object expected");
                        message.track = $root.havocai.messages.v0.ResourceRef.fromObject(object.track);
                    }
                    if (object.standoffRange != null)
                        message.standoffRange = Number(object.standoffRange);
                    return message;
                };

                /**
                 * Creates a plain object from an EngageTrackParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.EngageTrackParams
                 * @static
                 * @param {havocai.messages.v0.EngageTrackParams} message EngageTrackParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EngageTrackParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.track = null;
                        object.standoffRange = 0;
                    }
                    if (message.track != null && message.hasOwnProperty("track"))
                        object.track = $root.havocai.messages.v0.ResourceRef.toObject(message.track, options);
                    if (message.standoffRange != null && message.hasOwnProperty("standoffRange"))
                        object.standoffRange = options.json && !isFinite(message.standoffRange) ? String(message.standoffRange) : message.standoffRange;
                    return object;
                };

                /**
                 * Converts this EngageTrackParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.EngageTrackParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EngageTrackParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for EngageTrackParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.EngageTrackParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EngageTrackParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.EngageTrackParams";
                };

                return EngageTrackParams;
            })();

            v0.Metadata = (function() {

                /**
                 * Properties of a Metadata.
                 * @memberof havocai.messages.v0
                 * @interface IMetadata
                 * @property {havocai.messages.v0.ResourceKind|null} [kind] Metadata kind
                 * @property {string|null} [id] Metadata id
                 * @property {string|null} [name] Metadata name
                 * @property {string|null} [description] Metadata description
                 * @property {number|Long|null} [creationTime] Metadata creationTime
                 * @property {number|Long|null} [modificationTime] Metadata modificationTime
                 * @property {havocai.messages.v0.DataSource|null} [dataSource] Metadata dataSource
                 * @property {Object.<string,string>|null} [labels] Metadata labels
                 * @property {Array.<string>|null} [tags] Metadata tags
                 */

                /**
                 * Constructs a new Metadata.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Metadata.
                 * @implements IMetadata
                 * @constructor
                 * @param {havocai.messages.v0.IMetadata=} [properties] Properties to set
                 */
                function Metadata(properties) {
                    this.labels = {};
                    this.tags = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Metadata kind.
                 * @member {havocai.messages.v0.ResourceKind} kind
                 * @memberof havocai.messages.v0.Metadata
                 * @instance
                 */
                Metadata.prototype.kind = 0;

                /**
                 * Metadata id.
                 * @member {string} id
                 * @memberof havocai.messages.v0.Metadata
                 * @instance
                 */
                Metadata.prototype.id = "";

                /**
                 * Metadata name.
                 * @member {string} name
                 * @memberof havocai.messages.v0.Metadata
                 * @instance
                 */
                Metadata.prototype.name = "";

                /**
                 * Metadata description.
                 * @member {string} description
                 * @memberof havocai.messages.v0.Metadata
                 * @instance
                 */
                Metadata.prototype.description = "";

                /**
                 * Metadata creationTime.
                 * @member {number|Long} creationTime
                 * @memberof havocai.messages.v0.Metadata
                 * @instance
                 */
                Metadata.prototype.creationTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Metadata modificationTime.
                 * @member {number|Long} modificationTime
                 * @memberof havocai.messages.v0.Metadata
                 * @instance
                 */
                Metadata.prototype.modificationTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Metadata dataSource.
                 * @member {havocai.messages.v0.DataSource} dataSource
                 * @memberof havocai.messages.v0.Metadata
                 * @instance
                 */
                Metadata.prototype.dataSource = 0;

                /**
                 * Metadata labels.
                 * @member {Object.<string,string>} labels
                 * @memberof havocai.messages.v0.Metadata
                 * @instance
                 */
                Metadata.prototype.labels = $util.emptyObject;

                /**
                 * Metadata tags.
                 * @member {Array.<string>} tags
                 * @memberof havocai.messages.v0.Metadata
                 * @instance
                 */
                Metadata.prototype.tags = $util.emptyArray;

                /**
                 * Creates a new Metadata instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Metadata
                 * @static
                 * @param {havocai.messages.v0.IMetadata=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Metadata} Metadata instance
                 */
                Metadata.create = function create(properties) {
                    return new Metadata(properties);
                };

                /**
                 * Encodes the specified Metadata message. Does not implicitly {@link havocai.messages.v0.Metadata.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Metadata
                 * @static
                 * @param {havocai.messages.v0.IMetadata} message Metadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Metadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.kind);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                    if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                        for (let keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 12, wireType 2 =*/98).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                    if (message.creationTime != null && Object.hasOwnProperty.call(message, "creationTime"))
                        writer.uint32(/* id 13, wireType 0 =*/104).int64(message.creationTime);
                    if (message.modificationTime != null && Object.hasOwnProperty.call(message, "modificationTime"))
                        writer.uint32(/* id 14, wireType 0 =*/112).int64(message.modificationTime);
                    if (message.tags != null && message.tags.length)
                        for (let i = 0; i < message.tags.length; ++i)
                            writer.uint32(/* id 15, wireType 2 =*/122).string(message.tags[i]);
                    if (message.dataSource != null && Object.hasOwnProperty.call(message, "dataSource"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.dataSource);
                    return writer;
                };

                /**
                 * Encodes the specified Metadata message, length delimited. Does not implicitly {@link havocai.messages.v0.Metadata.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Metadata
                 * @static
                 * @param {havocai.messages.v0.IMetadata} message Metadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Metadata.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Metadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Metadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Metadata} Metadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Metadata.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Metadata(), key, value;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.kind = reader.int32();
                                break;
                            }
                        case 2: {
                                message.id = reader.string();
                                break;
                            }
                        case 3: {
                                message.name = reader.string();
                                break;
                            }
                        case 4: {
                                message.description = reader.string();
                                break;
                            }
                        case 13: {
                                message.creationTime = reader.int64();
                                break;
                            }
                        case 14: {
                                message.modificationTime = reader.int64();
                                break;
                            }
                        case 16: {
                                message.dataSource = reader.int32();
                                break;
                            }
                        case 12: {
                                if (message.labels === $util.emptyObject)
                                    message.labels = {};
                                let end2 = reader.uint32() + reader.pos;
                                key = "";
                                value = "";
                                while (reader.pos < end2) {
                                    let tag2 = reader.uint32();
                                    switch (tag2 >>> 3) {
                                    case 1:
                                        key = reader.string();
                                        break;
                                    case 2:
                                        value = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag2 & 7);
                                        break;
                                    }
                                }
                                message.labels[key] = value;
                                break;
                            }
                        case 15: {
                                if (!(message.tags && message.tags.length))
                                    message.tags = [];
                                message.tags.push(reader.string());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Metadata message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Metadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Metadata} Metadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Metadata.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Metadata message.
                 * @function verify
                 * @memberof havocai.messages.v0.Metadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Metadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        switch (message.kind) {
                        default:
                            return "kind: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.creationTime != null && message.hasOwnProperty("creationTime"))
                        if (!$util.isInteger(message.creationTime) && !(message.creationTime && $util.isInteger(message.creationTime.low) && $util.isInteger(message.creationTime.high)))
                            return "creationTime: integer|Long expected";
                    if (message.modificationTime != null && message.hasOwnProperty("modificationTime"))
                        if (!$util.isInteger(message.modificationTime) && !(message.modificationTime && $util.isInteger(message.modificationTime.low) && $util.isInteger(message.modificationTime.high)))
                            return "modificationTime: integer|Long expected";
                    if (message.dataSource != null && message.hasOwnProperty("dataSource"))
                        switch (message.dataSource) {
                        default:
                            return "dataSource: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (let i = 0; i < message.tags.length; ++i)
                            if (!$util.isString(message.tags[i]))
                                return "tags: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Metadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Metadata} Metadata
                 */
                Metadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Metadata)
                        return object;
                    let message = new $root.havocai.messages.v0.Metadata();
                    switch (object.kind) {
                    default:
                        if (typeof object.kind === "number") {
                            message.kind = object.kind;
                            break;
                        }
                        break;
                    case "RESOURCE_KIND_UNKNOWN":
                    case 0:
                        message.kind = 0;
                        break;
                    case "RESOURCE_KIND_SECTOR":
                    case 1:
                        message.kind = 1;
                        break;
                    case "RESOURCE_KIND_ZONE":
                    case 2:
                        message.kind = 2;
                        break;
                    case "RESOURCE_KIND_TEAM":
                    case 3:
                        message.kind = 3;
                        break;
                    case "RESOURCE_KIND_BOAT":
                    case 4:
                        message.kind = 4;
                        break;
                    case "RESOURCE_KIND_TRACK":
                    case 6:
                        message.kind = 6;
                        break;
                    case "RESOURCE_KIND_PLAY_DEFINITION":
                    case 7:
                        message.kind = 7;
                        break;
                    case "RESOURCE_KIND_PLAY_EXECUTION":
                    case 8:
                        message.kind = 8;
                        break;
                    case "RESOURCE_KIND_PLAY_RUNNER":
                    case 9:
                        message.kind = 9;
                        break;
                    case "RESOURCE_KIND_SIMULATION":
                    case 10:
                        message.kind = 10;
                        break;
                    }
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.creationTime != null)
                        if ($util.Long)
                            (message.creationTime = $util.Long.fromValue(object.creationTime)).unsigned = false;
                        else if (typeof object.creationTime === "string")
                            message.creationTime = parseInt(object.creationTime, 10);
                        else if (typeof object.creationTime === "number")
                            message.creationTime = object.creationTime;
                        else if (typeof object.creationTime === "object")
                            message.creationTime = new $util.LongBits(object.creationTime.low >>> 0, object.creationTime.high >>> 0).toNumber();
                    if (object.modificationTime != null)
                        if ($util.Long)
                            (message.modificationTime = $util.Long.fromValue(object.modificationTime)).unsigned = false;
                        else if (typeof object.modificationTime === "string")
                            message.modificationTime = parseInt(object.modificationTime, 10);
                        else if (typeof object.modificationTime === "number")
                            message.modificationTime = object.modificationTime;
                        else if (typeof object.modificationTime === "object")
                            message.modificationTime = new $util.LongBits(object.modificationTime.low >>> 0, object.modificationTime.high >>> 0).toNumber();
                    switch (object.dataSource) {
                    default:
                        if (typeof object.dataSource === "number") {
                            message.dataSource = object.dataSource;
                            break;
                        }
                        break;
                    case "DATA_SOURCE_UNKNOWN":
                    case 0:
                        message.dataSource = 0;
                        break;
                    case "DATA_SOURCE_API":
                    case 1:
                        message.dataSource = 1;
                        break;
                    case "DATA_SOURCE_TAK":
                    case 2:
                        message.dataSource = 2;
                        break;
                    case "DATA_SOURCE_LATTICE":
                    case 3:
                        message.dataSource = 3;
                        break;
                    }
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".havocai.messages.v0.Metadata.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.tags) {
                        if (!Array.isArray(object.tags))
                            throw TypeError(".havocai.messages.v0.Metadata.tags: array expected");
                        message.tags = [];
                        for (let i = 0; i < object.tags.length; ++i)
                            message.tags[i] = String(object.tags[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Metadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Metadata
                 * @static
                 * @param {havocai.messages.v0.Metadata} message Metadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Metadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.tags = [];
                    if (options.objects || options.defaults)
                        object.labels = {};
                    if (options.defaults) {
                        object.kind = options.enums === String ? "RESOURCE_KIND_UNKNOWN" : 0;
                        object.id = "";
                        object.name = "";
                        object.description = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.creationTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.creationTime = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.modificationTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.modificationTime = options.longs === String ? "0" : 0;
                        object.dataSource = options.enums === String ? "DATA_SOURCE_UNKNOWN" : 0;
                    }
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        object.kind = options.enums === String ? $root.havocai.messages.v0.ResourceKind[message.kind] === undefined ? message.kind : $root.havocai.messages.v0.ResourceKind[message.kind] : message.kind;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.creationTime != null && message.hasOwnProperty("creationTime"))
                        if (typeof message.creationTime === "number")
                            object.creationTime = options.longs === String ? String(message.creationTime) : message.creationTime;
                        else
                            object.creationTime = options.longs === String ? $util.Long.prototype.toString.call(message.creationTime) : options.longs === Number ? new $util.LongBits(message.creationTime.low >>> 0, message.creationTime.high >>> 0).toNumber() : message.creationTime;
                    if (message.modificationTime != null && message.hasOwnProperty("modificationTime"))
                        if (typeof message.modificationTime === "number")
                            object.modificationTime = options.longs === String ? String(message.modificationTime) : message.modificationTime;
                        else
                            object.modificationTime = options.longs === String ? $util.Long.prototype.toString.call(message.modificationTime) : options.longs === Number ? new $util.LongBits(message.modificationTime.low >>> 0, message.modificationTime.high >>> 0).toNumber() : message.modificationTime;
                    if (message.tags && message.tags.length) {
                        object.tags = [];
                        for (let j = 0; j < message.tags.length; ++j)
                            object.tags[j] = message.tags[j];
                    }
                    if (message.dataSource != null && message.hasOwnProperty("dataSource"))
                        object.dataSource = options.enums === String ? $root.havocai.messages.v0.DataSource[message.dataSource] === undefined ? message.dataSource : $root.havocai.messages.v0.DataSource[message.dataSource] : message.dataSource;
                    return object;
                };

                /**
                 * Converts this Metadata to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Metadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Metadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Metadata
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Metadata
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Metadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Metadata";
                };

                return Metadata;
            })();

            v0.ResourceRef = (function() {

                /**
                 * Properties of a ResourceRef.
                 * @memberof havocai.messages.v0
                 * @interface IResourceRef
                 * @property {havocai.messages.v0.ResourceKind|null} [kind] ResourceRef kind
                 * @property {string|null} [id] ResourceRef id
                 * @property {string|null} [name] ResourceRef name
                 */

                /**
                 * Constructs a new ResourceRef.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a ResourceRef.
                 * @implements IResourceRef
                 * @constructor
                 * @param {havocai.messages.v0.IResourceRef=} [properties] Properties to set
                 */
                function ResourceRef(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ResourceRef kind.
                 * @member {havocai.messages.v0.ResourceKind} kind
                 * @memberof havocai.messages.v0.ResourceRef
                 * @instance
                 */
                ResourceRef.prototype.kind = 0;

                /**
                 * ResourceRef id.
                 * @member {string} id
                 * @memberof havocai.messages.v0.ResourceRef
                 * @instance
                 */
                ResourceRef.prototype.id = "";

                /**
                 * ResourceRef name.
                 * @member {string} name
                 * @memberof havocai.messages.v0.ResourceRef
                 * @instance
                 */
                ResourceRef.prototype.name = "";

                /**
                 * Creates a new ResourceRef instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.ResourceRef
                 * @static
                 * @param {havocai.messages.v0.IResourceRef=} [properties] Properties to set
                 * @returns {havocai.messages.v0.ResourceRef} ResourceRef instance
                 */
                ResourceRef.create = function create(properties) {
                    return new ResourceRef(properties);
                };

                /**
                 * Encodes the specified ResourceRef message. Does not implicitly {@link havocai.messages.v0.ResourceRef.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.ResourceRef
                 * @static
                 * @param {havocai.messages.v0.IResourceRef} message ResourceRef message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ResourceRef.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.kind);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    return writer;
                };

                /**
                 * Encodes the specified ResourceRef message, length delimited. Does not implicitly {@link havocai.messages.v0.ResourceRef.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.ResourceRef
                 * @static
                 * @param {havocai.messages.v0.IResourceRef} message ResourceRef message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ResourceRef.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ResourceRef message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.ResourceRef
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.ResourceRef} ResourceRef
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ResourceRef.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.ResourceRef();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.kind = reader.int32();
                                break;
                            }
                        case 2: {
                                message.id = reader.string();
                                break;
                            }
                        case 3: {
                                message.name = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ResourceRef message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.ResourceRef
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.ResourceRef} ResourceRef
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ResourceRef.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ResourceRef message.
                 * @function verify
                 * @memberof havocai.messages.v0.ResourceRef
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ResourceRef.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        switch (message.kind) {
                        default:
                            return "kind: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a ResourceRef message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.ResourceRef
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.ResourceRef} ResourceRef
                 */
                ResourceRef.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.ResourceRef)
                        return object;
                    let message = new $root.havocai.messages.v0.ResourceRef();
                    switch (object.kind) {
                    default:
                        if (typeof object.kind === "number") {
                            message.kind = object.kind;
                            break;
                        }
                        break;
                    case "RESOURCE_KIND_UNKNOWN":
                    case 0:
                        message.kind = 0;
                        break;
                    case "RESOURCE_KIND_SECTOR":
                    case 1:
                        message.kind = 1;
                        break;
                    case "RESOURCE_KIND_ZONE":
                    case 2:
                        message.kind = 2;
                        break;
                    case "RESOURCE_KIND_TEAM":
                    case 3:
                        message.kind = 3;
                        break;
                    case "RESOURCE_KIND_BOAT":
                    case 4:
                        message.kind = 4;
                        break;
                    case "RESOURCE_KIND_TRACK":
                    case 6:
                        message.kind = 6;
                        break;
                    case "RESOURCE_KIND_PLAY_DEFINITION":
                    case 7:
                        message.kind = 7;
                        break;
                    case "RESOURCE_KIND_PLAY_EXECUTION":
                    case 8:
                        message.kind = 8;
                        break;
                    case "RESOURCE_KIND_PLAY_RUNNER":
                    case 9:
                        message.kind = 9;
                        break;
                    case "RESOURCE_KIND_SIMULATION":
                    case 10:
                        message.kind = 10;
                        break;
                    }
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a ResourceRef message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.ResourceRef
                 * @static
                 * @param {havocai.messages.v0.ResourceRef} message ResourceRef
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ResourceRef.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.kind = options.enums === String ? "RESOURCE_KIND_UNKNOWN" : 0;
                        object.id = "";
                        object.name = "";
                    }
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        object.kind = options.enums === String ? $root.havocai.messages.v0.ResourceKind[message.kind] === undefined ? message.kind : $root.havocai.messages.v0.ResourceKind[message.kind] : message.kind;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this ResourceRef to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.ResourceRef
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ResourceRef.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ResourceRef
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.ResourceRef
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ResourceRef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.ResourceRef";
                };

                return ResourceRef;
            })();

            v0.Component = (function() {

                /**
                 * Properties of a Component.
                 * @memberof havocai.messages.v0
                 * @interface IComponent
                 * @property {havocai.messages.v0.ComponentKey|null} [key] Component key
                 * @property {havocai.messages.v0.Health|null} [health] Component health
                 * @property {Array.<havocai.messages.v0.IError>|null} [errors] Component errors
                 */

                /**
                 * Constructs a new Component.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Component.
                 * @implements IComponent
                 * @constructor
                 * @param {havocai.messages.v0.IComponent=} [properties] Properties to set
                 */
                function Component(properties) {
                    this.errors = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Component key.
                 * @member {havocai.messages.v0.ComponentKey} key
                 * @memberof havocai.messages.v0.Component
                 * @instance
                 */
                Component.prototype.key = 0;

                /**
                 * Component health.
                 * @member {havocai.messages.v0.Health} health
                 * @memberof havocai.messages.v0.Component
                 * @instance
                 */
                Component.prototype.health = 0;

                /**
                 * Component errors.
                 * @member {Array.<havocai.messages.v0.IError>} errors
                 * @memberof havocai.messages.v0.Component
                 * @instance
                 */
                Component.prototype.errors = $util.emptyArray;

                /**
                 * Creates a new Component instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Component
                 * @static
                 * @param {havocai.messages.v0.IComponent=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Component} Component instance
                 */
                Component.create = function create(properties) {
                    return new Component(properties);
                };

                /**
                 * Encodes the specified Component message. Does not implicitly {@link havocai.messages.v0.Component.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Component
                 * @static
                 * @param {havocai.messages.v0.IComponent} message Component message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Component.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.key);
                    if (message.health != null && Object.hasOwnProperty.call(message, "health"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.health);
                    if (message.errors != null && message.errors.length)
                        for (let i = 0; i < message.errors.length; ++i)
                            $root.havocai.messages.v0.Error.encode(message.errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Component message, length delimited. Does not implicitly {@link havocai.messages.v0.Component.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Component
                 * @static
                 * @param {havocai.messages.v0.IComponent} message Component message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Component.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Component message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Component
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Component} Component
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Component.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Component();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.key = reader.int32();
                                break;
                            }
                        case 2: {
                                message.health = reader.int32();
                                break;
                            }
                        case 3: {
                                if (!(message.errors && message.errors.length))
                                    message.errors = [];
                                message.errors.push($root.havocai.messages.v0.Error.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Component message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Component
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Component} Component
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Component.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Component message.
                 * @function verify
                 * @memberof havocai.messages.v0.Component
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Component.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        switch (message.key) {
                        default:
                            return "key: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.health != null && message.hasOwnProperty("health"))
                        switch (message.health) {
                        default:
                            return "health: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (let i = 0; i < message.errors.length; ++i) {
                            let error = $root.havocai.messages.v0.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Component message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Component
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Component} Component
                 */
                Component.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Component)
                        return object;
                    let message = new $root.havocai.messages.v0.Component();
                    switch (object.key) {
                    default:
                        if (typeof object.key === "number") {
                            message.key = object.key;
                            break;
                        }
                        break;
                    case "COMPONENT_KEY_UNKNOWN":
                    case 0:
                        message.key = 0;
                        break;
                    case "COMPONENT_KEY_BATTERY":
                    case 1:
                        message.key = 1;
                        break;
                    case "COMPONENT_KEY_COMMS":
                    case 2:
                        message.key = 2;
                        break;
                    case "COMPONENT_KEY_SENSORS":
                    case 3:
                        message.key = 3;
                        break;
                    case "COMPONENT_KEY_GPS":
                    case 4:
                        message.key = 4;
                        break;
                    case "COMPONENT_KEY_MISSION_MANAGER":
                    case 5:
                        message.key = 5;
                        break;
                    }
                    switch (object.health) {
                    default:
                        if (typeof object.health === "number") {
                            message.health = object.health;
                            break;
                        }
                        break;
                    case "HEALTH_UNKNOWN":
                    case 0:
                        message.health = 0;
                        break;
                    case "HEALTH_HEALTHY":
                    case 1:
                        message.health = 1;
                        break;
                    case "HEALTH_DEGRADED":
                    case 2:
                        message.health = 2;
                        break;
                    case "HEALTH_FATAL":
                    case 3:
                        message.health = 3;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".havocai.messages.v0.Component.errors: array expected");
                        message.errors = [];
                        for (let i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".havocai.messages.v0.Component.errors: object expected");
                            message.errors[i] = $root.havocai.messages.v0.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Component message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Component
                 * @static
                 * @param {havocai.messages.v0.Component} message Component
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Component.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.defaults) {
                        object.key = options.enums === String ? "COMPONENT_KEY_UNKNOWN" : 0;
                        object.health = options.enums === String ? "HEALTH_UNKNOWN" : 0;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.enums === String ? $root.havocai.messages.v0.ComponentKey[message.key] === undefined ? message.key : $root.havocai.messages.v0.ComponentKey[message.key] : message.key;
                    if (message.health != null && message.hasOwnProperty("health"))
                        object.health = options.enums === String ? $root.havocai.messages.v0.Health[message.health] === undefined ? message.health : $root.havocai.messages.v0.Health[message.health] : message.health;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (let j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.havocai.messages.v0.Error.toObject(message.errors[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Component to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Component
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Component.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Component
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Component
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Component.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Component";
                };

                return Component;
            })();

            v0.Task = (function() {

                /**
                 * Properties of a Task.
                 * @memberof havocai.messages.v0
                 * @interface ITask
                 * @property {havocai.messages.v0.PlayKey|null} [playKey] Task playKey
                 * @property {havocai.messages.v0.TaskKey|null} [key] Task key
                 * @property {number|null} [boatCount] Task boatCount
                 * @property {number|Long|null} [eta] Task eta
                 * @property {number|Long|null} [lastEta] Task lastEta
                 * @property {havocai.messages.v0.IGeoPoint|null} [goalLocation] Task goalLocation
                 * @property {havocai.messages.v0.IResourceRef|null} [goalTrack] Task goalTrack
                 * @property {havocai.messages.v0.IResourceRef|null} [goalZone] Task goalZone
                 * @property {havocai.messages.v0.WaypointType|null} [goalWaypointType] Task goalWaypointType
                 * @property {Array.<havocai.messages.v0.Command>|null} [supportedCommands] Task supportedCommands
                 */

                /**
                 * Constructs a new Task.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Task.
                 * @implements ITask
                 * @constructor
                 * @param {havocai.messages.v0.ITask=} [properties] Properties to set
                 */
                function Task(properties) {
                    this.supportedCommands = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Task playKey.
                 * @member {havocai.messages.v0.PlayKey} playKey
                 * @memberof havocai.messages.v0.Task
                 * @instance
                 */
                Task.prototype.playKey = 0;

                /**
                 * Task key.
                 * @member {havocai.messages.v0.TaskKey} key
                 * @memberof havocai.messages.v0.Task
                 * @instance
                 */
                Task.prototype.key = 0;

                /**
                 * Task boatCount.
                 * @member {number} boatCount
                 * @memberof havocai.messages.v0.Task
                 * @instance
                 */
                Task.prototype.boatCount = 0;

                /**
                 * Task eta.
                 * @member {number|Long} eta
                 * @memberof havocai.messages.v0.Task
                 * @instance
                 */
                Task.prototype.eta = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Task lastEta.
                 * @member {number|Long} lastEta
                 * @memberof havocai.messages.v0.Task
                 * @instance
                 */
                Task.prototype.lastEta = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Task goalLocation.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} goalLocation
                 * @memberof havocai.messages.v0.Task
                 * @instance
                 */
                Task.prototype.goalLocation = null;

                /**
                 * Task goalTrack.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} goalTrack
                 * @memberof havocai.messages.v0.Task
                 * @instance
                 */
                Task.prototype.goalTrack = null;

                /**
                 * Task goalZone.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} goalZone
                 * @memberof havocai.messages.v0.Task
                 * @instance
                 */
                Task.prototype.goalZone = null;

                /**
                 * Task goalWaypointType.
                 * @member {havocai.messages.v0.WaypointType} goalWaypointType
                 * @memberof havocai.messages.v0.Task
                 * @instance
                 */
                Task.prototype.goalWaypointType = 0;

                /**
                 * Task supportedCommands.
                 * @member {Array.<havocai.messages.v0.Command>} supportedCommands
                 * @memberof havocai.messages.v0.Task
                 * @instance
                 */
                Task.prototype.supportedCommands = $util.emptyArray;

                /**
                 * Creates a new Task instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Task
                 * @static
                 * @param {havocai.messages.v0.ITask=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Task} Task instance
                 */
                Task.create = function create(properties) {
                    return new Task(properties);
                };

                /**
                 * Encodes the specified Task message. Does not implicitly {@link havocai.messages.v0.Task.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Task
                 * @static
                 * @param {havocai.messages.v0.ITask} message Task message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Task.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.playKey != null && Object.hasOwnProperty.call(message, "playKey"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.playKey);
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.key);
                    if (message.boatCount != null && Object.hasOwnProperty.call(message, "boatCount"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.boatCount);
                    if (message.eta != null && Object.hasOwnProperty.call(message, "eta"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.eta);
                    if (message.lastEta != null && Object.hasOwnProperty.call(message, "lastEta"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.lastEta);
                    if (message.goalLocation != null && Object.hasOwnProperty.call(message, "goalLocation"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.goalLocation, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.goalTrack != null && Object.hasOwnProperty.call(message, "goalTrack"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.goalTrack, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.goalZone != null && Object.hasOwnProperty.call(message, "goalZone"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.goalZone, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.goalWaypointType != null && Object.hasOwnProperty.call(message, "goalWaypointType"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.goalWaypointType);
                    if (message.supportedCommands != null && message.supportedCommands.length) {
                        writer.uint32(/* id 10, wireType 2 =*/82).fork();
                        for (let i = 0; i < message.supportedCommands.length; ++i)
                            writer.int32(message.supportedCommands[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified Task message, length delimited. Does not implicitly {@link havocai.messages.v0.Task.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Task
                 * @static
                 * @param {havocai.messages.v0.ITask} message Task message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Task.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Task message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Task
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Task} Task
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Task.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Task();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.playKey = reader.int32();
                                break;
                            }
                        case 2: {
                                message.key = reader.int32();
                                break;
                            }
                        case 3: {
                                message.boatCount = reader.uint32();
                                break;
                            }
                        case 4: {
                                message.eta = reader.uint64();
                                break;
                            }
                        case 5: {
                                message.lastEta = reader.uint64();
                                break;
                            }
                        case 6: {
                                message.goalLocation = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        case 7: {
                                message.goalTrack = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 8: {
                                message.goalZone = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 9: {
                                message.goalWaypointType = reader.int32();
                                break;
                            }
                        case 10: {
                                if (!(message.supportedCommands && message.supportedCommands.length))
                                    message.supportedCommands = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.supportedCommands.push(reader.int32());
                                } else
                                    message.supportedCommands.push(reader.int32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Task message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Task
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Task} Task
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Task.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Task message.
                 * @function verify
                 * @memberof havocai.messages.v0.Task
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Task.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.playKey != null && message.hasOwnProperty("playKey"))
                        switch (message.playKey) {
                        default:
                            return "playKey: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                            break;
                        }
                    if (message.key != null && message.hasOwnProperty("key"))
                        switch (message.key) {
                        default:
                            return "key: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                        case 19:
                        case 20:
                        case 21:
                        case 22:
                        case 23:
                        case 24:
                        case 25:
                        case 26:
                        case 27:
                        case 28:
                        case 29:
                        case 30:
                        case 31:
                        case 32:
                        case 33:
                            break;
                        }
                    if (message.boatCount != null && message.hasOwnProperty("boatCount"))
                        if (!$util.isInteger(message.boatCount))
                            return "boatCount: integer expected";
                    if (message.eta != null && message.hasOwnProperty("eta"))
                        if (!$util.isInteger(message.eta) && !(message.eta && $util.isInteger(message.eta.low) && $util.isInteger(message.eta.high)))
                            return "eta: integer|Long expected";
                    if (message.lastEta != null && message.hasOwnProperty("lastEta"))
                        if (!$util.isInteger(message.lastEta) && !(message.lastEta && $util.isInteger(message.lastEta.low) && $util.isInteger(message.lastEta.high)))
                            return "lastEta: integer|Long expected";
                    if (message.goalLocation != null && message.hasOwnProperty("goalLocation")) {
                        let error = $root.havocai.messages.v0.GeoPoint.verify(message.goalLocation);
                        if (error)
                            return "goalLocation." + error;
                    }
                    if (message.goalTrack != null && message.hasOwnProperty("goalTrack")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.goalTrack);
                        if (error)
                            return "goalTrack." + error;
                    }
                    if (message.goalZone != null && message.hasOwnProperty("goalZone")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.goalZone);
                        if (error)
                            return "goalZone." + error;
                    }
                    if (message.goalWaypointType != null && message.hasOwnProperty("goalWaypointType"))
                        switch (message.goalWaypointType) {
                        default:
                            return "goalWaypointType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.supportedCommands != null && message.hasOwnProperty("supportedCommands")) {
                        if (!Array.isArray(message.supportedCommands))
                            return "supportedCommands: array expected";
                        for (let i = 0; i < message.supportedCommands.length; ++i)
                            switch (message.supportedCommands[i]) {
                            default:
                                return "supportedCommands: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                                break;
                            }
                    }
                    return null;
                };

                /**
                 * Creates a Task message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Task
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Task} Task
                 */
                Task.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Task)
                        return object;
                    let message = new $root.havocai.messages.v0.Task();
                    switch (object.playKey) {
                    default:
                        if (typeof object.playKey === "number") {
                            message.playKey = object.playKey;
                            break;
                        }
                        break;
                    case "PLAY_KEY_UNKNOWN":
                    case 0:
                        message.playKey = 0;
                        break;
                    case "PLAY_KEY_NONE":
                    case 1:
                        message.playKey = 1;
                        break;
                    case "PLAY_KEY_DIRECT":
                    case 2:
                        message.playKey = 2;
                        break;
                    case "PLAY_KEY_CONTESTED_LOGISTICS":
                    case 3:
                        message.playKey = 3;
                        break;
                    case "PLAY_KEY_PAYLOAD_ORCHESTRATION":
                    case 4:
                        message.playKey = 4;
                        break;
                    case "PLAY_KEY_FIND_FIX_INVESTIGATE":
                    case 5:
                        message.playKey = 5;
                        break;
                    case "PLAY_KEY_FIND_FIX_INVESTIGATE_EPISCI":
                    case 6:
                        message.playKey = 6;
                        break;
                    case "PLAY_KEY_CHECKOUT":
                    case 7:
                        message.playKey = 7;
                        break;
                    case "PLAY_KEY_BEACH_LAUNCH":
                    case 8:
                        message.playKey = 8;
                        break;
                    case "PLAY_KEY_AVAST":
                    case 9:
                        message.playKey = 9;
                        break;
                    case "PLAY_KEY_JAZZ":
                    case 10:
                        message.playKey = 10;
                        break;
                    case "PLAY_KEY_CHARIOT_RAMP_CONTROL":
                    case 11:
                        message.playKey = 11;
                        break;
                    case "PLAY_KEY_CHARIOT_RESUPPLY":
                    case 12:
                        message.playKey = 12;
                        break;
                    case "PLAY_KEY_ENGAGE_TRACK":
                    case 13:
                        message.playKey = 13;
                        break;
                    case "PLAY_KEY_DYNAMIC":
                    case 14:
                        message.playKey = 14;
                        break;
                    }
                    switch (object.key) {
                    default:
                        if (typeof object.key === "number") {
                            message.key = object.key;
                            break;
                        }
                        break;
                    case "TASK_KEY_UNKNOWN":
                    case 0:
                        message.key = 0;
                        break;
                    case "TASK_KEY_NONE":
                    case 1:
                        message.key = 1;
                        break;
                    case "TASK_KEY_DIRECT_MOVE_GOAL":
                    case 2:
                        message.key = 2;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_STAGING":
                    case 3:
                        message.key = 3;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_STAGING":
                    case 4:
                        message.key = 4;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_LANDING":
                    case 5:
                        message.key = 5;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_LANDING":
                    case 6:
                        message.key = 6;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_EGRESS":
                    case 7:
                        message.key = 7;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_EGRESS":
                    case 8:
                        message.key = 8;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_STAGING":
                    case 9:
                        message.key = 9;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_STAGING":
                    case 10:
                        message.key = 10;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_LANDING":
                    case 11:
                        message.key = 11;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_LANDING":
                    case 12:
                        message.key = 12;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_EGRESS":
                    case 13:
                        message.key = 13;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_EGRESS":
                    case 14:
                        message.key = 14;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP":
                    case 15:
                        message.key = 15;
                        break;
                    case "TASK_KEY_PAYLOAD_ORCHESTRATION_MOVE_TRACK":
                    case 16:
                        message.key = 16;
                        break;
                    case "TASK_KEY_FIND_FIX_INVESTIGATE_FIND_TRACK":
                    case 17:
                        message.key = 17;
                        break;
                    case "TASK_KEY_FIND_FIX_INVESTIGATE_INVESTIGATE_TRACK":
                    case 18:
                        message.key = 18;
                        break;
                    case "TASK_KEY_CHECKOUT_WAIT":
                    case 19:
                        message.key = 19;
                        break;
                    case "TASK_KEY_CHECKOUT_TEST_DRIVE":
                    case 20:
                        message.key = 20;
                        break;
                    case "TASK_KEY_BEACH_LAUNCH_WAIT":
                    case 21:
                        message.key = 21;
                        break;
                    case "TASK_KEY_BEACH_LAUNCH_DEPLOY":
                    case 22:
                        message.key = 22;
                        break;
                    case "TASK_KEY_BEACH_LAUNCH_MOVE_EGRESS":
                    case 23:
                        message.key = 23;
                        break;
                    case "TASK_KEY_AVAST_WAIT":
                    case 24:
                        message.key = 24;
                        break;
                    case "TASK_KEY_JAZZ_ACTIVE":
                    case 25:
                        message.key = 25;
                        break;
                    case "TASK_KEY_CHARIOT_RAMP_CONTROL_ACTIVE":
                    case 26:
                        message.key = 26;
                        break;
                    case "TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_STAGING":
                    case 27:
                        message.key = 27;
                        break;
                    case "TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_SHORE":
                    case 28:
                        message.key = 28;
                        break;
                    case "TASK_KEY_CHARIOT_RESUPPLY_LANDING_CONFIRMATION":
                    case 29:
                        message.key = 29;
                        break;
                    case "TASK_KEY_CHARIOT_RESUPPLY_DEPART_CONFIRMATION":
                    case 30:
                        message.key = 30;
                        break;
                    case "TASK_KEY_CHARIOT_RESUPPLY_MOVE_OFF_SHORE":
                    case 31:
                        message.key = 31;
                        break;
                    case "TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_EGRESS":
                    case 32:
                        message.key = 32;
                        break;
                    case "TASK_KEY_ENGAGE_TRACK":
                    case 33:
                        message.key = 33;
                        break;
                    }
                    if (object.boatCount != null)
                        message.boatCount = object.boatCount >>> 0;
                    if (object.eta != null)
                        if ($util.Long)
                            (message.eta = $util.Long.fromValue(object.eta)).unsigned = true;
                        else if (typeof object.eta === "string")
                            message.eta = parseInt(object.eta, 10);
                        else if (typeof object.eta === "number")
                            message.eta = object.eta;
                        else if (typeof object.eta === "object")
                            message.eta = new $util.LongBits(object.eta.low >>> 0, object.eta.high >>> 0).toNumber(true);
                    if (object.lastEta != null)
                        if ($util.Long)
                            (message.lastEta = $util.Long.fromValue(object.lastEta)).unsigned = true;
                        else if (typeof object.lastEta === "string")
                            message.lastEta = parseInt(object.lastEta, 10);
                        else if (typeof object.lastEta === "number")
                            message.lastEta = object.lastEta;
                        else if (typeof object.lastEta === "object")
                            message.lastEta = new $util.LongBits(object.lastEta.low >>> 0, object.lastEta.high >>> 0).toNumber(true);
                    if (object.goalLocation != null) {
                        if (typeof object.goalLocation !== "object")
                            throw TypeError(".havocai.messages.v0.Task.goalLocation: object expected");
                        message.goalLocation = $root.havocai.messages.v0.GeoPoint.fromObject(object.goalLocation);
                    }
                    if (object.goalTrack != null) {
                        if (typeof object.goalTrack !== "object")
                            throw TypeError(".havocai.messages.v0.Task.goalTrack: object expected");
                        message.goalTrack = $root.havocai.messages.v0.ResourceRef.fromObject(object.goalTrack);
                    }
                    if (object.goalZone != null) {
                        if (typeof object.goalZone !== "object")
                            throw TypeError(".havocai.messages.v0.Task.goalZone: object expected");
                        message.goalZone = $root.havocai.messages.v0.ResourceRef.fromObject(object.goalZone);
                    }
                    switch (object.goalWaypointType) {
                    default:
                        if (typeof object.goalWaypointType === "number") {
                            message.goalWaypointType = object.goalWaypointType;
                            break;
                        }
                        break;
                    case "WAYPOINT_TYPE_UNKNOWN":
                    case 0:
                        message.goalWaypointType = 0;
                        break;
                    case "WAYPOINT_TYPE_LANDING":
                    case 1:
                        message.goalWaypointType = 1;
                        break;
                    case "WAYPOINT_TYPE_EGRESS":
                    case 2:
                        message.goalWaypointType = 2;
                        break;
                    case "WAYPOINT_TYPE_STAGING":
                    case 3:
                        message.goalWaypointType = 3;
                        break;
                    }
                    if (object.supportedCommands) {
                        if (!Array.isArray(object.supportedCommands))
                            throw TypeError(".havocai.messages.v0.Task.supportedCommands: array expected");
                        message.supportedCommands = [];
                        for (let i = 0; i < object.supportedCommands.length; ++i)
                            switch (object.supportedCommands[i]) {
                            default:
                                if (typeof object.supportedCommands[i] === "number") {
                                    message.supportedCommands[i] = object.supportedCommands[i];
                                    break;
                                }
                            case "COMMAND_UNKNOWN":
                            case 0:
                                message.supportedCommands[i] = 0;
                                break;
                            case "COMMAND_CANCEL":
                            case 1:
                                message.supportedCommands[i] = 1;
                                break;
                            case "COMMAND_GO":
                            case 2:
                                message.supportedCommands[i] = 2;
                                break;
                            case "COMMAND_AUTHORIZE":
                            case 3:
                                message.supportedCommands[i] = 3;
                                break;
                            case "COMMAND_CUSTOM":
                            case 4:
                                message.supportedCommands[i] = 4;
                                break;
                            case "COMMAND_AUTHORIZE_TASK":
                            case 5:
                                message.supportedCommands[i] = 5;
                                break;
                            case "COMMAND_EXECUTE_TASK":
                            case 6:
                                message.supportedCommands[i] = 6;
                                break;
                            case "COMMAND_TRIGGER_PAYLOAD":
                            case 7:
                                message.supportedCommands[i] = 7;
                                break;
                            }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Task message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Task
                 * @static
                 * @param {havocai.messages.v0.Task} message Task
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Task.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.supportedCommands = [];
                    if (options.defaults) {
                        object.playKey = options.enums === String ? "PLAY_KEY_UNKNOWN" : 0;
                        object.key = options.enums === String ? "TASK_KEY_UNKNOWN" : 0;
                        object.boatCount = 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.eta = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.eta = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.lastEta = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.lastEta = options.longs === String ? "0" : 0;
                        object.goalLocation = null;
                        object.goalTrack = null;
                        object.goalZone = null;
                        object.goalWaypointType = options.enums === String ? "WAYPOINT_TYPE_UNKNOWN" : 0;
                    }
                    if (message.playKey != null && message.hasOwnProperty("playKey"))
                        object.playKey = options.enums === String ? $root.havocai.messages.v0.PlayKey[message.playKey] === undefined ? message.playKey : $root.havocai.messages.v0.PlayKey[message.playKey] : message.playKey;
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.enums === String ? $root.havocai.messages.v0.TaskKey[message.key] === undefined ? message.key : $root.havocai.messages.v0.TaskKey[message.key] : message.key;
                    if (message.boatCount != null && message.hasOwnProperty("boatCount"))
                        object.boatCount = message.boatCount;
                    if (message.eta != null && message.hasOwnProperty("eta"))
                        if (typeof message.eta === "number")
                            object.eta = options.longs === String ? String(message.eta) : message.eta;
                        else
                            object.eta = options.longs === String ? $util.Long.prototype.toString.call(message.eta) : options.longs === Number ? new $util.LongBits(message.eta.low >>> 0, message.eta.high >>> 0).toNumber(true) : message.eta;
                    if (message.lastEta != null && message.hasOwnProperty("lastEta"))
                        if (typeof message.lastEta === "number")
                            object.lastEta = options.longs === String ? String(message.lastEta) : message.lastEta;
                        else
                            object.lastEta = options.longs === String ? $util.Long.prototype.toString.call(message.lastEta) : options.longs === Number ? new $util.LongBits(message.lastEta.low >>> 0, message.lastEta.high >>> 0).toNumber(true) : message.lastEta;
                    if (message.goalLocation != null && message.hasOwnProperty("goalLocation"))
                        object.goalLocation = $root.havocai.messages.v0.GeoPoint.toObject(message.goalLocation, options);
                    if (message.goalTrack != null && message.hasOwnProperty("goalTrack"))
                        object.goalTrack = $root.havocai.messages.v0.ResourceRef.toObject(message.goalTrack, options);
                    if (message.goalZone != null && message.hasOwnProperty("goalZone"))
                        object.goalZone = $root.havocai.messages.v0.ResourceRef.toObject(message.goalZone, options);
                    if (message.goalWaypointType != null && message.hasOwnProperty("goalWaypointType"))
                        object.goalWaypointType = options.enums === String ? $root.havocai.messages.v0.WaypointType[message.goalWaypointType] === undefined ? message.goalWaypointType : $root.havocai.messages.v0.WaypointType[message.goalWaypointType] : message.goalWaypointType;
                    if (message.supportedCommands && message.supportedCommands.length) {
                        object.supportedCommands = [];
                        for (let j = 0; j < message.supportedCommands.length; ++j)
                            object.supportedCommands[j] = options.enums === String ? $root.havocai.messages.v0.Command[message.supportedCommands[j]] === undefined ? message.supportedCommands[j] : $root.havocai.messages.v0.Command[message.supportedCommands[j]] : message.supportedCommands[j];
                    }
                    return object;
                };

                /**
                 * Converts this Task to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Task
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Task.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Task
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Task
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Task.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Task";
                };

                return Task;
            })();

            v0.TaskParams = (function() {

                /**
                 * Properties of a TaskParams.
                 * @memberof havocai.messages.v0
                 * @interface ITaskParams
                 * @property {havocai.messages.v0.TaskKey|null} [key] TaskParams key
                 * @property {number|null} [targetSpeed] TaskParams targetSpeed
                 * @property {number|null} [goalDistanceTolerance] TaskParams goalDistanceTolerance
                 */

                /**
                 * Constructs a new TaskParams.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a TaskParams.
                 * @implements ITaskParams
                 * @constructor
                 * @param {havocai.messages.v0.ITaskParams=} [properties] Properties to set
                 */
                function TaskParams(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TaskParams key.
                 * @member {havocai.messages.v0.TaskKey} key
                 * @memberof havocai.messages.v0.TaskParams
                 * @instance
                 */
                TaskParams.prototype.key = 0;

                /**
                 * TaskParams targetSpeed.
                 * @member {number} targetSpeed
                 * @memberof havocai.messages.v0.TaskParams
                 * @instance
                 */
                TaskParams.prototype.targetSpeed = 0;

                /**
                 * TaskParams goalDistanceTolerance.
                 * @member {number} goalDistanceTolerance
                 * @memberof havocai.messages.v0.TaskParams
                 * @instance
                 */
                TaskParams.prototype.goalDistanceTolerance = 0;

                /**
                 * Creates a new TaskParams instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.TaskParams
                 * @static
                 * @param {havocai.messages.v0.ITaskParams=} [properties] Properties to set
                 * @returns {havocai.messages.v0.TaskParams} TaskParams instance
                 */
                TaskParams.create = function create(properties) {
                    return new TaskParams(properties);
                };

                /**
                 * Encodes the specified TaskParams message. Does not implicitly {@link havocai.messages.v0.TaskParams.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.TaskParams
                 * @static
                 * @param {havocai.messages.v0.ITaskParams} message TaskParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.key);
                    if (message.targetSpeed != null && Object.hasOwnProperty.call(message, "targetSpeed"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.targetSpeed);
                    if (message.goalDistanceTolerance != null && Object.hasOwnProperty.call(message, "goalDistanceTolerance"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.goalDistanceTolerance);
                    return writer;
                };

                /**
                 * Encodes the specified TaskParams message, length delimited. Does not implicitly {@link havocai.messages.v0.TaskParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.TaskParams
                 * @static
                 * @param {havocai.messages.v0.ITaskParams} message TaskParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TaskParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.TaskParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.TaskParams} TaskParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskParams.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.TaskParams();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.key = reader.int32();
                                break;
                            }
                        case 2: {
                                message.targetSpeed = reader.float();
                                break;
                            }
                        case 3: {
                                message.goalDistanceTolerance = reader.float();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TaskParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.TaskParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.TaskParams} TaskParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TaskParams message.
                 * @function verify
                 * @memberof havocai.messages.v0.TaskParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        switch (message.key) {
                        default:
                            return "key: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                        case 19:
                        case 20:
                        case 21:
                        case 22:
                        case 23:
                        case 24:
                        case 25:
                        case 26:
                        case 27:
                        case 28:
                        case 29:
                        case 30:
                        case 31:
                        case 32:
                        case 33:
                            break;
                        }
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        if (typeof message.targetSpeed !== "number")
                            return "targetSpeed: number expected";
                    if (message.goalDistanceTolerance != null && message.hasOwnProperty("goalDistanceTolerance"))
                        if (typeof message.goalDistanceTolerance !== "number")
                            return "goalDistanceTolerance: number expected";
                    return null;
                };

                /**
                 * Creates a TaskParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.TaskParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.TaskParams} TaskParams
                 */
                TaskParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.TaskParams)
                        return object;
                    let message = new $root.havocai.messages.v0.TaskParams();
                    switch (object.key) {
                    default:
                        if (typeof object.key === "number") {
                            message.key = object.key;
                            break;
                        }
                        break;
                    case "TASK_KEY_UNKNOWN":
                    case 0:
                        message.key = 0;
                        break;
                    case "TASK_KEY_NONE":
                    case 1:
                        message.key = 1;
                        break;
                    case "TASK_KEY_DIRECT_MOVE_GOAL":
                    case 2:
                        message.key = 2;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_STAGING":
                    case 3:
                        message.key = 3;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_STAGING":
                    case 4:
                        message.key = 4;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_LANDING":
                    case 5:
                        message.key = 5;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_LANDING":
                    case 6:
                        message.key = 6;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_EGRESS":
                    case 7:
                        message.key = 7;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_EGRESS":
                    case 8:
                        message.key = 8;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_STAGING":
                    case 9:
                        message.key = 9;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_STAGING":
                    case 10:
                        message.key = 10;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_LANDING":
                    case 11:
                        message.key = 11;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_LANDING":
                    case 12:
                        message.key = 12;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_EGRESS":
                    case 13:
                        message.key = 13;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_EGRESS":
                    case 14:
                        message.key = 14;
                        break;
                    case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP":
                    case 15:
                        message.key = 15;
                        break;
                    case "TASK_KEY_PAYLOAD_ORCHESTRATION_MOVE_TRACK":
                    case 16:
                        message.key = 16;
                        break;
                    case "TASK_KEY_FIND_FIX_INVESTIGATE_FIND_TRACK":
                    case 17:
                        message.key = 17;
                        break;
                    case "TASK_KEY_FIND_FIX_INVESTIGATE_INVESTIGATE_TRACK":
                    case 18:
                        message.key = 18;
                        break;
                    case "TASK_KEY_CHECKOUT_WAIT":
                    case 19:
                        message.key = 19;
                        break;
                    case "TASK_KEY_CHECKOUT_TEST_DRIVE":
                    case 20:
                        message.key = 20;
                        break;
                    case "TASK_KEY_BEACH_LAUNCH_WAIT":
                    case 21:
                        message.key = 21;
                        break;
                    case "TASK_KEY_BEACH_LAUNCH_DEPLOY":
                    case 22:
                        message.key = 22;
                        break;
                    case "TASK_KEY_BEACH_LAUNCH_MOVE_EGRESS":
                    case 23:
                        message.key = 23;
                        break;
                    case "TASK_KEY_AVAST_WAIT":
                    case 24:
                        message.key = 24;
                        break;
                    case "TASK_KEY_JAZZ_ACTIVE":
                    case 25:
                        message.key = 25;
                        break;
                    case "TASK_KEY_CHARIOT_RAMP_CONTROL_ACTIVE":
                    case 26:
                        message.key = 26;
                        break;
                    case "TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_STAGING":
                    case 27:
                        message.key = 27;
                        break;
                    case "TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_SHORE":
                    case 28:
                        message.key = 28;
                        break;
                    case "TASK_KEY_CHARIOT_RESUPPLY_LANDING_CONFIRMATION":
                    case 29:
                        message.key = 29;
                        break;
                    case "TASK_KEY_CHARIOT_RESUPPLY_DEPART_CONFIRMATION":
                    case 30:
                        message.key = 30;
                        break;
                    case "TASK_KEY_CHARIOT_RESUPPLY_MOVE_OFF_SHORE":
                    case 31:
                        message.key = 31;
                        break;
                    case "TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_EGRESS":
                    case 32:
                        message.key = 32;
                        break;
                    case "TASK_KEY_ENGAGE_TRACK":
                    case 33:
                        message.key = 33;
                        break;
                    }
                    if (object.targetSpeed != null)
                        message.targetSpeed = Number(object.targetSpeed);
                    if (object.goalDistanceTolerance != null)
                        message.goalDistanceTolerance = Number(object.goalDistanceTolerance);
                    return message;
                };

                /**
                 * Creates a plain object from a TaskParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.TaskParams
                 * @static
                 * @param {havocai.messages.v0.TaskParams} message TaskParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TaskParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.key = options.enums === String ? "TASK_KEY_UNKNOWN" : 0;
                        object.targetSpeed = 0;
                        object.goalDistanceTolerance = 0;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.enums === String ? $root.havocai.messages.v0.TaskKey[message.key] === undefined ? message.key : $root.havocai.messages.v0.TaskKey[message.key] : message.key;
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        object.targetSpeed = options.json && !isFinite(message.targetSpeed) ? String(message.targetSpeed) : message.targetSpeed;
                    if (message.goalDistanceTolerance != null && message.hasOwnProperty("goalDistanceTolerance"))
                        object.goalDistanceTolerance = options.json && !isFinite(message.goalDistanceTolerance) ? String(message.goalDistanceTolerance) : message.goalDistanceTolerance;
                    return object;
                };

                /**
                 * Converts this TaskParams to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.TaskParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TaskParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TaskParams
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.TaskParams
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TaskParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.TaskParams";
                };

                return TaskParams;
            })();

            v0.Subscription = (function() {

                /**
                 * Properties of a Subscription.
                 * @memberof havocai.messages.v0
                 * @interface ISubscription
                 * @property {havocai.messages.v0.Encoding|null} [encoding] Subscription encoding
                 * @property {number|null} [updateInterval] Subscription updateInterval
                 * @property {Array.<havocai.messages.v0.ISubscriptionCriteria>|null} [criteria] Subscription criteria
                 */

                /**
                 * Constructs a new Subscription.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Subscription.
                 * @implements ISubscription
                 * @constructor
                 * @param {havocai.messages.v0.ISubscription=} [properties] Properties to set
                 */
                function Subscription(properties) {
                    this.criteria = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Subscription encoding.
                 * @member {havocai.messages.v0.Encoding} encoding
                 * @memberof havocai.messages.v0.Subscription
                 * @instance
                 */
                Subscription.prototype.encoding = 0;

                /**
                 * Subscription updateInterval.
                 * @member {number} updateInterval
                 * @memberof havocai.messages.v0.Subscription
                 * @instance
                 */
                Subscription.prototype.updateInterval = 0;

                /**
                 * Subscription criteria.
                 * @member {Array.<havocai.messages.v0.ISubscriptionCriteria>} criteria
                 * @memberof havocai.messages.v0.Subscription
                 * @instance
                 */
                Subscription.prototype.criteria = $util.emptyArray;

                /**
                 * Creates a new Subscription instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Subscription
                 * @static
                 * @param {havocai.messages.v0.ISubscription=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Subscription} Subscription instance
                 */
                Subscription.create = function create(properties) {
                    return new Subscription(properties);
                };

                /**
                 * Encodes the specified Subscription message. Does not implicitly {@link havocai.messages.v0.Subscription.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Subscription
                 * @static
                 * @param {havocai.messages.v0.ISubscription} message Subscription message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Subscription.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.encoding != null && Object.hasOwnProperty.call(message, "encoding"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.encoding);
                    if (message.updateInterval != null && Object.hasOwnProperty.call(message, "updateInterval"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.updateInterval);
                    if (message.criteria != null && message.criteria.length)
                        for (let i = 0; i < message.criteria.length; ++i)
                            $root.havocai.messages.v0.SubscriptionCriteria.encode(message.criteria[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Subscription message, length delimited. Does not implicitly {@link havocai.messages.v0.Subscription.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Subscription
                 * @static
                 * @param {havocai.messages.v0.ISubscription} message Subscription message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Subscription.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Subscription message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Subscription
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Subscription} Subscription
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Subscription.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Subscription();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.encoding = reader.int32();
                                break;
                            }
                        case 2: {
                                message.updateInterval = reader.uint32();
                                break;
                            }
                        case 15: {
                                if (!(message.criteria && message.criteria.length))
                                    message.criteria = [];
                                message.criteria.push($root.havocai.messages.v0.SubscriptionCriteria.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Subscription message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Subscription
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Subscription} Subscription
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Subscription.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Subscription message.
                 * @function verify
                 * @memberof havocai.messages.v0.Subscription
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Subscription.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.encoding != null && message.hasOwnProperty("encoding"))
                        switch (message.encoding) {
                        default:
                            return "encoding: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.updateInterval != null && message.hasOwnProperty("updateInterval"))
                        if (!$util.isInteger(message.updateInterval))
                            return "updateInterval: integer expected";
                    if (message.criteria != null && message.hasOwnProperty("criteria")) {
                        if (!Array.isArray(message.criteria))
                            return "criteria: array expected";
                        for (let i = 0; i < message.criteria.length; ++i) {
                            let error = $root.havocai.messages.v0.SubscriptionCriteria.verify(message.criteria[i]);
                            if (error)
                                return "criteria." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Subscription message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Subscription
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Subscription} Subscription
                 */
                Subscription.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Subscription)
                        return object;
                    let message = new $root.havocai.messages.v0.Subscription();
                    switch (object.encoding) {
                    default:
                        if (typeof object.encoding === "number") {
                            message.encoding = object.encoding;
                            break;
                        }
                        break;
                    case "ENCODING_JSON":
                    case 0:
                        message.encoding = 0;
                        break;
                    case "ENCODING_PROTOBUF":
                    case 1:
                        message.encoding = 1;
                        break;
                    }
                    if (object.updateInterval != null)
                        message.updateInterval = object.updateInterval >>> 0;
                    if (object.criteria) {
                        if (!Array.isArray(object.criteria))
                            throw TypeError(".havocai.messages.v0.Subscription.criteria: array expected");
                        message.criteria = [];
                        for (let i = 0; i < object.criteria.length; ++i) {
                            if (typeof object.criteria[i] !== "object")
                                throw TypeError(".havocai.messages.v0.Subscription.criteria: object expected");
                            message.criteria[i] = $root.havocai.messages.v0.SubscriptionCriteria.fromObject(object.criteria[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Subscription message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Subscription
                 * @static
                 * @param {havocai.messages.v0.Subscription} message Subscription
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Subscription.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.criteria = [];
                    if (options.defaults) {
                        object.encoding = options.enums === String ? "ENCODING_JSON" : 0;
                        object.updateInterval = 0;
                    }
                    if (message.encoding != null && message.hasOwnProperty("encoding"))
                        object.encoding = options.enums === String ? $root.havocai.messages.v0.Encoding[message.encoding] === undefined ? message.encoding : $root.havocai.messages.v0.Encoding[message.encoding] : message.encoding;
                    if (message.updateInterval != null && message.hasOwnProperty("updateInterval"))
                        object.updateInterval = message.updateInterval;
                    if (message.criteria && message.criteria.length) {
                        object.criteria = [];
                        for (let j = 0; j < message.criteria.length; ++j)
                            object.criteria[j] = $root.havocai.messages.v0.SubscriptionCriteria.toObject(message.criteria[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Subscription to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Subscription
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Subscription.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Subscription
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Subscription
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Subscription.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Subscription";
                };

                return Subscription;
            })();

            v0.SubscriptionCriteria = (function() {

                /**
                 * Properties of a SubscriptionCriteria.
                 * @memberof havocai.messages.v0
                 * @interface ISubscriptionCriteria
                 * @property {havocai.messages.v0.ResourceKind|null} [resourceKind] SubscriptionCriteria resourceKind
                 * @property {Array.<havocai.messages.v0.IGeoPoint>|null} [area] SubscriptionCriteria area
                 * @property {Array.<string>|null} [names] SubscriptionCriteria names
                 * @property {Array.<string>|null} [sectors] SubscriptionCriteria sectors
                 * @property {Array.<havocai.messages.v0.PlayKey>|null} [plays] SubscriptionCriteria plays
                 * @property {Array.<string>|null} [teams] SubscriptionCriteria teams
                 * @property {Array.<havocai.messages.v0.TaskKey>|null} [tasks] SubscriptionCriteria tasks
                 * @property {Array.<havocai.messages.v0.ZoneType>|null} [zoneTypes] SubscriptionCriteria zoneTypes
                 * @property {Array.<havocai.messages.v0.WaypointType>|null} [waypointTypes] SubscriptionCriteria waypointTypes
                 * @property {Array.<havocai.messages.v0.TrackType>|null} [trackTypes] SubscriptionCriteria trackTypes
                 * @property {Array.<havocai.messages.v0.Affiliation>|null} [affiliations] SubscriptionCriteria affiliations
                 * @property {Array.<string>|null} [tags] SubscriptionCriteria tags
                 */

                /**
                 * Constructs a new SubscriptionCriteria.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a SubscriptionCriteria.
                 * @implements ISubscriptionCriteria
                 * @constructor
                 * @param {havocai.messages.v0.ISubscriptionCriteria=} [properties] Properties to set
                 */
                function SubscriptionCriteria(properties) {
                    this.area = [];
                    this.names = [];
                    this.sectors = [];
                    this.plays = [];
                    this.teams = [];
                    this.tasks = [];
                    this.zoneTypes = [];
                    this.waypointTypes = [];
                    this.trackTypes = [];
                    this.affiliations = [];
                    this.tags = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SubscriptionCriteria resourceKind.
                 * @member {havocai.messages.v0.ResourceKind} resourceKind
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @instance
                 */
                SubscriptionCriteria.prototype.resourceKind = 0;

                /**
                 * SubscriptionCriteria area.
                 * @member {Array.<havocai.messages.v0.IGeoPoint>} area
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @instance
                 */
                SubscriptionCriteria.prototype.area = $util.emptyArray;

                /**
                 * SubscriptionCriteria names.
                 * @member {Array.<string>} names
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @instance
                 */
                SubscriptionCriteria.prototype.names = $util.emptyArray;

                /**
                 * SubscriptionCriteria sectors.
                 * @member {Array.<string>} sectors
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @instance
                 */
                SubscriptionCriteria.prototype.sectors = $util.emptyArray;

                /**
                 * SubscriptionCriteria plays.
                 * @member {Array.<havocai.messages.v0.PlayKey>} plays
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @instance
                 */
                SubscriptionCriteria.prototype.plays = $util.emptyArray;

                /**
                 * SubscriptionCriteria teams.
                 * @member {Array.<string>} teams
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @instance
                 */
                SubscriptionCriteria.prototype.teams = $util.emptyArray;

                /**
                 * SubscriptionCriteria tasks.
                 * @member {Array.<havocai.messages.v0.TaskKey>} tasks
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @instance
                 */
                SubscriptionCriteria.prototype.tasks = $util.emptyArray;

                /**
                 * SubscriptionCriteria zoneTypes.
                 * @member {Array.<havocai.messages.v0.ZoneType>} zoneTypes
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @instance
                 */
                SubscriptionCriteria.prototype.zoneTypes = $util.emptyArray;

                /**
                 * SubscriptionCriteria waypointTypes.
                 * @member {Array.<havocai.messages.v0.WaypointType>} waypointTypes
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @instance
                 */
                SubscriptionCriteria.prototype.waypointTypes = $util.emptyArray;

                /**
                 * SubscriptionCriteria trackTypes.
                 * @member {Array.<havocai.messages.v0.TrackType>} trackTypes
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @instance
                 */
                SubscriptionCriteria.prototype.trackTypes = $util.emptyArray;

                /**
                 * SubscriptionCriteria affiliations.
                 * @member {Array.<havocai.messages.v0.Affiliation>} affiliations
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @instance
                 */
                SubscriptionCriteria.prototype.affiliations = $util.emptyArray;

                /**
                 * SubscriptionCriteria tags.
                 * @member {Array.<string>} tags
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @instance
                 */
                SubscriptionCriteria.prototype.tags = $util.emptyArray;

                /**
                 * Creates a new SubscriptionCriteria instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @static
                 * @param {havocai.messages.v0.ISubscriptionCriteria=} [properties] Properties to set
                 * @returns {havocai.messages.v0.SubscriptionCriteria} SubscriptionCriteria instance
                 */
                SubscriptionCriteria.create = function create(properties) {
                    return new SubscriptionCriteria(properties);
                };

                /**
                 * Encodes the specified SubscriptionCriteria message. Does not implicitly {@link havocai.messages.v0.SubscriptionCriteria.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @static
                 * @param {havocai.messages.v0.ISubscriptionCriteria} message SubscriptionCriteria message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SubscriptionCriteria.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resourceKind != null && Object.hasOwnProperty.call(message, "resourceKind"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resourceKind);
                    if (message.area != null && message.area.length)
                        for (let i = 0; i < message.area.length; ++i)
                            $root.havocai.messages.v0.GeoPoint.encode(message.area[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.names != null && message.names.length)
                        for (let i = 0; i < message.names.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.names[i]);
                    if (message.sectors != null && message.sectors.length)
                        for (let i = 0; i < message.sectors.length; ++i)
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.sectors[i]);
                    if (message.plays != null && message.plays.length) {
                        writer.uint32(/* id 5, wireType 2 =*/42).fork();
                        for (let i = 0; i < message.plays.length; ++i)
                            writer.int32(message.plays[i]);
                        writer.ldelim();
                    }
                    if (message.teams != null && message.teams.length)
                        for (let i = 0; i < message.teams.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.teams[i]);
                    if (message.tasks != null && message.tasks.length) {
                        writer.uint32(/* id 7, wireType 2 =*/58).fork();
                        for (let i = 0; i < message.tasks.length; ++i)
                            writer.int32(message.tasks[i]);
                        writer.ldelim();
                    }
                    if (message.zoneTypes != null && message.zoneTypes.length) {
                        writer.uint32(/* id 8, wireType 2 =*/66).fork();
                        for (let i = 0; i < message.zoneTypes.length; ++i)
                            writer.int32(message.zoneTypes[i]);
                        writer.ldelim();
                    }
                    if (message.waypointTypes != null && message.waypointTypes.length) {
                        writer.uint32(/* id 9, wireType 2 =*/74).fork();
                        for (let i = 0; i < message.waypointTypes.length; ++i)
                            writer.int32(message.waypointTypes[i]);
                        writer.ldelim();
                    }
                    if (message.trackTypes != null && message.trackTypes.length) {
                        writer.uint32(/* id 10, wireType 2 =*/82).fork();
                        for (let i = 0; i < message.trackTypes.length; ++i)
                            writer.int32(message.trackTypes[i]);
                        writer.ldelim();
                    }
                    if (message.affiliations != null && message.affiliations.length) {
                        writer.uint32(/* id 11, wireType 2 =*/90).fork();
                        for (let i = 0; i < message.affiliations.length; ++i)
                            writer.int32(message.affiliations[i]);
                        writer.ldelim();
                    }
                    if (message.tags != null && message.tags.length)
                        for (let i = 0; i < message.tags.length; ++i)
                            writer.uint32(/* id 15, wireType 2 =*/122).string(message.tags[i]);
                    return writer;
                };

                /**
                 * Encodes the specified SubscriptionCriteria message, length delimited. Does not implicitly {@link havocai.messages.v0.SubscriptionCriteria.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @static
                 * @param {havocai.messages.v0.ISubscriptionCriteria} message SubscriptionCriteria message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SubscriptionCriteria.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SubscriptionCriteria message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.SubscriptionCriteria} SubscriptionCriteria
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SubscriptionCriteria.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.SubscriptionCriteria();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.resourceKind = reader.int32();
                                break;
                            }
                        case 2: {
                                if (!(message.area && message.area.length))
                                    message.area = [];
                                message.area.push($root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                if (!(message.names && message.names.length))
                                    message.names = [];
                                message.names.push(reader.string());
                                break;
                            }
                        case 4: {
                                if (!(message.sectors && message.sectors.length))
                                    message.sectors = [];
                                message.sectors.push(reader.string());
                                break;
                            }
                        case 5: {
                                if (!(message.plays && message.plays.length))
                                    message.plays = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.plays.push(reader.int32());
                                } else
                                    message.plays.push(reader.int32());
                                break;
                            }
                        case 6: {
                                if (!(message.teams && message.teams.length))
                                    message.teams = [];
                                message.teams.push(reader.string());
                                break;
                            }
                        case 7: {
                                if (!(message.tasks && message.tasks.length))
                                    message.tasks = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.tasks.push(reader.int32());
                                } else
                                    message.tasks.push(reader.int32());
                                break;
                            }
                        case 8: {
                                if (!(message.zoneTypes && message.zoneTypes.length))
                                    message.zoneTypes = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.zoneTypes.push(reader.int32());
                                } else
                                    message.zoneTypes.push(reader.int32());
                                break;
                            }
                        case 9: {
                                if (!(message.waypointTypes && message.waypointTypes.length))
                                    message.waypointTypes = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.waypointTypes.push(reader.int32());
                                } else
                                    message.waypointTypes.push(reader.int32());
                                break;
                            }
                        case 10: {
                                if (!(message.trackTypes && message.trackTypes.length))
                                    message.trackTypes = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.trackTypes.push(reader.int32());
                                } else
                                    message.trackTypes.push(reader.int32());
                                break;
                            }
                        case 11: {
                                if (!(message.affiliations && message.affiliations.length))
                                    message.affiliations = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.affiliations.push(reader.int32());
                                } else
                                    message.affiliations.push(reader.int32());
                                break;
                            }
                        case 15: {
                                if (!(message.tags && message.tags.length))
                                    message.tags = [];
                                message.tags.push(reader.string());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SubscriptionCriteria message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.SubscriptionCriteria} SubscriptionCriteria
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SubscriptionCriteria.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SubscriptionCriteria message.
                 * @function verify
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SubscriptionCriteria.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resourceKind != null && message.hasOwnProperty("resourceKind"))
                        switch (message.resourceKind) {
                        default:
                            return "resourceKind: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                            break;
                        }
                    if (message.area != null && message.hasOwnProperty("area")) {
                        if (!Array.isArray(message.area))
                            return "area: array expected";
                        for (let i = 0; i < message.area.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoPoint.verify(message.area[i]);
                            if (error)
                                return "area." + error;
                        }
                    }
                    if (message.names != null && message.hasOwnProperty("names")) {
                        if (!Array.isArray(message.names))
                            return "names: array expected";
                        for (let i = 0; i < message.names.length; ++i)
                            if (!$util.isString(message.names[i]))
                                return "names: string[] expected";
                    }
                    if (message.sectors != null && message.hasOwnProperty("sectors")) {
                        if (!Array.isArray(message.sectors))
                            return "sectors: array expected";
                        for (let i = 0; i < message.sectors.length; ++i)
                            if (!$util.isString(message.sectors[i]))
                                return "sectors: string[] expected";
                    }
                    if (message.plays != null && message.hasOwnProperty("plays")) {
                        if (!Array.isArray(message.plays))
                            return "plays: array expected";
                        for (let i = 0; i < message.plays.length; ++i)
                            switch (message.plays[i]) {
                            default:
                                return "plays: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                                break;
                            }
                    }
                    if (message.teams != null && message.hasOwnProperty("teams")) {
                        if (!Array.isArray(message.teams))
                            return "teams: array expected";
                        for (let i = 0; i < message.teams.length; ++i)
                            if (!$util.isString(message.teams[i]))
                                return "teams: string[] expected";
                    }
                    if (message.tasks != null && message.hasOwnProperty("tasks")) {
                        if (!Array.isArray(message.tasks))
                            return "tasks: array expected";
                        for (let i = 0; i < message.tasks.length; ++i)
                            switch (message.tasks[i]) {
                            default:
                                return "tasks: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                            case 24:
                            case 25:
                            case 26:
                            case 27:
                            case 28:
                            case 29:
                            case 30:
                            case 31:
                            case 32:
                            case 33:
                                break;
                            }
                    }
                    if (message.zoneTypes != null && message.hasOwnProperty("zoneTypes")) {
                        if (!Array.isArray(message.zoneTypes))
                            return "zoneTypes: array expected";
                        for (let i = 0; i < message.zoneTypes.length; ++i)
                            switch (message.zoneTypes[i]) {
                            default:
                                return "zoneTypes: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                    }
                    if (message.waypointTypes != null && message.hasOwnProperty("waypointTypes")) {
                        if (!Array.isArray(message.waypointTypes))
                            return "waypointTypes: array expected";
                        for (let i = 0; i < message.waypointTypes.length; ++i)
                            switch (message.waypointTypes[i]) {
                            default:
                                return "waypointTypes: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                    }
                    if (message.trackTypes != null && message.hasOwnProperty("trackTypes")) {
                        if (!Array.isArray(message.trackTypes))
                            return "trackTypes: array expected";
                        for (let i = 0; i < message.trackTypes.length; ++i)
                            switch (message.trackTypes[i]) {
                            default:
                                return "trackTypes: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 98:
                            case 99:
                                break;
                            }
                    }
                    if (message.affiliations != null && message.hasOwnProperty("affiliations")) {
                        if (!Array.isArray(message.affiliations))
                            return "affiliations: array expected";
                        for (let i = 0; i < message.affiliations.length; ++i)
                            switch (message.affiliations[i]) {
                            default:
                                return "affiliations: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            }
                    }
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (let i = 0; i < message.tags.length; ++i)
                            if (!$util.isString(message.tags[i]))
                                return "tags: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a SubscriptionCriteria message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.SubscriptionCriteria} SubscriptionCriteria
                 */
                SubscriptionCriteria.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.SubscriptionCriteria)
                        return object;
                    let message = new $root.havocai.messages.v0.SubscriptionCriteria();
                    switch (object.resourceKind) {
                    default:
                        if (typeof object.resourceKind === "number") {
                            message.resourceKind = object.resourceKind;
                            break;
                        }
                        break;
                    case "RESOURCE_KIND_UNKNOWN":
                    case 0:
                        message.resourceKind = 0;
                        break;
                    case "RESOURCE_KIND_SECTOR":
                    case 1:
                        message.resourceKind = 1;
                        break;
                    case "RESOURCE_KIND_ZONE":
                    case 2:
                        message.resourceKind = 2;
                        break;
                    case "RESOURCE_KIND_TEAM":
                    case 3:
                        message.resourceKind = 3;
                        break;
                    case "RESOURCE_KIND_BOAT":
                    case 4:
                        message.resourceKind = 4;
                        break;
                    case "RESOURCE_KIND_TRACK":
                    case 6:
                        message.resourceKind = 6;
                        break;
                    case "RESOURCE_KIND_PLAY_DEFINITION":
                    case 7:
                        message.resourceKind = 7;
                        break;
                    case "RESOURCE_KIND_PLAY_EXECUTION":
                    case 8:
                        message.resourceKind = 8;
                        break;
                    case "RESOURCE_KIND_PLAY_RUNNER":
                    case 9:
                        message.resourceKind = 9;
                        break;
                    case "RESOURCE_KIND_SIMULATION":
                    case 10:
                        message.resourceKind = 10;
                        break;
                    }
                    if (object.area) {
                        if (!Array.isArray(object.area))
                            throw TypeError(".havocai.messages.v0.SubscriptionCriteria.area: array expected");
                        message.area = [];
                        for (let i = 0; i < object.area.length; ++i) {
                            if (typeof object.area[i] !== "object")
                                throw TypeError(".havocai.messages.v0.SubscriptionCriteria.area: object expected");
                            message.area[i] = $root.havocai.messages.v0.GeoPoint.fromObject(object.area[i]);
                        }
                    }
                    if (object.names) {
                        if (!Array.isArray(object.names))
                            throw TypeError(".havocai.messages.v0.SubscriptionCriteria.names: array expected");
                        message.names = [];
                        for (let i = 0; i < object.names.length; ++i)
                            message.names[i] = String(object.names[i]);
                    }
                    if (object.sectors) {
                        if (!Array.isArray(object.sectors))
                            throw TypeError(".havocai.messages.v0.SubscriptionCriteria.sectors: array expected");
                        message.sectors = [];
                        for (let i = 0; i < object.sectors.length; ++i)
                            message.sectors[i] = String(object.sectors[i]);
                    }
                    if (object.plays) {
                        if (!Array.isArray(object.plays))
                            throw TypeError(".havocai.messages.v0.SubscriptionCriteria.plays: array expected");
                        message.plays = [];
                        for (let i = 0; i < object.plays.length; ++i)
                            switch (object.plays[i]) {
                            default:
                                if (typeof object.plays[i] === "number") {
                                    message.plays[i] = object.plays[i];
                                    break;
                                }
                            case "PLAY_KEY_UNKNOWN":
                            case 0:
                                message.plays[i] = 0;
                                break;
                            case "PLAY_KEY_NONE":
                            case 1:
                                message.plays[i] = 1;
                                break;
                            case "PLAY_KEY_DIRECT":
                            case 2:
                                message.plays[i] = 2;
                                break;
                            case "PLAY_KEY_CONTESTED_LOGISTICS":
                            case 3:
                                message.plays[i] = 3;
                                break;
                            case "PLAY_KEY_PAYLOAD_ORCHESTRATION":
                            case 4:
                                message.plays[i] = 4;
                                break;
                            case "PLAY_KEY_FIND_FIX_INVESTIGATE":
                            case 5:
                                message.plays[i] = 5;
                                break;
                            case "PLAY_KEY_FIND_FIX_INVESTIGATE_EPISCI":
                            case 6:
                                message.plays[i] = 6;
                                break;
                            case "PLAY_KEY_CHECKOUT":
                            case 7:
                                message.plays[i] = 7;
                                break;
                            case "PLAY_KEY_BEACH_LAUNCH":
                            case 8:
                                message.plays[i] = 8;
                                break;
                            case "PLAY_KEY_AVAST":
                            case 9:
                                message.plays[i] = 9;
                                break;
                            case "PLAY_KEY_JAZZ":
                            case 10:
                                message.plays[i] = 10;
                                break;
                            case "PLAY_KEY_CHARIOT_RAMP_CONTROL":
                            case 11:
                                message.plays[i] = 11;
                                break;
                            case "PLAY_KEY_CHARIOT_RESUPPLY":
                            case 12:
                                message.plays[i] = 12;
                                break;
                            case "PLAY_KEY_ENGAGE_TRACK":
                            case 13:
                                message.plays[i] = 13;
                                break;
                            case "PLAY_KEY_DYNAMIC":
                            case 14:
                                message.plays[i] = 14;
                                break;
                            }
                    }
                    if (object.teams) {
                        if (!Array.isArray(object.teams))
                            throw TypeError(".havocai.messages.v0.SubscriptionCriteria.teams: array expected");
                        message.teams = [];
                        for (let i = 0; i < object.teams.length; ++i)
                            message.teams[i] = String(object.teams[i]);
                    }
                    if (object.tasks) {
                        if (!Array.isArray(object.tasks))
                            throw TypeError(".havocai.messages.v0.SubscriptionCriteria.tasks: array expected");
                        message.tasks = [];
                        for (let i = 0; i < object.tasks.length; ++i)
                            switch (object.tasks[i]) {
                            default:
                                if (typeof object.tasks[i] === "number") {
                                    message.tasks[i] = object.tasks[i];
                                    break;
                                }
                            case "TASK_KEY_UNKNOWN":
                            case 0:
                                message.tasks[i] = 0;
                                break;
                            case "TASK_KEY_NONE":
                            case 1:
                                message.tasks[i] = 1;
                                break;
                            case "TASK_KEY_DIRECT_MOVE_GOAL":
                            case 2:
                                message.tasks[i] = 2;
                                break;
                            case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_STAGING":
                            case 3:
                                message.tasks[i] = 3;
                                break;
                            case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_STAGING":
                            case 4:
                                message.tasks[i] = 4;
                                break;
                            case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_LANDING":
                            case 5:
                                message.tasks[i] = 5;
                                break;
                            case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_LANDING":
                            case 6:
                                message.tasks[i] = 6;
                                break;
                            case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP_EGRESS":
                            case 7:
                                message.tasks[i] = 7;
                                break;
                            case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_PICKUP_EGRESS":
                            case 8:
                                message.tasks[i] = 8;
                                break;
                            case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_STAGING":
                            case 9:
                                message.tasks[i] = 9;
                                break;
                            case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_STAGING":
                            case 10:
                                message.tasks[i] = 10;
                                break;
                            case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_LANDING":
                            case 11:
                                message.tasks[i] = 11;
                                break;
                            case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_LANDING":
                            case 12:
                                message.tasks[i] = 12;
                                break;
                            case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_DROPOFF_EGRESS":
                            case 13:
                                message.tasks[i] = 13;
                                break;
                            case "TASK_KEY_CONTESTED_LOGISTICS_WAIT_DROPOFF_EGRESS":
                            case 14:
                                message.tasks[i] = 14;
                                break;
                            case "TASK_KEY_CONTESTED_LOGISTICS_MOVE_PICKUP":
                            case 15:
                                message.tasks[i] = 15;
                                break;
                            case "TASK_KEY_PAYLOAD_ORCHESTRATION_MOVE_TRACK":
                            case 16:
                                message.tasks[i] = 16;
                                break;
                            case "TASK_KEY_FIND_FIX_INVESTIGATE_FIND_TRACK":
                            case 17:
                                message.tasks[i] = 17;
                                break;
                            case "TASK_KEY_FIND_FIX_INVESTIGATE_INVESTIGATE_TRACK":
                            case 18:
                                message.tasks[i] = 18;
                                break;
                            case "TASK_KEY_CHECKOUT_WAIT":
                            case 19:
                                message.tasks[i] = 19;
                                break;
                            case "TASK_KEY_CHECKOUT_TEST_DRIVE":
                            case 20:
                                message.tasks[i] = 20;
                                break;
                            case "TASK_KEY_BEACH_LAUNCH_WAIT":
                            case 21:
                                message.tasks[i] = 21;
                                break;
                            case "TASK_KEY_BEACH_LAUNCH_DEPLOY":
                            case 22:
                                message.tasks[i] = 22;
                                break;
                            case "TASK_KEY_BEACH_LAUNCH_MOVE_EGRESS":
                            case 23:
                                message.tasks[i] = 23;
                                break;
                            case "TASK_KEY_AVAST_WAIT":
                            case 24:
                                message.tasks[i] = 24;
                                break;
                            case "TASK_KEY_JAZZ_ACTIVE":
                            case 25:
                                message.tasks[i] = 25;
                                break;
                            case "TASK_KEY_CHARIOT_RAMP_CONTROL_ACTIVE":
                            case 26:
                                message.tasks[i] = 26;
                                break;
                            case "TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_STAGING":
                            case 27:
                                message.tasks[i] = 27;
                                break;
                            case "TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_SHORE":
                            case 28:
                                message.tasks[i] = 28;
                                break;
                            case "TASK_KEY_CHARIOT_RESUPPLY_LANDING_CONFIRMATION":
                            case 29:
                                message.tasks[i] = 29;
                                break;
                            case "TASK_KEY_CHARIOT_RESUPPLY_DEPART_CONFIRMATION":
                            case 30:
                                message.tasks[i] = 30;
                                break;
                            case "TASK_KEY_CHARIOT_RESUPPLY_MOVE_OFF_SHORE":
                            case 31:
                                message.tasks[i] = 31;
                                break;
                            case "TASK_KEY_CHARIOT_RESUPPLY_MOVE_TO_EGRESS":
                            case 32:
                                message.tasks[i] = 32;
                                break;
                            case "TASK_KEY_ENGAGE_TRACK":
                            case 33:
                                message.tasks[i] = 33;
                                break;
                            }
                    }
                    if (object.zoneTypes) {
                        if (!Array.isArray(object.zoneTypes))
                            throw TypeError(".havocai.messages.v0.SubscriptionCriteria.zoneTypes: array expected");
                        message.zoneTypes = [];
                        for (let i = 0; i < object.zoneTypes.length; ++i)
                            switch (object.zoneTypes[i]) {
                            default:
                                if (typeof object.zoneTypes[i] === "number") {
                                    message.zoneTypes[i] = object.zoneTypes[i];
                                    break;
                                }
                            case "ZONE_TYPE_UNKNOWN":
                            case 0:
                                message.zoneTypes[i] = 0;
                                break;
                            case "ZONE_TYPE_BEACH":
                            case 1:
                                message.zoneTypes[i] = 1;
                                break;
                            case "ZONE_TYPE_OVERLAY":
                            case 2:
                                message.zoneTypes[i] = 2;
                                break;
                            case "ZONE_TYPE_ENGAGEMENT":
                            case 3:
                                message.zoneTypes[i] = 3;
                                break;
                            case "ZONE_TYPE_ROUTE":
                            case 4:
                                message.zoneTypes[i] = 4;
                                break;
                            }
                    }
                    if (object.waypointTypes) {
                        if (!Array.isArray(object.waypointTypes))
                            throw TypeError(".havocai.messages.v0.SubscriptionCriteria.waypointTypes: array expected");
                        message.waypointTypes = [];
                        for (let i = 0; i < object.waypointTypes.length; ++i)
                            switch (object.waypointTypes[i]) {
                            default:
                                if (typeof object.waypointTypes[i] === "number") {
                                    message.waypointTypes[i] = object.waypointTypes[i];
                                    break;
                                }
                            case "WAYPOINT_TYPE_UNKNOWN":
                            case 0:
                                message.waypointTypes[i] = 0;
                                break;
                            case "WAYPOINT_TYPE_LANDING":
                            case 1:
                                message.waypointTypes[i] = 1;
                                break;
                            case "WAYPOINT_TYPE_EGRESS":
                            case 2:
                                message.waypointTypes[i] = 2;
                                break;
                            case "WAYPOINT_TYPE_STAGING":
                            case 3:
                                message.waypointTypes[i] = 3;
                                break;
                            }
                    }
                    if (object.trackTypes) {
                        if (!Array.isArray(object.trackTypes))
                            throw TypeError(".havocai.messages.v0.SubscriptionCriteria.trackTypes: array expected");
                        message.trackTypes = [];
                        for (let i = 0; i < object.trackTypes.length; ++i)
                            switch (object.trackTypes[i]) {
                            default:
                                if (typeof object.trackTypes[i] === "number") {
                                    message.trackTypes[i] = object.trackTypes[i];
                                    break;
                                }
                            case "TRACK_TYPE_UNKNOWN":
                            case 0:
                                message.trackTypes[i] = 0;
                                break;
                            case "TRACK_TYPE_AIS":
                            case 1:
                                message.trackTypes[i] = 1;
                                break;
                            case "TRACK_TYPE_RADAR":
                            case 2:
                                message.trackTypes[i] = 2;
                                break;
                            case "TRACK_TYPE_EO":
                            case 3:
                                message.trackTypes[i] = 3;
                                break;
                            case "TRACK_TYPE_FUSED":
                            case 4:
                                message.trackTypes[i] = 4;
                                break;
                            case "TRACK_TYPE_USER_CREATED":
                            case 5:
                                message.trackTypes[i] = 5;
                                break;
                            case "TRACK_TYPE_EXTERNAL_SYSTEM":
                            case 6:
                                message.trackTypes[i] = 6;
                                break;
                            case "TRACK_TYPE_RF":
                            case 7:
                                message.trackTypes[i] = 7;
                                break;
                            case "TRACK_TYPE_PERSON":
                            case 8:
                                message.trackTypes[i] = 8;
                                break;
                            case "TRACK_TYPE_MISSILE":
                            case 9:
                                message.trackTypes[i] = 9;
                                break;
                            case "TRACK_TYPE_TORPEDO":
                            case 10:
                                message.trackTypes[i] = 10;
                                break;
                            case "TRACK_TYPE_RUBBER_DUCKIE":
                            case 98:
                                message.trackTypes[i] = 98;
                                break;
                            case "TRACK_TYPE_NERF_DART":
                            case 99:
                                message.trackTypes[i] = 99;
                                break;
                            }
                    }
                    if (object.affiliations) {
                        if (!Array.isArray(object.affiliations))
                            throw TypeError(".havocai.messages.v0.SubscriptionCriteria.affiliations: array expected");
                        message.affiliations = [];
                        for (let i = 0; i < object.affiliations.length; ++i)
                            switch (object.affiliations[i]) {
                            default:
                                if (typeof object.affiliations[i] === "number") {
                                    message.affiliations[i] = object.affiliations[i];
                                    break;
                                }
                            case "AFFILIATION_UNKNOWN":
                            case 0:
                                message.affiliations[i] = 0;
                                break;
                            case "AFFILIATION_ASSUMED_FRIENDLY":
                            case 1:
                                message.affiliations[i] = 1;
                                break;
                            case "AFFILIATION_FRIENDLY":
                            case 2:
                                message.affiliations[i] = 2;
                                break;
                            case "AFFILIATION_NEUTRAL":
                            case 3:
                                message.affiliations[i] = 3;
                                break;
                            case "AFFILIATION_SUSPECT":
                            case 4:
                                message.affiliations[i] = 4;
                                break;
                            case "AFFILIATION_HOSTILE":
                            case 5:
                                message.affiliations[i] = 5;
                                break;
                            }
                    }
                    if (object.tags) {
                        if (!Array.isArray(object.tags))
                            throw TypeError(".havocai.messages.v0.SubscriptionCriteria.tags: array expected");
                        message.tags = [];
                        for (let i = 0; i < object.tags.length; ++i)
                            message.tags[i] = String(object.tags[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SubscriptionCriteria message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @static
                 * @param {havocai.messages.v0.SubscriptionCriteria} message SubscriptionCriteria
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SubscriptionCriteria.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.area = [];
                        object.names = [];
                        object.sectors = [];
                        object.plays = [];
                        object.teams = [];
                        object.tasks = [];
                        object.zoneTypes = [];
                        object.waypointTypes = [];
                        object.trackTypes = [];
                        object.affiliations = [];
                        object.tags = [];
                    }
                    if (options.defaults)
                        object.resourceKind = options.enums === String ? "RESOURCE_KIND_UNKNOWN" : 0;
                    if (message.resourceKind != null && message.hasOwnProperty("resourceKind"))
                        object.resourceKind = options.enums === String ? $root.havocai.messages.v0.ResourceKind[message.resourceKind] === undefined ? message.resourceKind : $root.havocai.messages.v0.ResourceKind[message.resourceKind] : message.resourceKind;
                    if (message.area && message.area.length) {
                        object.area = [];
                        for (let j = 0; j < message.area.length; ++j)
                            object.area[j] = $root.havocai.messages.v0.GeoPoint.toObject(message.area[j], options);
                    }
                    if (message.names && message.names.length) {
                        object.names = [];
                        for (let j = 0; j < message.names.length; ++j)
                            object.names[j] = message.names[j];
                    }
                    if (message.sectors && message.sectors.length) {
                        object.sectors = [];
                        for (let j = 0; j < message.sectors.length; ++j)
                            object.sectors[j] = message.sectors[j];
                    }
                    if (message.plays && message.plays.length) {
                        object.plays = [];
                        for (let j = 0; j < message.plays.length; ++j)
                            object.plays[j] = options.enums === String ? $root.havocai.messages.v0.PlayKey[message.plays[j]] === undefined ? message.plays[j] : $root.havocai.messages.v0.PlayKey[message.plays[j]] : message.plays[j];
                    }
                    if (message.teams && message.teams.length) {
                        object.teams = [];
                        for (let j = 0; j < message.teams.length; ++j)
                            object.teams[j] = message.teams[j];
                    }
                    if (message.tasks && message.tasks.length) {
                        object.tasks = [];
                        for (let j = 0; j < message.tasks.length; ++j)
                            object.tasks[j] = options.enums === String ? $root.havocai.messages.v0.TaskKey[message.tasks[j]] === undefined ? message.tasks[j] : $root.havocai.messages.v0.TaskKey[message.tasks[j]] : message.tasks[j];
                    }
                    if (message.zoneTypes && message.zoneTypes.length) {
                        object.zoneTypes = [];
                        for (let j = 0; j < message.zoneTypes.length; ++j)
                            object.zoneTypes[j] = options.enums === String ? $root.havocai.messages.v0.ZoneType[message.zoneTypes[j]] === undefined ? message.zoneTypes[j] : $root.havocai.messages.v0.ZoneType[message.zoneTypes[j]] : message.zoneTypes[j];
                    }
                    if (message.waypointTypes && message.waypointTypes.length) {
                        object.waypointTypes = [];
                        for (let j = 0; j < message.waypointTypes.length; ++j)
                            object.waypointTypes[j] = options.enums === String ? $root.havocai.messages.v0.WaypointType[message.waypointTypes[j]] === undefined ? message.waypointTypes[j] : $root.havocai.messages.v0.WaypointType[message.waypointTypes[j]] : message.waypointTypes[j];
                    }
                    if (message.trackTypes && message.trackTypes.length) {
                        object.trackTypes = [];
                        for (let j = 0; j < message.trackTypes.length; ++j)
                            object.trackTypes[j] = options.enums === String ? $root.havocai.messages.v0.TrackType[message.trackTypes[j]] === undefined ? message.trackTypes[j] : $root.havocai.messages.v0.TrackType[message.trackTypes[j]] : message.trackTypes[j];
                    }
                    if (message.affiliations && message.affiliations.length) {
                        object.affiliations = [];
                        for (let j = 0; j < message.affiliations.length; ++j)
                            object.affiliations[j] = options.enums === String ? $root.havocai.messages.v0.Affiliation[message.affiliations[j]] === undefined ? message.affiliations[j] : $root.havocai.messages.v0.Affiliation[message.affiliations[j]] : message.affiliations[j];
                    }
                    if (message.tags && message.tags.length) {
                        object.tags = [];
                        for (let j = 0; j < message.tags.length; ++j)
                            object.tags[j] = message.tags[j];
                    }
                    return object;
                };

                /**
                 * Converts this SubscriptionCriteria to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SubscriptionCriteria.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SubscriptionCriteria
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.SubscriptionCriteria
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SubscriptionCriteria.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.SubscriptionCriteria";
                };

                return SubscriptionCriteria;
            })();

            v0.CooperativeOffset = (function() {

                /**
                 * Properties of a CooperativeOffset.
                 * @memberof havocai.messages.v0
                 * @interface ICooperativeOffset
                 * @property {havocai.messages.v0.CooperativeConfig|null} [config] CooperativeOffset config
                 * @property {number|null} [distance_0] CooperativeOffset distance_0
                 * @property {number|null} [distance_1] CooperativeOffset distance_1
                 * @property {number|null} [distance_2] CooperativeOffset distance_2
                 * @property {number|null} [angleA] CooperativeOffset angleA
                 * @property {number|null} [angleB] CooperativeOffset angleB
                 * @property {havocai.messages.v0.IGeoPoint|null} [location_0] CooperativeOffset location_0
                 * @property {havocai.messages.v0.IGeoPoint|null} [location_1] CooperativeOffset location_1
                 */

                /**
                 * Constructs a new CooperativeOffset.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a CooperativeOffset.
                 * @implements ICooperativeOffset
                 * @constructor
                 * @param {havocai.messages.v0.ICooperativeOffset=} [properties] Properties to set
                 */
                function CooperativeOffset(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CooperativeOffset config.
                 * @member {havocai.messages.v0.CooperativeConfig} config
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @instance
                 */
                CooperativeOffset.prototype.config = 0;

                /**
                 * CooperativeOffset distance_0.
                 * @member {number} distance_0
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @instance
                 */
                CooperativeOffset.prototype.distance_0 = 0;

                /**
                 * CooperativeOffset distance_1.
                 * @member {number} distance_1
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @instance
                 */
                CooperativeOffset.prototype.distance_1 = 0;

                /**
                 * CooperativeOffset distance_2.
                 * @member {number} distance_2
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @instance
                 */
                CooperativeOffset.prototype.distance_2 = 0;

                /**
                 * CooperativeOffset angleA.
                 * @member {number} angleA
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @instance
                 */
                CooperativeOffset.prototype.angleA = 0;

                /**
                 * CooperativeOffset angleB.
                 * @member {number} angleB
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @instance
                 */
                CooperativeOffset.prototype.angleB = 0;

                /**
                 * CooperativeOffset location_0.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} location_0
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @instance
                 */
                CooperativeOffset.prototype.location_0 = null;

                /**
                 * CooperativeOffset location_1.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} location_1
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @instance
                 */
                CooperativeOffset.prototype.location_1 = null;

                /**
                 * Creates a new CooperativeOffset instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @static
                 * @param {havocai.messages.v0.ICooperativeOffset=} [properties] Properties to set
                 * @returns {havocai.messages.v0.CooperativeOffset} CooperativeOffset instance
                 */
                CooperativeOffset.create = function create(properties) {
                    return new CooperativeOffset(properties);
                };

                /**
                 * Encodes the specified CooperativeOffset message. Does not implicitly {@link havocai.messages.v0.CooperativeOffset.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @static
                 * @param {havocai.messages.v0.ICooperativeOffset} message CooperativeOffset message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CooperativeOffset.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.config != null && Object.hasOwnProperty.call(message, "config"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.config);
                    if (message.distance_0 != null && Object.hasOwnProperty.call(message, "distance_0"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.distance_0);
                    if (message.distance_1 != null && Object.hasOwnProperty.call(message, "distance_1"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.distance_1);
                    if (message.angleA != null && Object.hasOwnProperty.call(message, "angleA"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.angleA);
                    if (message.angleB != null && Object.hasOwnProperty.call(message, "angleB"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.angleB);
                    if (message.location_0 != null && Object.hasOwnProperty.call(message, "location_0"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.location_0, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.location_1 != null && Object.hasOwnProperty.call(message, "location_1"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.location_1, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.distance_2 != null && Object.hasOwnProperty.call(message, "distance_2"))
                        writer.uint32(/* id 8, wireType 5 =*/69).float(message.distance_2);
                    return writer;
                };

                /**
                 * Encodes the specified CooperativeOffset message, length delimited. Does not implicitly {@link havocai.messages.v0.CooperativeOffset.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @static
                 * @param {havocai.messages.v0.ICooperativeOffset} message CooperativeOffset message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CooperativeOffset.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CooperativeOffset message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.CooperativeOffset} CooperativeOffset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CooperativeOffset.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.CooperativeOffset();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.config = reader.int32();
                                break;
                            }
                        case 2: {
                                message.distance_0 = reader.float();
                                break;
                            }
                        case 3: {
                                message.distance_1 = reader.float();
                                break;
                            }
                        case 8: {
                                message.distance_2 = reader.float();
                                break;
                            }
                        case 4: {
                                message.angleA = reader.float();
                                break;
                            }
                        case 5: {
                                message.angleB = reader.float();
                                break;
                            }
                        case 6: {
                                message.location_0 = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        case 7: {
                                message.location_1 = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CooperativeOffset message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.CooperativeOffset} CooperativeOffset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CooperativeOffset.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CooperativeOffset message.
                 * @function verify
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CooperativeOffset.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.config != null && message.hasOwnProperty("config"))
                        switch (message.config) {
                        default:
                            return "config: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.distance_0 != null && message.hasOwnProperty("distance_0"))
                        if (typeof message.distance_0 !== "number")
                            return "distance_0: number expected";
                    if (message.distance_1 != null && message.hasOwnProperty("distance_1"))
                        if (typeof message.distance_1 !== "number")
                            return "distance_1: number expected";
                    if (message.distance_2 != null && message.hasOwnProperty("distance_2"))
                        if (typeof message.distance_2 !== "number")
                            return "distance_2: number expected";
                    if (message.angleA != null && message.hasOwnProperty("angleA"))
                        if (typeof message.angleA !== "number")
                            return "angleA: number expected";
                    if (message.angleB != null && message.hasOwnProperty("angleB"))
                        if (typeof message.angleB !== "number")
                            return "angleB: number expected";
                    if (message.location_0 != null && message.hasOwnProperty("location_0")) {
                        let error = $root.havocai.messages.v0.GeoPoint.verify(message.location_0);
                        if (error)
                            return "location_0." + error;
                    }
                    if (message.location_1 != null && message.hasOwnProperty("location_1")) {
                        let error = $root.havocai.messages.v0.GeoPoint.verify(message.location_1);
                        if (error)
                            return "location_1." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CooperativeOffset message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.CooperativeOffset} CooperativeOffset
                 */
                CooperativeOffset.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.CooperativeOffset)
                        return object;
                    let message = new $root.havocai.messages.v0.CooperativeOffset();
                    switch (object.config) {
                    default:
                        if (typeof object.config === "number") {
                            message.config = object.config;
                            break;
                        }
                        break;
                    case "COOPERATIVE_CONFIG_UNKNOWN":
                    case 0:
                        message.config = 0;
                        break;
                    case "COOPERATIVE_CONFIG_CIRCLE":
                    case 1:
                        message.config = 1;
                        break;
                    case "COOPERATIVE_CONFIG_LINE":
                    case 2:
                        message.config = 2;
                        break;
                    case "COOPERATIVE_CONFIG_BLOCKADE":
                    case 3:
                        message.config = 3;
                        break;
                    case "COOPERATIVE_CONFIG_ELLIPSE":
                    case 4:
                        message.config = 4;
                        break;
                    }
                    if (object.distance_0 != null)
                        message.distance_0 = Number(object.distance_0);
                    if (object.distance_1 != null)
                        message.distance_1 = Number(object.distance_1);
                    if (object.distance_2 != null)
                        message.distance_2 = Number(object.distance_2);
                    if (object.angleA != null)
                        message.angleA = Number(object.angleA);
                    if (object.angleB != null)
                        message.angleB = Number(object.angleB);
                    if (object.location_0 != null) {
                        if (typeof object.location_0 !== "object")
                            throw TypeError(".havocai.messages.v0.CooperativeOffset.location_0: object expected");
                        message.location_0 = $root.havocai.messages.v0.GeoPoint.fromObject(object.location_0);
                    }
                    if (object.location_1 != null) {
                        if (typeof object.location_1 !== "object")
                            throw TypeError(".havocai.messages.v0.CooperativeOffset.location_1: object expected");
                        message.location_1 = $root.havocai.messages.v0.GeoPoint.fromObject(object.location_1);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CooperativeOffset message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @static
                 * @param {havocai.messages.v0.CooperativeOffset} message CooperativeOffset
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CooperativeOffset.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.config = options.enums === String ? "COOPERATIVE_CONFIG_UNKNOWN" : 0;
                        object.distance_0 = 0;
                        object.distance_1 = 0;
                        object.angleA = 0;
                        object.angleB = 0;
                        object.location_0 = null;
                        object.location_1 = null;
                        object.distance_2 = 0;
                    }
                    if (message.config != null && message.hasOwnProperty("config"))
                        object.config = options.enums === String ? $root.havocai.messages.v0.CooperativeConfig[message.config] === undefined ? message.config : $root.havocai.messages.v0.CooperativeConfig[message.config] : message.config;
                    if (message.distance_0 != null && message.hasOwnProperty("distance_0"))
                        object.distance_0 = options.json && !isFinite(message.distance_0) ? String(message.distance_0) : message.distance_0;
                    if (message.distance_1 != null && message.hasOwnProperty("distance_1"))
                        object.distance_1 = options.json && !isFinite(message.distance_1) ? String(message.distance_1) : message.distance_1;
                    if (message.angleA != null && message.hasOwnProperty("angleA"))
                        object.angleA = options.json && !isFinite(message.angleA) ? String(message.angleA) : message.angleA;
                    if (message.angleB != null && message.hasOwnProperty("angleB"))
                        object.angleB = options.json && !isFinite(message.angleB) ? String(message.angleB) : message.angleB;
                    if (message.location_0 != null && message.hasOwnProperty("location_0"))
                        object.location_0 = $root.havocai.messages.v0.GeoPoint.toObject(message.location_0, options);
                    if (message.location_1 != null && message.hasOwnProperty("location_1"))
                        object.location_1 = $root.havocai.messages.v0.GeoPoint.toObject(message.location_1, options);
                    if (message.distance_2 != null && message.hasOwnProperty("distance_2"))
                        object.distance_2 = options.json && !isFinite(message.distance_2) ? String(message.distance_2) : message.distance_2;
                    return object;
                };

                /**
                 * Converts this CooperativeOffset to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CooperativeOffset.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for CooperativeOffset
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.CooperativeOffset
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                CooperativeOffset.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.CooperativeOffset";
                };

                return CooperativeOffset;
            })();

            v0.Waypoint = (function() {

                /**
                 * Properties of a Waypoint.
                 * @memberof havocai.messages.v0
                 * @interface IWaypoint
                 * @property {string|null} [name] Waypoint name
                 * @property {havocai.messages.v0.WaypointType|null} [type] Waypoint type
                 * @property {havocai.messages.v0.IGeoPoint|null} [location] Waypoint location
                 */

                /**
                 * Constructs a new Waypoint.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Waypoint.
                 * @implements IWaypoint
                 * @constructor
                 * @param {havocai.messages.v0.IWaypoint=} [properties] Properties to set
                 */
                function Waypoint(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Waypoint name.
                 * @member {string} name
                 * @memberof havocai.messages.v0.Waypoint
                 * @instance
                 */
                Waypoint.prototype.name = "";

                /**
                 * Waypoint type.
                 * @member {havocai.messages.v0.WaypointType} type
                 * @memberof havocai.messages.v0.Waypoint
                 * @instance
                 */
                Waypoint.prototype.type = 0;

                /**
                 * Waypoint location.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} location
                 * @memberof havocai.messages.v0.Waypoint
                 * @instance
                 */
                Waypoint.prototype.location = null;

                /**
                 * Creates a new Waypoint instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Waypoint
                 * @static
                 * @param {havocai.messages.v0.IWaypoint=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Waypoint} Waypoint instance
                 */
                Waypoint.create = function create(properties) {
                    return new Waypoint(properties);
                };

                /**
                 * Encodes the specified Waypoint message. Does not implicitly {@link havocai.messages.v0.Waypoint.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Waypoint
                 * @static
                 * @param {havocai.messages.v0.IWaypoint} message Waypoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Waypoint.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.location, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Waypoint message, length delimited. Does not implicitly {@link havocai.messages.v0.Waypoint.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Waypoint
                 * @static
                 * @param {havocai.messages.v0.IWaypoint} message Waypoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Waypoint.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Waypoint message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Waypoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Waypoint} Waypoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Waypoint.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Waypoint();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.type = reader.int32();
                                break;
                            }
                        case 4: {
                                message.location = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Waypoint message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Waypoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Waypoint} Waypoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Waypoint.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Waypoint message.
                 * @function verify
                 * @memberof havocai.messages.v0.Waypoint
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Waypoint.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.location != null && message.hasOwnProperty("location")) {
                        let error = $root.havocai.messages.v0.GeoPoint.verify(message.location);
                        if (error)
                            return "location." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Waypoint message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Waypoint
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Waypoint} Waypoint
                 */
                Waypoint.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Waypoint)
                        return object;
                    let message = new $root.havocai.messages.v0.Waypoint();
                    if (object.name != null)
                        message.name = String(object.name);
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "WAYPOINT_TYPE_UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "WAYPOINT_TYPE_LANDING":
                    case 1:
                        message.type = 1;
                        break;
                    case "WAYPOINT_TYPE_EGRESS":
                    case 2:
                        message.type = 2;
                        break;
                    case "WAYPOINT_TYPE_STAGING":
                    case 3:
                        message.type = 3;
                        break;
                    }
                    if (object.location != null) {
                        if (typeof object.location !== "object")
                            throw TypeError(".havocai.messages.v0.Waypoint.location: object expected");
                        message.location = $root.havocai.messages.v0.GeoPoint.fromObject(object.location);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Waypoint message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Waypoint
                 * @static
                 * @param {havocai.messages.v0.Waypoint} message Waypoint
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Waypoint.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.type = options.enums === String ? "WAYPOINT_TYPE_UNKNOWN" : 0;
                        object.location = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.havocai.messages.v0.WaypointType[message.type] === undefined ? message.type : $root.havocai.messages.v0.WaypointType[message.type] : message.type;
                    if (message.location != null && message.hasOwnProperty("location"))
                        object.location = $root.havocai.messages.v0.GeoPoint.toObject(message.location, options);
                    return object;
                };

                /**
                 * Converts this Waypoint to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Waypoint
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Waypoint.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Waypoint
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Waypoint
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Waypoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Waypoint";
                };

                return Waypoint;
            })();

            v0.Marker = (function() {

                /**
                 * Properties of a Marker.
                 * @memberof havocai.messages.v0
                 * @interface IMarker
                 * @property {string|null} [name] Marker name
                 * @property {havocai.messages.v0.MarkerType|null} [type] Marker type
                 * @property {string|null} [variant] Marker variant
                 * @property {havocai.messages.v0.IGeoPoint|null} [location] Marker location
                 * @property {string|null} [description] Marker description
                 * @property {string|null} [icon] Marker icon
                 * @property {string|null} [id] Marker id
                 * @property {havocai.messages.v0.DataSource|null} [dataSource] Marker dataSource
                 */

                /**
                 * Constructs a new Marker.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Marker.
                 * @implements IMarker
                 * @constructor
                 * @param {havocai.messages.v0.IMarker=} [properties] Properties to set
                 */
                function Marker(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Marker name.
                 * @member {string} name
                 * @memberof havocai.messages.v0.Marker
                 * @instance
                 */
                Marker.prototype.name = "";

                /**
                 * Marker type.
                 * @member {havocai.messages.v0.MarkerType} type
                 * @memberof havocai.messages.v0.Marker
                 * @instance
                 */
                Marker.prototype.type = 0;

                /**
                 * Marker variant.
                 * @member {string} variant
                 * @memberof havocai.messages.v0.Marker
                 * @instance
                 */
                Marker.prototype.variant = "";

                /**
                 * Marker location.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} location
                 * @memberof havocai.messages.v0.Marker
                 * @instance
                 */
                Marker.prototype.location = null;

                /**
                 * Marker description.
                 * @member {string} description
                 * @memberof havocai.messages.v0.Marker
                 * @instance
                 */
                Marker.prototype.description = "";

                /**
                 * Marker icon.
                 * @member {string} icon
                 * @memberof havocai.messages.v0.Marker
                 * @instance
                 */
                Marker.prototype.icon = "";

                /**
                 * Marker id.
                 * @member {string} id
                 * @memberof havocai.messages.v0.Marker
                 * @instance
                 */
                Marker.prototype.id = "";

                /**
                 * Marker dataSource.
                 * @member {havocai.messages.v0.DataSource} dataSource
                 * @memberof havocai.messages.v0.Marker
                 * @instance
                 */
                Marker.prototype.dataSource = 0;

                /**
                 * Creates a new Marker instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Marker
                 * @static
                 * @param {havocai.messages.v0.IMarker=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Marker} Marker instance
                 */
                Marker.create = function create(properties) {
                    return new Marker(properties);
                };

                /**
                 * Encodes the specified Marker message. Does not implicitly {@link havocai.messages.v0.Marker.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Marker
                 * @static
                 * @param {havocai.messages.v0.IMarker} message Marker message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Marker.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.variant != null && Object.hasOwnProperty.call(message, "variant"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.variant);
                    if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.location, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                    if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.icon);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.id);
                    if (message.dataSource != null && Object.hasOwnProperty.call(message, "dataSource"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.dataSource);
                    return writer;
                };

                /**
                 * Encodes the specified Marker message, length delimited. Does not implicitly {@link havocai.messages.v0.Marker.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Marker
                 * @static
                 * @param {havocai.messages.v0.IMarker} message Marker message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Marker.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Marker message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Marker
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Marker} Marker
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Marker.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Marker();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.type = reader.int32();
                                break;
                            }
                        case 3: {
                                message.variant = reader.string();
                                break;
                            }
                        case 4: {
                                message.location = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.description = reader.string();
                                break;
                            }
                        case 6: {
                                message.icon = reader.string();
                                break;
                            }
                        case 7: {
                                message.id = reader.string();
                                break;
                            }
                        case 8: {
                                message.dataSource = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Marker message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Marker
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Marker} Marker
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Marker.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Marker message.
                 * @function verify
                 * @memberof havocai.messages.v0.Marker
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Marker.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.variant != null && message.hasOwnProperty("variant"))
                        if (!$util.isString(message.variant))
                            return "variant: string expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        let error = $root.havocai.messages.v0.GeoPoint.verify(message.location);
                        if (error)
                            return "location." + error;
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.icon != null && message.hasOwnProperty("icon"))
                        if (!$util.isString(message.icon))
                            return "icon: string expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.dataSource != null && message.hasOwnProperty("dataSource"))
                        switch (message.dataSource) {
                        default:
                            return "dataSource: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a Marker message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Marker
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Marker} Marker
                 */
                Marker.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Marker)
                        return object;
                    let message = new $root.havocai.messages.v0.Marker();
                    if (object.name != null)
                        message.name = String(object.name);
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "MARKER_TYPE_UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "MARKER_TYPE_LANDING":
                    case 1:
                        message.type = 1;
                        break;
                    case "MARKER_TYPE_EGRESS":
                    case 2:
                        message.type = 2;
                        break;
                    case "MARKER_TYPE_STAGING":
                    case 3:
                        message.type = 3;
                        break;
                    case "MARKER_TYPE_LANDMARK":
                    case 4:
                        message.type = 4;
                        break;
                    case "MARKER_TYPE_HAZARD":
                    case 5:
                        message.type = 5;
                        break;
                    }
                    if (object.variant != null)
                        message.variant = String(object.variant);
                    if (object.location != null) {
                        if (typeof object.location !== "object")
                            throw TypeError(".havocai.messages.v0.Marker.location: object expected");
                        message.location = $root.havocai.messages.v0.GeoPoint.fromObject(object.location);
                    }
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.icon != null)
                        message.icon = String(object.icon);
                    if (object.id != null)
                        message.id = String(object.id);
                    switch (object.dataSource) {
                    default:
                        if (typeof object.dataSource === "number") {
                            message.dataSource = object.dataSource;
                            break;
                        }
                        break;
                    case "DATA_SOURCE_UNKNOWN":
                    case 0:
                        message.dataSource = 0;
                        break;
                    case "DATA_SOURCE_API":
                    case 1:
                        message.dataSource = 1;
                        break;
                    case "DATA_SOURCE_TAK":
                    case 2:
                        message.dataSource = 2;
                        break;
                    case "DATA_SOURCE_LATTICE":
                    case 3:
                        message.dataSource = 3;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Marker message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Marker
                 * @static
                 * @param {havocai.messages.v0.Marker} message Marker
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Marker.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.type = options.enums === String ? "MARKER_TYPE_UNKNOWN" : 0;
                        object.variant = "";
                        object.location = null;
                        object.description = "";
                        object.icon = "";
                        object.id = "";
                        object.dataSource = options.enums === String ? "DATA_SOURCE_UNKNOWN" : 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.havocai.messages.v0.MarkerType[message.type] === undefined ? message.type : $root.havocai.messages.v0.MarkerType[message.type] : message.type;
                    if (message.variant != null && message.hasOwnProperty("variant"))
                        object.variant = message.variant;
                    if (message.location != null && message.hasOwnProperty("location"))
                        object.location = $root.havocai.messages.v0.GeoPoint.toObject(message.location, options);
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.icon != null && message.hasOwnProperty("icon"))
                        object.icon = message.icon;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.dataSource != null && message.hasOwnProperty("dataSource"))
                        object.dataSource = options.enums === String ? $root.havocai.messages.v0.DataSource[message.dataSource] === undefined ? message.dataSource : $root.havocai.messages.v0.DataSource[message.dataSource] : message.dataSource;
                    return object;
                };

                /**
                 * Converts this Marker to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Marker
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Marker.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Marker
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Marker
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Marker.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Marker";
                };

                return Marker;
            })();

            v0.GeoFence = (function() {

                /**
                 * Properties of a GeoFence.
                 * @memberof havocai.messages.v0
                 * @interface IGeoFence
                 * @property {string|null} [name] GeoFence name
                 * @property {havocai.messages.v0.GeoFenceType|null} [type] GeoFence type
                 * @property {string|null} [id] GeoFence id
                 * @property {havocai.messages.v0.DataSource|null} [dataSource] GeoFence dataSource
                 * @property {Array.<havocai.messages.v0.IGeoPoint>|null} [area] GeoFence area
                 */

                /**
                 * Constructs a new GeoFence.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a GeoFence.
                 * @implements IGeoFence
                 * @constructor
                 * @param {havocai.messages.v0.IGeoFence=} [properties] Properties to set
                 */
                function GeoFence(properties) {
                    this.area = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GeoFence name.
                 * @member {string} name
                 * @memberof havocai.messages.v0.GeoFence
                 * @instance
                 */
                GeoFence.prototype.name = "";

                /**
                 * GeoFence type.
                 * @member {havocai.messages.v0.GeoFenceType} type
                 * @memberof havocai.messages.v0.GeoFence
                 * @instance
                 */
                GeoFence.prototype.type = 0;

                /**
                 * GeoFence id.
                 * @member {string} id
                 * @memberof havocai.messages.v0.GeoFence
                 * @instance
                 */
                GeoFence.prototype.id = "";

                /**
                 * GeoFence dataSource.
                 * @member {havocai.messages.v0.DataSource} dataSource
                 * @memberof havocai.messages.v0.GeoFence
                 * @instance
                 */
                GeoFence.prototype.dataSource = 0;

                /**
                 * GeoFence area.
                 * @member {Array.<havocai.messages.v0.IGeoPoint>} area
                 * @memberof havocai.messages.v0.GeoFence
                 * @instance
                 */
                GeoFence.prototype.area = $util.emptyArray;

                /**
                 * Creates a new GeoFence instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.GeoFence
                 * @static
                 * @param {havocai.messages.v0.IGeoFence=} [properties] Properties to set
                 * @returns {havocai.messages.v0.GeoFence} GeoFence instance
                 */
                GeoFence.create = function create(properties) {
                    return new GeoFence(properties);
                };

                /**
                 * Encodes the specified GeoFence message. Does not implicitly {@link havocai.messages.v0.GeoFence.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.GeoFence
                 * @static
                 * @param {havocai.messages.v0.IGeoFence} message GeoFence message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeoFence.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.id);
                    if (message.dataSource != null && Object.hasOwnProperty.call(message, "dataSource"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.dataSource);
                    if (message.area != null && message.area.length)
                        for (let i = 0; i < message.area.length; ++i)
                            $root.havocai.messages.v0.GeoPoint.encode(message.area[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified GeoFence message, length delimited. Does not implicitly {@link havocai.messages.v0.GeoFence.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.GeoFence
                 * @static
                 * @param {havocai.messages.v0.IGeoFence} message GeoFence message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeoFence.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GeoFence message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.GeoFence
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.GeoFence} GeoFence
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeoFence.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.GeoFence();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.type = reader.int32();
                                break;
                            }
                        case 3: {
                                message.id = reader.string();
                                break;
                            }
                        case 4: {
                                message.dataSource = reader.int32();
                                break;
                            }
                        case 15: {
                                if (!(message.area && message.area.length))
                                    message.area = [];
                                message.area.push($root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GeoFence message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.GeoFence
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.GeoFence} GeoFence
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeoFence.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GeoFence message.
                 * @function verify
                 * @memberof havocai.messages.v0.GeoFence
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeoFence.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.dataSource != null && message.hasOwnProperty("dataSource"))
                        switch (message.dataSource) {
                        default:
                            return "dataSource: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.area != null && message.hasOwnProperty("area")) {
                        if (!Array.isArray(message.area))
                            return "area: array expected";
                        for (let i = 0; i < message.area.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoPoint.verify(message.area[i]);
                            if (error)
                                return "area." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GeoFence message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.GeoFence
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.GeoFence} GeoFence
                 */
                GeoFence.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.GeoFence)
                        return object;
                    let message = new $root.havocai.messages.v0.GeoFence();
                    if (object.name != null)
                        message.name = String(object.name);
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "GEO_FENCE_TYPE_UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "GEO_FENCE_TYPE_RESTRICTED":
                    case 1:
                        message.type = 1;
                        break;
                    case "GEO_FENCE_TYPE_REQUIRED":
                    case 2:
                        message.type = 2;
                        break;
                    case "GEO_FENCE_TYPE_PERMITTED":
                    case 3:
                        message.type = 3;
                        break;
                    case "GEO_FENCE_TYPE_PREFERRED":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.id != null)
                        message.id = String(object.id);
                    switch (object.dataSource) {
                    default:
                        if (typeof object.dataSource === "number") {
                            message.dataSource = object.dataSource;
                            break;
                        }
                        break;
                    case "DATA_SOURCE_UNKNOWN":
                    case 0:
                        message.dataSource = 0;
                        break;
                    case "DATA_SOURCE_API":
                    case 1:
                        message.dataSource = 1;
                        break;
                    case "DATA_SOURCE_TAK":
                    case 2:
                        message.dataSource = 2;
                        break;
                    case "DATA_SOURCE_LATTICE":
                    case 3:
                        message.dataSource = 3;
                        break;
                    }
                    if (object.area) {
                        if (!Array.isArray(object.area))
                            throw TypeError(".havocai.messages.v0.GeoFence.area: array expected");
                        message.area = [];
                        for (let i = 0; i < object.area.length; ++i) {
                            if (typeof object.area[i] !== "object")
                                throw TypeError(".havocai.messages.v0.GeoFence.area: object expected");
                            message.area[i] = $root.havocai.messages.v0.GeoPoint.fromObject(object.area[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GeoFence message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.GeoFence
                 * @static
                 * @param {havocai.messages.v0.GeoFence} message GeoFence
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GeoFence.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.area = [];
                    if (options.defaults) {
                        object.name = "";
                        object.type = options.enums === String ? "GEO_FENCE_TYPE_UNKNOWN" : 0;
                        object.id = "";
                        object.dataSource = options.enums === String ? "DATA_SOURCE_UNKNOWN" : 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.havocai.messages.v0.GeoFenceType[message.type] === undefined ? message.type : $root.havocai.messages.v0.GeoFenceType[message.type] : message.type;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.dataSource != null && message.hasOwnProperty("dataSource"))
                        object.dataSource = options.enums === String ? $root.havocai.messages.v0.DataSource[message.dataSource] === undefined ? message.dataSource : $root.havocai.messages.v0.DataSource[message.dataSource] : message.dataSource;
                    if (message.area && message.area.length) {
                        object.area = [];
                        for (let j = 0; j < message.area.length; ++j)
                            object.area[j] = $root.havocai.messages.v0.GeoPoint.toObject(message.area[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GeoFence to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.GeoFence
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GeoFence.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for GeoFence
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.GeoFence
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                GeoFence.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.GeoFence";
                };

                return GeoFence;
            })();

            v0.GeoPose = (function() {

                /**
                 * Properties of a GeoPose.
                 * @memberof havocai.messages.v0
                 * @interface IGeoPose
                 * @property {number|Long|null} [time] GeoPose time
                 * @property {havocai.messages.v0.IGeoPoint|null} [location] GeoPose location
                 * @property {havocai.messages.v0.IQuaternion|null} [orientation] GeoPose orientation
                 */

                /**
                 * Constructs a new GeoPose.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a GeoPose.
                 * @implements IGeoPose
                 * @constructor
                 * @param {havocai.messages.v0.IGeoPose=} [properties] Properties to set
                 */
                function GeoPose(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GeoPose time.
                 * @member {number|Long} time
                 * @memberof havocai.messages.v0.GeoPose
                 * @instance
                 */
                GeoPose.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * GeoPose location.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} location
                 * @memberof havocai.messages.v0.GeoPose
                 * @instance
                 */
                GeoPose.prototype.location = null;

                /**
                 * GeoPose orientation.
                 * @member {havocai.messages.v0.IQuaternion|null|undefined} orientation
                 * @memberof havocai.messages.v0.GeoPose
                 * @instance
                 */
                GeoPose.prototype.orientation = null;

                /**
                 * Creates a new GeoPose instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.GeoPose
                 * @static
                 * @param {havocai.messages.v0.IGeoPose=} [properties] Properties to set
                 * @returns {havocai.messages.v0.GeoPose} GeoPose instance
                 */
                GeoPose.create = function create(properties) {
                    return new GeoPose(properties);
                };

                /**
                 * Encodes the specified GeoPose message. Does not implicitly {@link havocai.messages.v0.GeoPose.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.GeoPose
                 * @static
                 * @param {havocai.messages.v0.IGeoPose} message GeoPose message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeoPose.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
                    if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.location, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                        $root.havocai.messages.v0.Quaternion.encode(message.orientation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified GeoPose message, length delimited. Does not implicitly {@link havocai.messages.v0.GeoPose.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.GeoPose
                 * @static
                 * @param {havocai.messages.v0.IGeoPose} message GeoPose message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeoPose.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GeoPose message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.GeoPose
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.GeoPose} GeoPose
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeoPose.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.GeoPose();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.time = reader.int64();
                                break;
                            }
                        case 2: {
                                message.location = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.orientation = $root.havocai.messages.v0.Quaternion.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GeoPose message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.GeoPose
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.GeoPose} GeoPose
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeoPose.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GeoPose message.
                 * @function verify
                 * @memberof havocai.messages.v0.GeoPose
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeoPose.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.time != null && message.hasOwnProperty("time"))
                        if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                            return "time: integer|Long expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        let error = $root.havocai.messages.v0.GeoPoint.verify(message.location);
                        if (error)
                            return "location." + error;
                    }
                    if (message.orientation != null && message.hasOwnProperty("orientation")) {
                        let error = $root.havocai.messages.v0.Quaternion.verify(message.orientation);
                        if (error)
                            return "orientation." + error;
                    }
                    return null;
                };

                /**
                 * Creates a GeoPose message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.GeoPose
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.GeoPose} GeoPose
                 */
                GeoPose.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.GeoPose)
                        return object;
                    let message = new $root.havocai.messages.v0.GeoPose();
                    if (object.time != null)
                        if ($util.Long)
                            (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                        else if (typeof object.time === "string")
                            message.time = parseInt(object.time, 10);
                        else if (typeof object.time === "number")
                            message.time = object.time;
                        else if (typeof object.time === "object")
                            message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
                    if (object.location != null) {
                        if (typeof object.location !== "object")
                            throw TypeError(".havocai.messages.v0.GeoPose.location: object expected");
                        message.location = $root.havocai.messages.v0.GeoPoint.fromObject(object.location);
                    }
                    if (object.orientation != null) {
                        if (typeof object.orientation !== "object")
                            throw TypeError(".havocai.messages.v0.GeoPose.orientation: object expected");
                        message.orientation = $root.havocai.messages.v0.Quaternion.fromObject(object.orientation);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GeoPose message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.GeoPose
                 * @static
                 * @param {havocai.messages.v0.GeoPose} message GeoPose
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GeoPose.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.time = options.longs === String ? "0" : 0;
                        object.location = null;
                        object.orientation = null;
                    }
                    if (message.time != null && message.hasOwnProperty("time"))
                        if (typeof message.time === "number")
                            object.time = options.longs === String ? String(message.time) : message.time;
                        else
                            object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
                    if (message.location != null && message.hasOwnProperty("location"))
                        object.location = $root.havocai.messages.v0.GeoPoint.toObject(message.location, options);
                    if (message.orientation != null && message.hasOwnProperty("orientation"))
                        object.orientation = $root.havocai.messages.v0.Quaternion.toObject(message.orientation, options);
                    return object;
                };

                /**
                 * Converts this GeoPose to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.GeoPose
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GeoPose.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for GeoPose
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.GeoPose
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                GeoPose.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.GeoPose";
                };

                return GeoPose;
            })();

            v0.GeoPoint = (function() {

                /**
                 * Properties of a GeoPoint.
                 * @memberof havocai.messages.v0
                 * @interface IGeoPoint
                 * @property {number|null} [latitude] GeoPoint latitude
                 * @property {number|null} [longitude] GeoPoint longitude
                 * @property {number|null} [altitude] GeoPoint altitude
                 */

                /**
                 * Constructs a new GeoPoint.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a GeoPoint.
                 * @implements IGeoPoint
                 * @constructor
                 * @param {havocai.messages.v0.IGeoPoint=} [properties] Properties to set
                 */
                function GeoPoint(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GeoPoint latitude.
                 * @member {number} latitude
                 * @memberof havocai.messages.v0.GeoPoint
                 * @instance
                 */
                GeoPoint.prototype.latitude = 0;

                /**
                 * GeoPoint longitude.
                 * @member {number} longitude
                 * @memberof havocai.messages.v0.GeoPoint
                 * @instance
                 */
                GeoPoint.prototype.longitude = 0;

                /**
                 * GeoPoint altitude.
                 * @member {number} altitude
                 * @memberof havocai.messages.v0.GeoPoint
                 * @instance
                 */
                GeoPoint.prototype.altitude = 0;

                /**
                 * Creates a new GeoPoint instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.GeoPoint
                 * @static
                 * @param {havocai.messages.v0.IGeoPoint=} [properties] Properties to set
                 * @returns {havocai.messages.v0.GeoPoint} GeoPoint instance
                 */
                GeoPoint.create = function create(properties) {
                    return new GeoPoint(properties);
                };

                /**
                 * Encodes the specified GeoPoint message. Does not implicitly {@link havocai.messages.v0.GeoPoint.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.GeoPoint
                 * @static
                 * @param {havocai.messages.v0.IGeoPoint} message GeoPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeoPoint.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.latitude != null && Object.hasOwnProperty.call(message, "latitude"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.latitude);
                    if (message.longitude != null && Object.hasOwnProperty.call(message, "longitude"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.longitude);
                    if (message.altitude != null && Object.hasOwnProperty.call(message, "altitude"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.altitude);
                    return writer;
                };

                /**
                 * Encodes the specified GeoPoint message, length delimited. Does not implicitly {@link havocai.messages.v0.GeoPoint.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.GeoPoint
                 * @static
                 * @param {havocai.messages.v0.IGeoPoint} message GeoPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeoPoint.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GeoPoint message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.GeoPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.GeoPoint} GeoPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeoPoint.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.GeoPoint();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.latitude = reader.double();
                                break;
                            }
                        case 2: {
                                message.longitude = reader.double();
                                break;
                            }
                        case 3: {
                                message.altitude = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GeoPoint message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.GeoPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.GeoPoint} GeoPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeoPoint.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GeoPoint message.
                 * @function verify
                 * @memberof havocai.messages.v0.GeoPoint
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeoPoint.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.latitude != null && message.hasOwnProperty("latitude"))
                        if (typeof message.latitude !== "number")
                            return "latitude: number expected";
                    if (message.longitude != null && message.hasOwnProperty("longitude"))
                        if (typeof message.longitude !== "number")
                            return "longitude: number expected";
                    if (message.altitude != null && message.hasOwnProperty("altitude"))
                        if (typeof message.altitude !== "number")
                            return "altitude: number expected";
                    return null;
                };

                /**
                 * Creates a GeoPoint message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.GeoPoint
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.GeoPoint} GeoPoint
                 */
                GeoPoint.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.GeoPoint)
                        return object;
                    let message = new $root.havocai.messages.v0.GeoPoint();
                    if (object.latitude != null)
                        message.latitude = Number(object.latitude);
                    if (object.longitude != null)
                        message.longitude = Number(object.longitude);
                    if (object.altitude != null)
                        message.altitude = Number(object.altitude);
                    return message;
                };

                /**
                 * Creates a plain object from a GeoPoint message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.GeoPoint
                 * @static
                 * @param {havocai.messages.v0.GeoPoint} message GeoPoint
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GeoPoint.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.latitude = 0;
                        object.longitude = 0;
                        object.altitude = 0;
                    }
                    if (message.latitude != null && message.hasOwnProperty("latitude"))
                        object.latitude = options.json && !isFinite(message.latitude) ? String(message.latitude) : message.latitude;
                    if (message.longitude != null && message.hasOwnProperty("longitude"))
                        object.longitude = options.json && !isFinite(message.longitude) ? String(message.longitude) : message.longitude;
                    if (message.altitude != null && message.hasOwnProperty("altitude"))
                        object.altitude = options.json && !isFinite(message.altitude) ? String(message.altitude) : message.altitude;
                    return object;
                };

                /**
                 * Converts this GeoPoint to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.GeoPoint
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GeoPoint.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for GeoPoint
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.GeoPoint
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                GeoPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.GeoPoint";
                };

                return GeoPoint;
            })();

            v0.Quaternion = (function() {

                /**
                 * Properties of a Quaternion.
                 * @memberof havocai.messages.v0
                 * @interface IQuaternion
                 * @property {number|null} [x] Quaternion x
                 * @property {number|null} [y] Quaternion y
                 * @property {number|null} [z] Quaternion z
                 * @property {number|null} [w] Quaternion w
                 */

                /**
                 * Constructs a new Quaternion.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Quaternion.
                 * @implements IQuaternion
                 * @constructor
                 * @param {havocai.messages.v0.IQuaternion=} [properties] Properties to set
                 */
                function Quaternion(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Quaternion x.
                 * @member {number} x
                 * @memberof havocai.messages.v0.Quaternion
                 * @instance
                 */
                Quaternion.prototype.x = 0;

                /**
                 * Quaternion y.
                 * @member {number} y
                 * @memberof havocai.messages.v0.Quaternion
                 * @instance
                 */
                Quaternion.prototype.y = 0;

                /**
                 * Quaternion z.
                 * @member {number} z
                 * @memberof havocai.messages.v0.Quaternion
                 * @instance
                 */
                Quaternion.prototype.z = 0;

                /**
                 * Quaternion w.
                 * @member {number} w
                 * @memberof havocai.messages.v0.Quaternion
                 * @instance
                 */
                Quaternion.prototype.w = 0;

                /**
                 * Creates a new Quaternion instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Quaternion
                 * @static
                 * @param {havocai.messages.v0.IQuaternion=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Quaternion} Quaternion instance
                 */
                Quaternion.create = function create(properties) {
                    return new Quaternion(properties);
                };

                /**
                 * Encodes the specified Quaternion message. Does not implicitly {@link havocai.messages.v0.Quaternion.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Quaternion
                 * @static
                 * @param {havocai.messages.v0.IQuaternion} message Quaternion message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Quaternion.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
                    if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
                    if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.z);
                    if (message.w != null && Object.hasOwnProperty.call(message, "w"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.w);
                    return writer;
                };

                /**
                 * Encodes the specified Quaternion message, length delimited. Does not implicitly {@link havocai.messages.v0.Quaternion.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Quaternion
                 * @static
                 * @param {havocai.messages.v0.IQuaternion} message Quaternion message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Quaternion.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Quaternion message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Quaternion
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Quaternion} Quaternion
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Quaternion.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Quaternion();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.x = reader.double();
                                break;
                            }
                        case 2: {
                                message.y = reader.double();
                                break;
                            }
                        case 3: {
                                message.z = reader.double();
                                break;
                            }
                        case 4: {
                                message.w = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Quaternion message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Quaternion
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Quaternion} Quaternion
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Quaternion.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Quaternion message.
                 * @function verify
                 * @memberof havocai.messages.v0.Quaternion
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Quaternion.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.x != null && message.hasOwnProperty("x"))
                        if (typeof message.x !== "number")
                            return "x: number expected";
                    if (message.y != null && message.hasOwnProperty("y"))
                        if (typeof message.y !== "number")
                            return "y: number expected";
                    if (message.z != null && message.hasOwnProperty("z"))
                        if (typeof message.z !== "number")
                            return "z: number expected";
                    if (message.w != null && message.hasOwnProperty("w"))
                        if (typeof message.w !== "number")
                            return "w: number expected";
                    return null;
                };

                /**
                 * Creates a Quaternion message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Quaternion
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Quaternion} Quaternion
                 */
                Quaternion.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Quaternion)
                        return object;
                    let message = new $root.havocai.messages.v0.Quaternion();
                    if (object.x != null)
                        message.x = Number(object.x);
                    if (object.y != null)
                        message.y = Number(object.y);
                    if (object.z != null)
                        message.z = Number(object.z);
                    if (object.w != null)
                        message.w = Number(object.w);
                    return message;
                };

                /**
                 * Creates a plain object from a Quaternion message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Quaternion
                 * @static
                 * @param {havocai.messages.v0.Quaternion} message Quaternion
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Quaternion.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.x = 0;
                        object.y = 0;
                        object.z = 0;
                        object.w = 0;
                    }
                    if (message.x != null && message.hasOwnProperty("x"))
                        object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                    if (message.y != null && message.hasOwnProperty("y"))
                        object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                    if (message.z != null && message.hasOwnProperty("z"))
                        object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
                    if (message.w != null && message.hasOwnProperty("w"))
                        object.w = options.json && !isFinite(message.w) ? String(message.w) : message.w;
                    return object;
                };

                /**
                 * Converts this Quaternion to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Quaternion
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Quaternion.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Quaternion
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Quaternion
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Quaternion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Quaternion";
                };

                return Quaternion;
            })();

            v0.Metric = (function() {

                /**
                 * Properties of a Metric.
                 * @memberof havocai.messages.v0
                 * @interface IMetric
                 * @property {havocai.messages.v0.MetricKey|null} [key] Metric key
                 * @property {havocai.messages.v0.MetricType|null} [type] Metric type
                 * @property {number|null} [value] Metric value
                 */

                /**
                 * Constructs a new Metric.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Metric.
                 * @implements IMetric
                 * @constructor
                 * @param {havocai.messages.v0.IMetric=} [properties] Properties to set
                 */
                function Metric(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Metric key.
                 * @member {havocai.messages.v0.MetricKey} key
                 * @memberof havocai.messages.v0.Metric
                 * @instance
                 */
                Metric.prototype.key = 0;

                /**
                 * Metric type.
                 * @member {havocai.messages.v0.MetricType} type
                 * @memberof havocai.messages.v0.Metric
                 * @instance
                 */
                Metric.prototype.type = 0;

                /**
                 * Metric value.
                 * @member {number} value
                 * @memberof havocai.messages.v0.Metric
                 * @instance
                 */
                Metric.prototype.value = 0;

                /**
                 * Creates a new Metric instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Metric
                 * @static
                 * @param {havocai.messages.v0.IMetric=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Metric} Metric instance
                 */
                Metric.create = function create(properties) {
                    return new Metric(properties);
                };

                /**
                 * Encodes the specified Metric message. Does not implicitly {@link havocai.messages.v0.Metric.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Metric
                 * @static
                 * @param {havocai.messages.v0.IMetric} message Metric message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Metric.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.key);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.value);
                    return writer;
                };

                /**
                 * Encodes the specified Metric message, length delimited. Does not implicitly {@link havocai.messages.v0.Metric.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Metric
                 * @static
                 * @param {havocai.messages.v0.IMetric} message Metric message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Metric.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Metric message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Metric
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Metric} Metric
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Metric.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Metric();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.key = reader.int32();
                                break;
                            }
                        case 2: {
                                message.type = reader.int32();
                                break;
                            }
                        case 3: {
                                message.value = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Metric message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Metric
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Metric} Metric
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Metric.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Metric message.
                 * @function verify
                 * @memberof havocai.messages.v0.Metric
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Metric.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        switch (message.key) {
                        default:
                            return "key: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "number")
                            return "value: number expected";
                    return null;
                };

                /**
                 * Creates a Metric message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Metric
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Metric} Metric
                 */
                Metric.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Metric)
                        return object;
                    let message = new $root.havocai.messages.v0.Metric();
                    switch (object.key) {
                    default:
                        if (typeof object.key === "number") {
                            message.key = object.key;
                            break;
                        }
                        break;
                    case "METRIC_KEY_UNKNOWN":
                    case 0:
                        message.key = 0;
                        break;
                    case "METRIC_KEY_VOLTAGE":
                    case 1:
                        message.key = 1;
                        break;
                    case "METRIC_KEY_POWER":
                    case 2:
                        message.key = 2;
                        break;
                    case "METRIC_KEY_ENERGY_CAPACITY":
                    case 3:
                        message.key = 3;
                        break;
                    case "METRIC_KEY_ENERGY_REMAINING":
                    case 4:
                        message.key = 4;
                        break;
                    case "METRIC_KEY_BATTERY_CHARGE":
                    case 5:
                        message.key = 5;
                        break;
                    case "METRIC_KEY_SENSOR_RANGE":
                    case 6:
                        message.key = 6;
                        break;
                    case "METRIC_KEY_BATTERY_CURRENT":
                    case 7:
                        message.key = 7;
                        break;
                    case "METRIC_KEY_BATTERY_TEMPERATURE":
                    case 8:
                        message.key = 8;
                        break;
                    }
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "METRIC_TYPE_UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "METRIC_TYPE_BOOL":
                    case 1:
                        message.type = 1;
                        break;
                    case "METRIC_TYPE_NUMBER":
                    case 2:
                        message.type = 2;
                        break;
                    case "METRIC_TYPE_PERCENTAGE":
                    case 3:
                        message.type = 3;
                        break;
                    }
                    if (object.value != null)
                        message.value = Number(object.value);
                    return message;
                };

                /**
                 * Creates a plain object from a Metric message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Metric
                 * @static
                 * @param {havocai.messages.v0.Metric} message Metric
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Metric.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.key = options.enums === String ? "METRIC_KEY_UNKNOWN" : 0;
                        object.type = options.enums === String ? "METRIC_TYPE_UNKNOWN" : 0;
                        object.value = 0;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.enums === String ? $root.havocai.messages.v0.MetricKey[message.key] === undefined ? message.key : $root.havocai.messages.v0.MetricKey[message.key] : message.key;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.havocai.messages.v0.MetricType[message.type] === undefined ? message.type : $root.havocai.messages.v0.MetricType[message.type] : message.type;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                    return object;
                };

                /**
                 * Converts this Metric to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Metric
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Metric.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Metric
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Metric
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Metric.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Metric";
                };

                return Metric;
            })();

            v0.Error = (function() {

                /**
                 * Properties of an Error.
                 * @memberof havocai.messages.v0
                 * @interface IError
                 * @property {number|null} [code] Error code
                 * @property {string|null} [codeStr] Error codeStr
                 * @property {havocai.messages.v0.ErrorLevel|null} [level] Error level
                 * @property {string|null} [message] Error message
                 * @property {google.protobuf.ITimestamp|null} [timeReported] Error timeReported
                 */

                /**
                 * Constructs a new Error.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents an Error.
                 * @implements IError
                 * @constructor
                 * @param {havocai.messages.v0.IError=} [properties] Properties to set
                 */
                function Error(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Error code.
                 * @member {number} code
                 * @memberof havocai.messages.v0.Error
                 * @instance
                 */
                Error.prototype.code = 0;

                /**
                 * Error codeStr.
                 * @member {string} codeStr
                 * @memberof havocai.messages.v0.Error
                 * @instance
                 */
                Error.prototype.codeStr = "";

                /**
                 * Error level.
                 * @member {havocai.messages.v0.ErrorLevel} level
                 * @memberof havocai.messages.v0.Error
                 * @instance
                 */
                Error.prototype.level = 0;

                /**
                 * Error message.
                 * @member {string} message
                 * @memberof havocai.messages.v0.Error
                 * @instance
                 */
                Error.prototype.message = "";

                /**
                 * Error timeReported.
                 * @member {google.protobuf.ITimestamp|null|undefined} timeReported
                 * @memberof havocai.messages.v0.Error
                 * @instance
                 */
                Error.prototype.timeReported = null;

                /**
                 * Creates a new Error instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Error
                 * @static
                 * @param {havocai.messages.v0.IError=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Error} Error instance
                 */
                Error.create = function create(properties) {
                    return new Error(properties);
                };

                /**
                 * Encodes the specified Error message. Does not implicitly {@link havocai.messages.v0.Error.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Error
                 * @static
                 * @param {havocai.messages.v0.IError} message Error message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Error.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                    if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);
                    if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);
                    if (message.codeStr != null && Object.hasOwnProperty.call(message, "codeStr"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.codeStr);
                    if (message.timeReported != null && Object.hasOwnProperty.call(message, "timeReported"))
                        $root.google.protobuf.Timestamp.encode(message.timeReported, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Error message, length delimited. Does not implicitly {@link havocai.messages.v0.Error.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Error
                 * @static
                 * @param {havocai.messages.v0.IError} message Error message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Error.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Error message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Error
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Error} Error
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Error.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Error();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.code = reader.int32();
                                break;
                            }
                        case 4: {
                                message.codeStr = reader.string();
                                break;
                            }
                        case 2: {
                                message.level = reader.int32();
                                break;
                            }
                        case 3: {
                                message.message = reader.string();
                                break;
                            }
                        case 5: {
                                message.timeReported = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Error message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Error
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Error} Error
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Error.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Error message.
                 * @function verify
                 * @memberof havocai.messages.v0.Error
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Error.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isInteger(message.code))
                            return "code: integer expected";
                    if (message.codeStr != null && message.hasOwnProperty("codeStr"))
                        if (!$util.isString(message.codeStr))
                            return "codeStr: string expected";
                    if (message.level != null && message.hasOwnProperty("level"))
                        switch (message.level) {
                        default:
                            return "level: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    if (message.timeReported != null && message.hasOwnProperty("timeReported")) {
                        let error = $root.google.protobuf.Timestamp.verify(message.timeReported);
                        if (error)
                            return "timeReported." + error;
                    }
                    return null;
                };

                /**
                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Error
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Error} Error
                 */
                Error.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Error)
                        return object;
                    let message = new $root.havocai.messages.v0.Error();
                    if (object.code != null)
                        message.code = object.code | 0;
                    if (object.codeStr != null)
                        message.codeStr = String(object.codeStr);
                    switch (object.level) {
                    default:
                        if (typeof object.level === "number") {
                            message.level = object.level;
                            break;
                        }
                        break;
                    case "ERROR_LEVEL_UNKNOWN":
                    case 0:
                        message.level = 0;
                        break;
                    case "ERROR_LEVEL_WARNING":
                    case 1:
                        message.level = 1;
                        break;
                    case "ERROR_LEVEL_MINOR":
                    case 2:
                        message.level = 2;
                        break;
                    case "ERROR_LEVEL_MAJOR":
                    case 3:
                        message.level = 3;
                        break;
                    case "ERROR_LEVEL_CRITICAL":
                    case 4:
                        message.level = 4;
                        break;
                    }
                    if (object.message != null)
                        message.message = String(object.message);
                    if (object.timeReported != null) {
                        if (typeof object.timeReported !== "object")
                            throw TypeError(".havocai.messages.v0.Error.timeReported: object expected");
                        message.timeReported = $root.google.protobuf.Timestamp.fromObject(object.timeReported);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Error
                 * @static
                 * @param {havocai.messages.v0.Error} message Error
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Error.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.code = 0;
                        object.level = options.enums === String ? "ERROR_LEVEL_UNKNOWN" : 0;
                        object.message = "";
                        object.codeStr = "";
                        object.timeReported = null;
                    }
                    if (message.code != null && message.hasOwnProperty("code"))
                        object.code = message.code;
                    if (message.level != null && message.hasOwnProperty("level"))
                        object.level = options.enums === String ? $root.havocai.messages.v0.ErrorLevel[message.level] === undefined ? message.level : $root.havocai.messages.v0.ErrorLevel[message.level] : message.level;
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    if (message.codeStr != null && message.hasOwnProperty("codeStr"))
                        object.codeStr = message.codeStr;
                    if (message.timeReported != null && message.hasOwnProperty("timeReported"))
                        object.timeReported = $root.google.protobuf.Timestamp.toObject(message.timeReported, options);
                    return object;
                };

                /**
                 * Converts this Error to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Error
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Error.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Error
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Error
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Error.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Error";
                };

                return Error;
            })();

            v0.FrontendContext = (function() {

                /**
                 * Properties of a FrontendContext.
                 * @memberof havocai.messages.v0
                 * @interface IFrontendContext
                 * @property {string|null} [version] FrontendContext version
                 * @property {string|null} [gitCommit] FrontendContext gitCommit
                 * @property {string|null} [buildTime] FrontendContext buildTime
                 * @property {string|null} [oauthClientId] FrontendContext oauthClientId
                 * @property {string|null} [oauthAuthorityUrl] FrontendContext oauthAuthorityUrl
                 */

                /**
                 * Constructs a new FrontendContext.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a FrontendContext.
                 * @implements IFrontendContext
                 * @constructor
                 * @param {havocai.messages.v0.IFrontendContext=} [properties] Properties to set
                 */
                function FrontendContext(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FrontendContext version.
                 * @member {string} version
                 * @memberof havocai.messages.v0.FrontendContext
                 * @instance
                 */
                FrontendContext.prototype.version = "";

                /**
                 * FrontendContext gitCommit.
                 * @member {string} gitCommit
                 * @memberof havocai.messages.v0.FrontendContext
                 * @instance
                 */
                FrontendContext.prototype.gitCommit = "";

                /**
                 * FrontendContext buildTime.
                 * @member {string} buildTime
                 * @memberof havocai.messages.v0.FrontendContext
                 * @instance
                 */
                FrontendContext.prototype.buildTime = "";

                /**
                 * FrontendContext oauthClientId.
                 * @member {string} oauthClientId
                 * @memberof havocai.messages.v0.FrontendContext
                 * @instance
                 */
                FrontendContext.prototype.oauthClientId = "";

                /**
                 * FrontendContext oauthAuthorityUrl.
                 * @member {string} oauthAuthorityUrl
                 * @memberof havocai.messages.v0.FrontendContext
                 * @instance
                 */
                FrontendContext.prototype.oauthAuthorityUrl = "";

                /**
                 * Creates a new FrontendContext instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.FrontendContext
                 * @static
                 * @param {havocai.messages.v0.IFrontendContext=} [properties] Properties to set
                 * @returns {havocai.messages.v0.FrontendContext} FrontendContext instance
                 */
                FrontendContext.create = function create(properties) {
                    return new FrontendContext(properties);
                };

                /**
                 * Encodes the specified FrontendContext message. Does not implicitly {@link havocai.messages.v0.FrontendContext.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.FrontendContext
                 * @static
                 * @param {havocai.messages.v0.IFrontendContext} message FrontendContext message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FrontendContext.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
                    if (message.gitCommit != null && Object.hasOwnProperty.call(message, "gitCommit"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.gitCommit);
                    if (message.buildTime != null && Object.hasOwnProperty.call(message, "buildTime"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.buildTime);
                    if (message.oauthClientId != null && Object.hasOwnProperty.call(message, "oauthClientId"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.oauthClientId);
                    if (message.oauthAuthorityUrl != null && Object.hasOwnProperty.call(message, "oauthAuthorityUrl"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.oauthAuthorityUrl);
                    return writer;
                };

                /**
                 * Encodes the specified FrontendContext message, length delimited. Does not implicitly {@link havocai.messages.v0.FrontendContext.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.FrontendContext
                 * @static
                 * @param {havocai.messages.v0.IFrontendContext} message FrontendContext message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FrontendContext.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FrontendContext message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.FrontendContext
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.FrontendContext} FrontendContext
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FrontendContext.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.FrontendContext();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.version = reader.string();
                                break;
                            }
                        case 2: {
                                message.gitCommit = reader.string();
                                break;
                            }
                        case 3: {
                                message.buildTime = reader.string();
                                break;
                            }
                        case 4: {
                                message.oauthClientId = reader.string();
                                break;
                            }
                        case 5: {
                                message.oauthAuthorityUrl = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FrontendContext message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.FrontendContext
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.FrontendContext} FrontendContext
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FrontendContext.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FrontendContext message.
                 * @function verify
                 * @memberof havocai.messages.v0.FrontendContext
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FrontendContext.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isString(message.version))
                            return "version: string expected";
                    if (message.gitCommit != null && message.hasOwnProperty("gitCommit"))
                        if (!$util.isString(message.gitCommit))
                            return "gitCommit: string expected";
                    if (message.buildTime != null && message.hasOwnProperty("buildTime"))
                        if (!$util.isString(message.buildTime))
                            return "buildTime: string expected";
                    if (message.oauthClientId != null && message.hasOwnProperty("oauthClientId"))
                        if (!$util.isString(message.oauthClientId))
                            return "oauthClientId: string expected";
                    if (message.oauthAuthorityUrl != null && message.hasOwnProperty("oauthAuthorityUrl"))
                        if (!$util.isString(message.oauthAuthorityUrl))
                            return "oauthAuthorityUrl: string expected";
                    return null;
                };

                /**
                 * Creates a FrontendContext message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.FrontendContext
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.FrontendContext} FrontendContext
                 */
                FrontendContext.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.FrontendContext)
                        return object;
                    let message = new $root.havocai.messages.v0.FrontendContext();
                    if (object.version != null)
                        message.version = String(object.version);
                    if (object.gitCommit != null)
                        message.gitCommit = String(object.gitCommit);
                    if (object.buildTime != null)
                        message.buildTime = String(object.buildTime);
                    if (object.oauthClientId != null)
                        message.oauthClientId = String(object.oauthClientId);
                    if (object.oauthAuthorityUrl != null)
                        message.oauthAuthorityUrl = String(object.oauthAuthorityUrl);
                    return message;
                };

                /**
                 * Creates a plain object from a FrontendContext message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.FrontendContext
                 * @static
                 * @param {havocai.messages.v0.FrontendContext} message FrontendContext
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FrontendContext.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.version = "";
                        object.gitCommit = "";
                        object.buildTime = "";
                        object.oauthClientId = "";
                        object.oauthAuthorityUrl = "";
                    }
                    if (message.version != null && message.hasOwnProperty("version"))
                        object.version = message.version;
                    if (message.gitCommit != null && message.hasOwnProperty("gitCommit"))
                        object.gitCommit = message.gitCommit;
                    if (message.buildTime != null && message.hasOwnProperty("buildTime"))
                        object.buildTime = message.buildTime;
                    if (message.oauthClientId != null && message.hasOwnProperty("oauthClientId"))
                        object.oauthClientId = message.oauthClientId;
                    if (message.oauthAuthorityUrl != null && message.hasOwnProperty("oauthAuthorityUrl"))
                        object.oauthAuthorityUrl = message.oauthAuthorityUrl;
                    return object;
                };

                /**
                 * Converts this FrontendContext to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.FrontendContext
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FrontendContext.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for FrontendContext
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.FrontendContext
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FrontendContext.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.FrontendContext";
                };

                return FrontendContext;
            })();

            v0.VehicleState = (function() {

                /**
                 * Properties of a VehicleState.
                 * @memberof havocai.messages.v0
                 * @interface IVehicleState
                 * @property {havocai.messages.v0.VehicleInterfaceStateType|null} [vehicleInterfaceState] VehicleState vehicleInterfaceState
                 */

                /**
                 * Constructs a new VehicleState.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a VehicleState.
                 * @implements IVehicleState
                 * @constructor
                 * @param {havocai.messages.v0.IVehicleState=} [properties] Properties to set
                 */
                function VehicleState(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * VehicleState vehicleInterfaceState.
                 * @member {havocai.messages.v0.VehicleInterfaceStateType} vehicleInterfaceState
                 * @memberof havocai.messages.v0.VehicleState
                 * @instance
                 */
                VehicleState.prototype.vehicleInterfaceState = 0;

                /**
                 * Creates a new VehicleState instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.VehicleState
                 * @static
                 * @param {havocai.messages.v0.IVehicleState=} [properties] Properties to set
                 * @returns {havocai.messages.v0.VehicleState} VehicleState instance
                 */
                VehicleState.create = function create(properties) {
                    return new VehicleState(properties);
                };

                /**
                 * Encodes the specified VehicleState message. Does not implicitly {@link havocai.messages.v0.VehicleState.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.VehicleState
                 * @static
                 * @param {havocai.messages.v0.IVehicleState} message VehicleState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VehicleState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.vehicleInterfaceState != null && Object.hasOwnProperty.call(message, "vehicleInterfaceState"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.vehicleInterfaceState);
                    return writer;
                };

                /**
                 * Encodes the specified VehicleState message, length delimited. Does not implicitly {@link havocai.messages.v0.VehicleState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.VehicleState
                 * @static
                 * @param {havocai.messages.v0.IVehicleState} message VehicleState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VehicleState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a VehicleState message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.VehicleState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.VehicleState} VehicleState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VehicleState.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.VehicleState();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 5: {
                                message.vehicleInterfaceState = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a VehicleState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.VehicleState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.VehicleState} VehicleState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VehicleState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a VehicleState message.
                 * @function verify
                 * @memberof havocai.messages.v0.VehicleState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                VehicleState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vehicleInterfaceState != null && message.hasOwnProperty("vehicleInterfaceState"))
                        switch (message.vehicleInterfaceState) {
                        default:
                            return "vehicleInterfaceState: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a VehicleState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.VehicleState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.VehicleState} VehicleState
                 */
                VehicleState.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.VehicleState)
                        return object;
                    let message = new $root.havocai.messages.v0.VehicleState();
                    switch (object.vehicleInterfaceState) {
                    default:
                        if (typeof object.vehicleInterfaceState === "number") {
                            message.vehicleInterfaceState = object.vehicleInterfaceState;
                            break;
                        }
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_UNSPECIFIED":
                    case 0:
                        message.vehicleInterfaceState = 0;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_DISARMED":
                    case 1:
                        message.vehicleInterfaceState = 1;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_FREE_FLOAT":
                    case 2:
                        message.vehicleInterfaceState = 2;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_ROUTE_FOLLOWING":
                    case 3:
                        message.vehicleInterfaceState = 3;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_CONTROLLED_DRIFT":
                    case 4:
                        message.vehicleInterfaceState = 4;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_VECTOR":
                    case 5:
                        message.vehicleInterfaceState = 5;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_FOLLOW_TARGET":
                    case 6:
                        message.vehicleInterfaceState = 6;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_REMOTELY_OPERATED":
                    case 7:
                        message.vehicleInterfaceState = 7;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a VehicleState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.VehicleState
                 * @static
                 * @param {havocai.messages.v0.VehicleState} message VehicleState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                VehicleState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.vehicleInterfaceState = options.enums === String ? "VEHICLE_INTERFACE_STATE_TYPE_UNSPECIFIED" : 0;
                    if (message.vehicleInterfaceState != null && message.hasOwnProperty("vehicleInterfaceState"))
                        object.vehicleInterfaceState = options.enums === String ? $root.havocai.messages.v0.VehicleInterfaceStateType[message.vehicleInterfaceState] === undefined ? message.vehicleInterfaceState : $root.havocai.messages.v0.VehicleInterfaceStateType[message.vehicleInterfaceState] : message.vehicleInterfaceState;
                    return object;
                };

                /**
                 * Converts this VehicleState to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.VehicleState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                VehicleState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for VehicleState
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.VehicleState
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                VehicleState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.VehicleState";
                };

                return VehicleState;
            })();

            v0.VehicleStateReport = (function() {

                /**
                 * Properties of a VehicleStateReport.
                 * @memberof havocai.messages.v0
                 * @interface IVehicleStateReport
                 * @property {havocai.messages.v0.IVehicleState|null} [body] VehicleStateReport body
                 */

                /**
                 * Constructs a new VehicleStateReport.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a VehicleStateReport.
                 * @implements IVehicleStateReport
                 * @constructor
                 * @param {havocai.messages.v0.IVehicleStateReport=} [properties] Properties to set
                 */
                function VehicleStateReport(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * VehicleStateReport body.
                 * @member {havocai.messages.v0.IVehicleState|null|undefined} body
                 * @memberof havocai.messages.v0.VehicleStateReport
                 * @instance
                 */
                VehicleStateReport.prototype.body = null;

                /**
                 * Creates a new VehicleStateReport instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.VehicleStateReport
                 * @static
                 * @param {havocai.messages.v0.IVehicleStateReport=} [properties] Properties to set
                 * @returns {havocai.messages.v0.VehicleStateReport} VehicleStateReport instance
                 */
                VehicleStateReport.create = function create(properties) {
                    return new VehicleStateReport(properties);
                };

                /**
                 * Encodes the specified VehicleStateReport message. Does not implicitly {@link havocai.messages.v0.VehicleStateReport.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.VehicleStateReport
                 * @static
                 * @param {havocai.messages.v0.IVehicleStateReport} message VehicleStateReport message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VehicleStateReport.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                        $root.havocai.messages.v0.VehicleState.encode(message.body, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified VehicleStateReport message, length delimited. Does not implicitly {@link havocai.messages.v0.VehicleStateReport.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.VehicleStateReport
                 * @static
                 * @param {havocai.messages.v0.IVehicleStateReport} message VehicleStateReport message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VehicleStateReport.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a VehicleStateReport message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.VehicleStateReport
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.VehicleStateReport} VehicleStateReport
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VehicleStateReport.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.VehicleStateReport();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 2: {
                                message.body = $root.havocai.messages.v0.VehicleState.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a VehicleStateReport message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.VehicleStateReport
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.VehicleStateReport} VehicleStateReport
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VehicleStateReport.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a VehicleStateReport message.
                 * @function verify
                 * @memberof havocai.messages.v0.VehicleStateReport
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                VehicleStateReport.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.body != null && message.hasOwnProperty("body")) {
                        let error = $root.havocai.messages.v0.VehicleState.verify(message.body);
                        if (error)
                            return "body." + error;
                    }
                    return null;
                };

                /**
                 * Creates a VehicleStateReport message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.VehicleStateReport
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.VehicleStateReport} VehicleStateReport
                 */
                VehicleStateReport.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.VehicleStateReport)
                        return object;
                    let message = new $root.havocai.messages.v0.VehicleStateReport();
                    if (object.body != null) {
                        if (typeof object.body !== "object")
                            throw TypeError(".havocai.messages.v0.VehicleStateReport.body: object expected");
                        message.body = $root.havocai.messages.v0.VehicleState.fromObject(object.body);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a VehicleStateReport message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.VehicleStateReport
                 * @static
                 * @param {havocai.messages.v0.VehicleStateReport} message VehicleStateReport
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                VehicleStateReport.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.body = null;
                    if (message.body != null && message.hasOwnProperty("body"))
                        object.body = $root.havocai.messages.v0.VehicleState.toObject(message.body, options);
                    return object;
                };

                /**
                 * Converts this VehicleStateReport to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.VehicleStateReport
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                VehicleStateReport.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for VehicleStateReport
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.VehicleStateReport
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                VehicleStateReport.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.VehicleStateReport";
                };

                return VehicleStateReport;
            })();

            v0.User = (function() {

                /**
                 * Properties of a User.
                 * @memberof havocai.messages.v0
                 * @interface IUser
                 * @property {string|null} [id] User id
                 * @property {string|null} [username] User username
                 * @property {string|null} [realName] User realName
                 */

                /**
                 * Constructs a new User.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a User.
                 * @implements IUser
                 * @constructor
                 * @param {havocai.messages.v0.IUser=} [properties] Properties to set
                 */
                function User(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * User id.
                 * @member {string} id
                 * @memberof havocai.messages.v0.User
                 * @instance
                 */
                User.prototype.id = "";

                /**
                 * User username.
                 * @member {string} username
                 * @memberof havocai.messages.v0.User
                 * @instance
                 */
                User.prototype.username = "";

                /**
                 * User realName.
                 * @member {string} realName
                 * @memberof havocai.messages.v0.User
                 * @instance
                 */
                User.prototype.realName = "";

                /**
                 * Creates a new User instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.User
                 * @static
                 * @param {havocai.messages.v0.IUser=} [properties] Properties to set
                 * @returns {havocai.messages.v0.User} User instance
                 */
                User.create = function create(properties) {
                    return new User(properties);
                };

                /**
                 * Encodes the specified User message. Does not implicitly {@link havocai.messages.v0.User.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.User
                 * @static
                 * @param {havocai.messages.v0.IUser} message User message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                User.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                    if (message.realName != null && Object.hasOwnProperty.call(message, "realName"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.realName);
                    return writer;
                };

                /**
                 * Encodes the specified User message, length delimited. Does not implicitly {@link havocai.messages.v0.User.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.User
                 * @static
                 * @param {havocai.messages.v0.IUser} message User message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                User.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a User message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.User
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.User} User
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                User.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.User();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.id = reader.string();
                                break;
                            }
                        case 2: {
                                message.username = reader.string();
                                break;
                            }
                        case 3: {
                                message.realName = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a User message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.User
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.User} User
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                User.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a User message.
                 * @function verify
                 * @memberof havocai.messages.v0.User
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                User.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.username != null && message.hasOwnProperty("username"))
                        if (!$util.isString(message.username))
                            return "username: string expected";
                    if (message.realName != null && message.hasOwnProperty("realName"))
                        if (!$util.isString(message.realName))
                            return "realName: string expected";
                    return null;
                };

                /**
                 * Creates a User message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.User
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.User} User
                 */
                User.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.User)
                        return object;
                    let message = new $root.havocai.messages.v0.User();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.username != null)
                        message.username = String(object.username);
                    if (object.realName != null)
                        message.realName = String(object.realName);
                    return message;
                };

                /**
                 * Creates a plain object from a User message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.User
                 * @static
                 * @param {havocai.messages.v0.User} message User
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                User.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.username = "";
                        object.realName = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.username != null && message.hasOwnProperty("username"))
                        object.username = message.username;
                    if (message.realName != null && message.hasOwnProperty("realName"))
                        object.realName = message.realName;
                    return object;
                };

                /**
                 * Converts this User to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.User
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                User.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for User
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.User
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                User.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.User";
                };

                return User;
            })();

            v0.GeoImage = (function() {

                /**
                 * Properties of a GeoImage.
                 * @memberof havocai.messages.v0
                 * @interface IGeoImage
                 * @property {string|null} [id] GeoImage id
                 * @property {string|null} [uri] GeoImage uri
                 * @property {number|Long|null} [creationTime] GeoImage creationTime
                 * @property {havocai.messages.v0.IResourceRef|null} [vehicle] GeoImage vehicle
                 * @property {string|null} [sourcePath] GeoImage sourcePath
                 * @property {havocai.messages.v0.IGeoPoint|null} [referencePosition] GeoImage referencePosition
                 * @property {number|null} [bearing] GeoImage bearing
                 * @property {number|null} [horizontalFov] GeoImage horizontalFov
                 * @property {number|null} [verticalFov] GeoImage verticalFov
                 * @property {number|null} [focalLength] GeoImage focalLength
                 */

                /**
                 * Constructs a new GeoImage.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a GeoImage.
                 * @implements IGeoImage
                 * @constructor
                 * @param {havocai.messages.v0.IGeoImage=} [properties] Properties to set
                 */
                function GeoImage(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GeoImage id.
                 * @member {string} id
                 * @memberof havocai.messages.v0.GeoImage
                 * @instance
                 */
                GeoImage.prototype.id = "";

                /**
                 * GeoImage uri.
                 * @member {string} uri
                 * @memberof havocai.messages.v0.GeoImage
                 * @instance
                 */
                GeoImage.prototype.uri = "";

                /**
                 * GeoImage creationTime.
                 * @member {number|Long} creationTime
                 * @memberof havocai.messages.v0.GeoImage
                 * @instance
                 */
                GeoImage.prototype.creationTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * GeoImage vehicle.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} vehicle
                 * @memberof havocai.messages.v0.GeoImage
                 * @instance
                 */
                GeoImage.prototype.vehicle = null;

                /**
                 * GeoImage sourcePath.
                 * @member {string} sourcePath
                 * @memberof havocai.messages.v0.GeoImage
                 * @instance
                 */
                GeoImage.prototype.sourcePath = "";

                /**
                 * GeoImage referencePosition.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} referencePosition
                 * @memberof havocai.messages.v0.GeoImage
                 * @instance
                 */
                GeoImage.prototype.referencePosition = null;

                /**
                 * GeoImage bearing.
                 * @member {number} bearing
                 * @memberof havocai.messages.v0.GeoImage
                 * @instance
                 */
                GeoImage.prototype.bearing = 0;

                /**
                 * GeoImage horizontalFov.
                 * @member {number} horizontalFov
                 * @memberof havocai.messages.v0.GeoImage
                 * @instance
                 */
                GeoImage.prototype.horizontalFov = 0;

                /**
                 * GeoImage verticalFov.
                 * @member {number} verticalFov
                 * @memberof havocai.messages.v0.GeoImage
                 * @instance
                 */
                GeoImage.prototype.verticalFov = 0;

                /**
                 * GeoImage focalLength.
                 * @member {number} focalLength
                 * @memberof havocai.messages.v0.GeoImage
                 * @instance
                 */
                GeoImage.prototype.focalLength = 0;

                /**
                 * Creates a new GeoImage instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.GeoImage
                 * @static
                 * @param {havocai.messages.v0.IGeoImage=} [properties] Properties to set
                 * @returns {havocai.messages.v0.GeoImage} GeoImage instance
                 */
                GeoImage.create = function create(properties) {
                    return new GeoImage(properties);
                };

                /**
                 * Encodes the specified GeoImage message. Does not implicitly {@link havocai.messages.v0.GeoImage.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.GeoImage
                 * @static
                 * @param {havocai.messages.v0.IGeoImage} message GeoImage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeoImage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.uri);
                    if (message.creationTime != null && Object.hasOwnProperty.call(message, "creationTime"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.creationTime);
                    if (message.sourcePath != null && Object.hasOwnProperty.call(message, "sourcePath"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.sourcePath);
                    if (message.referencePosition != null && Object.hasOwnProperty.call(message, "referencePosition"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.referencePosition, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.bearing != null && Object.hasOwnProperty.call(message, "bearing"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.bearing);
                    if (message.horizontalFov != null && Object.hasOwnProperty.call(message, "horizontalFov"))
                        writer.uint32(/* id 7, wireType 1 =*/57).double(message.horizontalFov);
                    if (message.verticalFov != null && Object.hasOwnProperty.call(message, "verticalFov"))
                        writer.uint32(/* id 8, wireType 1 =*/65).double(message.verticalFov);
                    if (message.focalLength != null && Object.hasOwnProperty.call(message, "focalLength"))
                        writer.uint32(/* id 9, wireType 1 =*/73).double(message.focalLength);
                    if (message.vehicle != null && Object.hasOwnProperty.call(message, "vehicle"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.vehicle, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified GeoImage message, length delimited. Does not implicitly {@link havocai.messages.v0.GeoImage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.GeoImage
                 * @static
                 * @param {havocai.messages.v0.IGeoImage} message GeoImage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeoImage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GeoImage message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.GeoImage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.GeoImage} GeoImage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeoImage.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.GeoImage();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.id = reader.string();
                                break;
                            }
                        case 2: {
                                message.uri = reader.string();
                                break;
                            }
                        case 3: {
                                message.creationTime = reader.int64();
                                break;
                            }
                        case 10: {
                                message.vehicle = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.sourcePath = reader.string();
                                break;
                            }
                        case 5: {
                                message.referencePosition = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        case 6: {
                                message.bearing = reader.double();
                                break;
                            }
                        case 7: {
                                message.horizontalFov = reader.double();
                                break;
                            }
                        case 8: {
                                message.verticalFov = reader.double();
                                break;
                            }
                        case 9: {
                                message.focalLength = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GeoImage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.GeoImage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.GeoImage} GeoImage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeoImage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GeoImage message.
                 * @function verify
                 * @memberof havocai.messages.v0.GeoImage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeoImage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.creationTime != null && message.hasOwnProperty("creationTime"))
                        if (!$util.isInteger(message.creationTime) && !(message.creationTime && $util.isInteger(message.creationTime.low) && $util.isInteger(message.creationTime.high)))
                            return "creationTime: integer|Long expected";
                    if (message.vehicle != null && message.hasOwnProperty("vehicle")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.vehicle);
                        if (error)
                            return "vehicle." + error;
                    }
                    if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                        if (!$util.isString(message.sourcePath))
                            return "sourcePath: string expected";
                    if (message.referencePosition != null && message.hasOwnProperty("referencePosition")) {
                        let error = $root.havocai.messages.v0.GeoPoint.verify(message.referencePosition);
                        if (error)
                            return "referencePosition." + error;
                    }
                    if (message.bearing != null && message.hasOwnProperty("bearing"))
                        if (typeof message.bearing !== "number")
                            return "bearing: number expected";
                    if (message.horizontalFov != null && message.hasOwnProperty("horizontalFov"))
                        if (typeof message.horizontalFov !== "number")
                            return "horizontalFov: number expected";
                    if (message.verticalFov != null && message.hasOwnProperty("verticalFov"))
                        if (typeof message.verticalFov !== "number")
                            return "verticalFov: number expected";
                    if (message.focalLength != null && message.hasOwnProperty("focalLength"))
                        if (typeof message.focalLength !== "number")
                            return "focalLength: number expected";
                    return null;
                };

                /**
                 * Creates a GeoImage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.GeoImage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.GeoImage} GeoImage
                 */
                GeoImage.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.GeoImage)
                        return object;
                    let message = new $root.havocai.messages.v0.GeoImage();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.creationTime != null)
                        if ($util.Long)
                            (message.creationTime = $util.Long.fromValue(object.creationTime)).unsigned = false;
                        else if (typeof object.creationTime === "string")
                            message.creationTime = parseInt(object.creationTime, 10);
                        else if (typeof object.creationTime === "number")
                            message.creationTime = object.creationTime;
                        else if (typeof object.creationTime === "object")
                            message.creationTime = new $util.LongBits(object.creationTime.low >>> 0, object.creationTime.high >>> 0).toNumber();
                    if (object.vehicle != null) {
                        if (typeof object.vehicle !== "object")
                            throw TypeError(".havocai.messages.v0.GeoImage.vehicle: object expected");
                        message.vehicle = $root.havocai.messages.v0.ResourceRef.fromObject(object.vehicle);
                    }
                    if (object.sourcePath != null)
                        message.sourcePath = String(object.sourcePath);
                    if (object.referencePosition != null) {
                        if (typeof object.referencePosition !== "object")
                            throw TypeError(".havocai.messages.v0.GeoImage.referencePosition: object expected");
                        message.referencePosition = $root.havocai.messages.v0.GeoPoint.fromObject(object.referencePosition);
                    }
                    if (object.bearing != null)
                        message.bearing = Number(object.bearing);
                    if (object.horizontalFov != null)
                        message.horizontalFov = Number(object.horizontalFov);
                    if (object.verticalFov != null)
                        message.verticalFov = Number(object.verticalFov);
                    if (object.focalLength != null)
                        message.focalLength = Number(object.focalLength);
                    return message;
                };

                /**
                 * Creates a plain object from a GeoImage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.GeoImage
                 * @static
                 * @param {havocai.messages.v0.GeoImage} message GeoImage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GeoImage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.uri = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.creationTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.creationTime = options.longs === String ? "0" : 0;
                        object.sourcePath = "";
                        object.referencePosition = null;
                        object.bearing = 0;
                        object.horizontalFov = 0;
                        object.verticalFov = 0;
                        object.focalLength = 0;
                        object.vehicle = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        object.uri = message.uri;
                    if (message.creationTime != null && message.hasOwnProperty("creationTime"))
                        if (typeof message.creationTime === "number")
                            object.creationTime = options.longs === String ? String(message.creationTime) : message.creationTime;
                        else
                            object.creationTime = options.longs === String ? $util.Long.prototype.toString.call(message.creationTime) : options.longs === Number ? new $util.LongBits(message.creationTime.low >>> 0, message.creationTime.high >>> 0).toNumber() : message.creationTime;
                    if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                        object.sourcePath = message.sourcePath;
                    if (message.referencePosition != null && message.hasOwnProperty("referencePosition"))
                        object.referencePosition = $root.havocai.messages.v0.GeoPoint.toObject(message.referencePosition, options);
                    if (message.bearing != null && message.hasOwnProperty("bearing"))
                        object.bearing = options.json && !isFinite(message.bearing) ? String(message.bearing) : message.bearing;
                    if (message.horizontalFov != null && message.hasOwnProperty("horizontalFov"))
                        object.horizontalFov = options.json && !isFinite(message.horizontalFov) ? String(message.horizontalFov) : message.horizontalFov;
                    if (message.verticalFov != null && message.hasOwnProperty("verticalFov"))
                        object.verticalFov = options.json && !isFinite(message.verticalFov) ? String(message.verticalFov) : message.verticalFov;
                    if (message.focalLength != null && message.hasOwnProperty("focalLength"))
                        object.focalLength = options.json && !isFinite(message.focalLength) ? String(message.focalLength) : message.focalLength;
                    if (message.vehicle != null && message.hasOwnProperty("vehicle"))
                        object.vehicle = $root.havocai.messages.v0.ResourceRef.toObject(message.vehicle, options);
                    return object;
                };

                /**
                 * Converts this GeoImage to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.GeoImage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GeoImage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for GeoImage
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.GeoImage
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                GeoImage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.GeoImage";
                };

                return GeoImage;
            })();

            v0.SectorMarkerRef = (function() {

                /**
                 * Properties of a SectorMarkerRef.
                 * @memberof havocai.messages.v0
                 * @interface ISectorMarkerRef
                 * @property {string|null} [sectorId] SectorMarkerRef sectorId
                 * @property {string|null} [markerId] SectorMarkerRef markerId
                 */

                /**
                 * Constructs a new SectorMarkerRef.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a SectorMarkerRef.
                 * @implements ISectorMarkerRef
                 * @constructor
                 * @param {havocai.messages.v0.ISectorMarkerRef=} [properties] Properties to set
                 */
                function SectorMarkerRef(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SectorMarkerRef sectorId.
                 * @member {string} sectorId
                 * @memberof havocai.messages.v0.SectorMarkerRef
                 * @instance
                 */
                SectorMarkerRef.prototype.sectorId = "";

                /**
                 * SectorMarkerRef markerId.
                 * @member {string} markerId
                 * @memberof havocai.messages.v0.SectorMarkerRef
                 * @instance
                 */
                SectorMarkerRef.prototype.markerId = "";

                /**
                 * Creates a new SectorMarkerRef instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.SectorMarkerRef
                 * @static
                 * @param {havocai.messages.v0.ISectorMarkerRef=} [properties] Properties to set
                 * @returns {havocai.messages.v0.SectorMarkerRef} SectorMarkerRef instance
                 */
                SectorMarkerRef.create = function create(properties) {
                    return new SectorMarkerRef(properties);
                };

                /**
                 * Encodes the specified SectorMarkerRef message. Does not implicitly {@link havocai.messages.v0.SectorMarkerRef.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.SectorMarkerRef
                 * @static
                 * @param {havocai.messages.v0.ISectorMarkerRef} message SectorMarkerRef message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SectorMarkerRef.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sectorId != null && Object.hasOwnProperty.call(message, "sectorId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.sectorId);
                    if (message.markerId != null && Object.hasOwnProperty.call(message, "markerId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.markerId);
                    return writer;
                };

                /**
                 * Encodes the specified SectorMarkerRef message, length delimited. Does not implicitly {@link havocai.messages.v0.SectorMarkerRef.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.SectorMarkerRef
                 * @static
                 * @param {havocai.messages.v0.ISectorMarkerRef} message SectorMarkerRef message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SectorMarkerRef.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SectorMarkerRef message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.SectorMarkerRef
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.SectorMarkerRef} SectorMarkerRef
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SectorMarkerRef.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.SectorMarkerRef();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.sectorId = reader.string();
                                break;
                            }
                        case 2: {
                                message.markerId = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SectorMarkerRef message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.SectorMarkerRef
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.SectorMarkerRef} SectorMarkerRef
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SectorMarkerRef.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SectorMarkerRef message.
                 * @function verify
                 * @memberof havocai.messages.v0.SectorMarkerRef
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SectorMarkerRef.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sectorId != null && message.hasOwnProperty("sectorId"))
                        if (!$util.isString(message.sectorId))
                            return "sectorId: string expected";
                    if (message.markerId != null && message.hasOwnProperty("markerId"))
                        if (!$util.isString(message.markerId))
                            return "markerId: string expected";
                    return null;
                };

                /**
                 * Creates a SectorMarkerRef message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.SectorMarkerRef
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.SectorMarkerRef} SectorMarkerRef
                 */
                SectorMarkerRef.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.SectorMarkerRef)
                        return object;
                    let message = new $root.havocai.messages.v0.SectorMarkerRef();
                    if (object.sectorId != null)
                        message.sectorId = String(object.sectorId);
                    if (object.markerId != null)
                        message.markerId = String(object.markerId);
                    return message;
                };

                /**
                 * Creates a plain object from a SectorMarkerRef message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.SectorMarkerRef
                 * @static
                 * @param {havocai.messages.v0.SectorMarkerRef} message SectorMarkerRef
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SectorMarkerRef.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.sectorId = "";
                        object.markerId = "";
                    }
                    if (message.sectorId != null && message.hasOwnProperty("sectorId"))
                        object.sectorId = message.sectorId;
                    if (message.markerId != null && message.hasOwnProperty("markerId"))
                        object.markerId = message.markerId;
                    return object;
                };

                /**
                 * Converts this SectorMarkerRef to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.SectorMarkerRef
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SectorMarkerRef.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SectorMarkerRef
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.SectorMarkerRef
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SectorMarkerRef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.SectorMarkerRef";
                };

                return SectorMarkerRef;
            })();

            v0.ZoneMarkerRef = (function() {

                /**
                 * Properties of a ZoneMarkerRef.
                 * @memberof havocai.messages.v0
                 * @interface IZoneMarkerRef
                 * @property {string|null} [zoneId] ZoneMarkerRef zoneId
                 * @property {string|null} [markerId] ZoneMarkerRef markerId
                 */

                /**
                 * Constructs a new ZoneMarkerRef.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a ZoneMarkerRef.
                 * @implements IZoneMarkerRef
                 * @constructor
                 * @param {havocai.messages.v0.IZoneMarkerRef=} [properties] Properties to set
                 */
                function ZoneMarkerRef(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ZoneMarkerRef zoneId.
                 * @member {string} zoneId
                 * @memberof havocai.messages.v0.ZoneMarkerRef
                 * @instance
                 */
                ZoneMarkerRef.prototype.zoneId = "";

                /**
                 * ZoneMarkerRef markerId.
                 * @member {string} markerId
                 * @memberof havocai.messages.v0.ZoneMarkerRef
                 * @instance
                 */
                ZoneMarkerRef.prototype.markerId = "";

                /**
                 * Creates a new ZoneMarkerRef instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.ZoneMarkerRef
                 * @static
                 * @param {havocai.messages.v0.IZoneMarkerRef=} [properties] Properties to set
                 * @returns {havocai.messages.v0.ZoneMarkerRef} ZoneMarkerRef instance
                 */
                ZoneMarkerRef.create = function create(properties) {
                    return new ZoneMarkerRef(properties);
                };

                /**
                 * Encodes the specified ZoneMarkerRef message. Does not implicitly {@link havocai.messages.v0.ZoneMarkerRef.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.ZoneMarkerRef
                 * @static
                 * @param {havocai.messages.v0.IZoneMarkerRef} message ZoneMarkerRef message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ZoneMarkerRef.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.zoneId != null && Object.hasOwnProperty.call(message, "zoneId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.zoneId);
                    if (message.markerId != null && Object.hasOwnProperty.call(message, "markerId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.markerId);
                    return writer;
                };

                /**
                 * Encodes the specified ZoneMarkerRef message, length delimited. Does not implicitly {@link havocai.messages.v0.ZoneMarkerRef.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.ZoneMarkerRef
                 * @static
                 * @param {havocai.messages.v0.IZoneMarkerRef} message ZoneMarkerRef message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ZoneMarkerRef.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ZoneMarkerRef message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.ZoneMarkerRef
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.ZoneMarkerRef} ZoneMarkerRef
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ZoneMarkerRef.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.ZoneMarkerRef();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.zoneId = reader.string();
                                break;
                            }
                        case 2: {
                                message.markerId = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ZoneMarkerRef message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.ZoneMarkerRef
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.ZoneMarkerRef} ZoneMarkerRef
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ZoneMarkerRef.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ZoneMarkerRef message.
                 * @function verify
                 * @memberof havocai.messages.v0.ZoneMarkerRef
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ZoneMarkerRef.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.zoneId != null && message.hasOwnProperty("zoneId"))
                        if (!$util.isString(message.zoneId))
                            return "zoneId: string expected";
                    if (message.markerId != null && message.hasOwnProperty("markerId"))
                        if (!$util.isString(message.markerId))
                            return "markerId: string expected";
                    return null;
                };

                /**
                 * Creates a ZoneMarkerRef message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.ZoneMarkerRef
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.ZoneMarkerRef} ZoneMarkerRef
                 */
                ZoneMarkerRef.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.ZoneMarkerRef)
                        return object;
                    let message = new $root.havocai.messages.v0.ZoneMarkerRef();
                    if (object.zoneId != null)
                        message.zoneId = String(object.zoneId);
                    if (object.markerId != null)
                        message.markerId = String(object.markerId);
                    return message;
                };

                /**
                 * Creates a plain object from a ZoneMarkerRef message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.ZoneMarkerRef
                 * @static
                 * @param {havocai.messages.v0.ZoneMarkerRef} message ZoneMarkerRef
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ZoneMarkerRef.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.zoneId = "";
                        object.markerId = "";
                    }
                    if (message.zoneId != null && message.hasOwnProperty("zoneId"))
                        object.zoneId = message.zoneId;
                    if (message.markerId != null && message.hasOwnProperty("markerId"))
                        object.markerId = message.markerId;
                    return object;
                };

                /**
                 * Converts this ZoneMarkerRef to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.ZoneMarkerRef
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ZoneMarkerRef.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ZoneMarkerRef
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.ZoneMarkerRef
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ZoneMarkerRef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.ZoneMarkerRef";
                };

                return ZoneMarkerRef;
            })();

            v0.Polygon = (function() {

                /**
                 * Properties of a Polygon.
                 * @memberof havocai.messages.v0
                 * @interface IPolygon
                 * @property {Array.<havocai.messages.v0.IGeoPoint>|null} [geoPoints] Polygon geoPoints
                 */

                /**
                 * Constructs a new Polygon.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Polygon.
                 * @implements IPolygon
                 * @constructor
                 * @param {havocai.messages.v0.IPolygon=} [properties] Properties to set
                 */
                function Polygon(properties) {
                    this.geoPoints = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Polygon geoPoints.
                 * @member {Array.<havocai.messages.v0.IGeoPoint>} geoPoints
                 * @memberof havocai.messages.v0.Polygon
                 * @instance
                 */
                Polygon.prototype.geoPoints = $util.emptyArray;

                /**
                 * Creates a new Polygon instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Polygon
                 * @static
                 * @param {havocai.messages.v0.IPolygon=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Polygon} Polygon instance
                 */
                Polygon.create = function create(properties) {
                    return new Polygon(properties);
                };

                /**
                 * Encodes the specified Polygon message. Does not implicitly {@link havocai.messages.v0.Polygon.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Polygon
                 * @static
                 * @param {havocai.messages.v0.IPolygon} message Polygon message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Polygon.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.geoPoints != null && message.geoPoints.length)
                        for (let i = 0; i < message.geoPoints.length; ++i)
                            $root.havocai.messages.v0.GeoPoint.encode(message.geoPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Polygon message, length delimited. Does not implicitly {@link havocai.messages.v0.Polygon.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Polygon
                 * @static
                 * @param {havocai.messages.v0.IPolygon} message Polygon message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Polygon.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Polygon message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Polygon
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Polygon} Polygon
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Polygon.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Polygon();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.geoPoints && message.geoPoints.length))
                                    message.geoPoints = [];
                                message.geoPoints.push($root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Polygon message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Polygon
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Polygon} Polygon
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Polygon.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Polygon message.
                 * @function verify
                 * @memberof havocai.messages.v0.Polygon
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Polygon.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.geoPoints != null && message.hasOwnProperty("geoPoints")) {
                        if (!Array.isArray(message.geoPoints))
                            return "geoPoints: array expected";
                        for (let i = 0; i < message.geoPoints.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoPoint.verify(message.geoPoints[i]);
                            if (error)
                                return "geoPoints." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Polygon message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Polygon
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Polygon} Polygon
                 */
                Polygon.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Polygon)
                        return object;
                    let message = new $root.havocai.messages.v0.Polygon();
                    if (object.geoPoints) {
                        if (!Array.isArray(object.geoPoints))
                            throw TypeError(".havocai.messages.v0.Polygon.geoPoints: array expected");
                        message.geoPoints = [];
                        for (let i = 0; i < object.geoPoints.length; ++i) {
                            if (typeof object.geoPoints[i] !== "object")
                                throw TypeError(".havocai.messages.v0.Polygon.geoPoints: object expected");
                            message.geoPoints[i] = $root.havocai.messages.v0.GeoPoint.fromObject(object.geoPoints[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Polygon message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Polygon
                 * @static
                 * @param {havocai.messages.v0.Polygon} message Polygon
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Polygon.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.geoPoints = [];
                    if (message.geoPoints && message.geoPoints.length) {
                        object.geoPoints = [];
                        for (let j = 0; j < message.geoPoints.length; ++j)
                            object.geoPoints[j] = $root.havocai.messages.v0.GeoPoint.toObject(message.geoPoints[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Polygon to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Polygon
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Polygon.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Polygon
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Polygon
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Polygon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Polygon";
                };

                return Polygon;
            })();

            v0.RouteWaypoint = (function() {

                /**
                 * Properties of a RouteWaypoint.
                 * @memberof havocai.messages.v0
                 * @interface IRouteWaypoint
                 * @property {havocai.messages.v0.ISectorMarkerRef|null} [sectorMarker] RouteWaypoint sectorMarker
                 * @property {havocai.messages.v0.IGeoPoint|null} [geoPoint] RouteWaypoint geoPoint
                 * @property {number|null} [targetSpeed] RouteWaypoint targetSpeed
                 * @property {number|null} [crossTrackErrorMax] RouteWaypoint crossTrackErrorMax
                 */

                /**
                 * Constructs a new RouteWaypoint.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a RouteWaypoint.
                 * @implements IRouteWaypoint
                 * @constructor
                 * @param {havocai.messages.v0.IRouteWaypoint=} [properties] Properties to set
                 */
                function RouteWaypoint(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RouteWaypoint sectorMarker.
                 * @member {havocai.messages.v0.ISectorMarkerRef|null|undefined} sectorMarker
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @instance
                 */
                RouteWaypoint.prototype.sectorMarker = null;

                /**
                 * RouteWaypoint geoPoint.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} geoPoint
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @instance
                 */
                RouteWaypoint.prototype.geoPoint = null;

                /**
                 * RouteWaypoint targetSpeed.
                 * @member {number} targetSpeed
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @instance
                 */
                RouteWaypoint.prototype.targetSpeed = 0;

                /**
                 * RouteWaypoint crossTrackErrorMax.
                 * @member {number} crossTrackErrorMax
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @instance
                 */
                RouteWaypoint.prototype.crossTrackErrorMax = 0;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * RouteWaypoint location.
                 * @member {"sectorMarker"|"geoPoint"|undefined} location
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @instance
                 */
                Object.defineProperty(RouteWaypoint.prototype, "location", {
                    get: $util.oneOfGetter($oneOfFields = ["sectorMarker", "geoPoint"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new RouteWaypoint instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @static
                 * @param {havocai.messages.v0.IRouteWaypoint=} [properties] Properties to set
                 * @returns {havocai.messages.v0.RouteWaypoint} RouteWaypoint instance
                 */
                RouteWaypoint.create = function create(properties) {
                    return new RouteWaypoint(properties);
                };

                /**
                 * Encodes the specified RouteWaypoint message. Does not implicitly {@link havocai.messages.v0.RouteWaypoint.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @static
                 * @param {havocai.messages.v0.IRouteWaypoint} message RouteWaypoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RouteWaypoint.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sectorMarker != null && Object.hasOwnProperty.call(message, "sectorMarker"))
                        $root.havocai.messages.v0.SectorMarkerRef.encode(message.sectorMarker, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.geoPoint != null && Object.hasOwnProperty.call(message, "geoPoint"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.geoPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.targetSpeed != null && Object.hasOwnProperty.call(message, "targetSpeed"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.targetSpeed);
                    if (message.crossTrackErrorMax != null && Object.hasOwnProperty.call(message, "crossTrackErrorMax"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.crossTrackErrorMax);
                    return writer;
                };

                /**
                 * Encodes the specified RouteWaypoint message, length delimited. Does not implicitly {@link havocai.messages.v0.RouteWaypoint.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @static
                 * @param {havocai.messages.v0.IRouteWaypoint} message RouteWaypoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RouteWaypoint.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RouteWaypoint message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.RouteWaypoint} RouteWaypoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RouteWaypoint.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.RouteWaypoint();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.sectorMarker = $root.havocai.messages.v0.SectorMarkerRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.geoPoint = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.targetSpeed = reader.float();
                                break;
                            }
                        case 4: {
                                message.crossTrackErrorMax = reader.float();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RouteWaypoint message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.RouteWaypoint} RouteWaypoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RouteWaypoint.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RouteWaypoint message.
                 * @function verify
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RouteWaypoint.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.sectorMarker != null && message.hasOwnProperty("sectorMarker")) {
                        properties.location = 1;
                        {
                            let error = $root.havocai.messages.v0.SectorMarkerRef.verify(message.sectorMarker);
                            if (error)
                                return "sectorMarker." + error;
                        }
                    }
                    if (message.geoPoint != null && message.hasOwnProperty("geoPoint")) {
                        if (properties.location === 1)
                            return "location: multiple values";
                        properties.location = 1;
                        {
                            let error = $root.havocai.messages.v0.GeoPoint.verify(message.geoPoint);
                            if (error)
                                return "geoPoint." + error;
                        }
                    }
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        if (typeof message.targetSpeed !== "number")
                            return "targetSpeed: number expected";
                    if (message.crossTrackErrorMax != null && message.hasOwnProperty("crossTrackErrorMax"))
                        if (typeof message.crossTrackErrorMax !== "number")
                            return "crossTrackErrorMax: number expected";
                    return null;
                };

                /**
                 * Creates a RouteWaypoint message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.RouteWaypoint} RouteWaypoint
                 */
                RouteWaypoint.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.RouteWaypoint)
                        return object;
                    let message = new $root.havocai.messages.v0.RouteWaypoint();
                    if (object.sectorMarker != null) {
                        if (typeof object.sectorMarker !== "object")
                            throw TypeError(".havocai.messages.v0.RouteWaypoint.sectorMarker: object expected");
                        message.sectorMarker = $root.havocai.messages.v0.SectorMarkerRef.fromObject(object.sectorMarker);
                    }
                    if (object.geoPoint != null) {
                        if (typeof object.geoPoint !== "object")
                            throw TypeError(".havocai.messages.v0.RouteWaypoint.geoPoint: object expected");
                        message.geoPoint = $root.havocai.messages.v0.GeoPoint.fromObject(object.geoPoint);
                    }
                    if (object.targetSpeed != null)
                        message.targetSpeed = Number(object.targetSpeed);
                    if (object.crossTrackErrorMax != null)
                        message.crossTrackErrorMax = Number(object.crossTrackErrorMax);
                    return message;
                };

                /**
                 * Creates a plain object from a RouteWaypoint message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @static
                 * @param {havocai.messages.v0.RouteWaypoint} message RouteWaypoint
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RouteWaypoint.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.targetSpeed = 0;
                        object.crossTrackErrorMax = 0;
                    }
                    if (message.sectorMarker != null && message.hasOwnProperty("sectorMarker")) {
                        object.sectorMarker = $root.havocai.messages.v0.SectorMarkerRef.toObject(message.sectorMarker, options);
                        if (options.oneofs)
                            object.location = "sectorMarker";
                    }
                    if (message.geoPoint != null && message.hasOwnProperty("geoPoint")) {
                        object.geoPoint = $root.havocai.messages.v0.GeoPoint.toObject(message.geoPoint, options);
                        if (options.oneofs)
                            object.location = "geoPoint";
                    }
                    if (message.targetSpeed != null && message.hasOwnProperty("targetSpeed"))
                        object.targetSpeed = options.json && !isFinite(message.targetSpeed) ? String(message.targetSpeed) : message.targetSpeed;
                    if (message.crossTrackErrorMax != null && message.hasOwnProperty("crossTrackErrorMax"))
                        object.crossTrackErrorMax = options.json && !isFinite(message.crossTrackErrorMax) ? String(message.crossTrackErrorMax) : message.crossTrackErrorMax;
                    return object;
                };

                /**
                 * Converts this RouteWaypoint to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RouteWaypoint.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for RouteWaypoint
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.RouteWaypoint
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                RouteWaypoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.RouteWaypoint";
                };

                return RouteWaypoint;
            })();

            v0.Route = (function() {

                /**
                 * Properties of a Route.
                 * @memberof havocai.messages.v0
                 * @interface IRoute
                 * @property {Array.<havocai.messages.v0.IRouteWaypoint>|null} [waypoints] Route waypoints
                 */

                /**
                 * Constructs a new Route.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Route.
                 * @implements IRoute
                 * @constructor
                 * @param {havocai.messages.v0.IRoute=} [properties] Properties to set
                 */
                function Route(properties) {
                    this.waypoints = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Route waypoints.
                 * @member {Array.<havocai.messages.v0.IRouteWaypoint>} waypoints
                 * @memberof havocai.messages.v0.Route
                 * @instance
                 */
                Route.prototype.waypoints = $util.emptyArray;

                /**
                 * Creates a new Route instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Route
                 * @static
                 * @param {havocai.messages.v0.IRoute=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Route} Route instance
                 */
                Route.create = function create(properties) {
                    return new Route(properties);
                };

                /**
                 * Encodes the specified Route message. Does not implicitly {@link havocai.messages.v0.Route.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Route
                 * @static
                 * @param {havocai.messages.v0.IRoute} message Route message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Route.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.waypoints != null && message.waypoints.length)
                        for (let i = 0; i < message.waypoints.length; ++i)
                            $root.havocai.messages.v0.RouteWaypoint.encode(message.waypoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Route message, length delimited. Does not implicitly {@link havocai.messages.v0.Route.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Route
                 * @static
                 * @param {havocai.messages.v0.IRoute} message Route message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Route.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Route message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Route
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Route} Route
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Route.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Route();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.waypoints && message.waypoints.length))
                                    message.waypoints = [];
                                message.waypoints.push($root.havocai.messages.v0.RouteWaypoint.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Route message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Route
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Route} Route
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Route.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Route message.
                 * @function verify
                 * @memberof havocai.messages.v0.Route
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Route.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.waypoints != null && message.hasOwnProperty("waypoints")) {
                        if (!Array.isArray(message.waypoints))
                            return "waypoints: array expected";
                        for (let i = 0; i < message.waypoints.length; ++i) {
                            let error = $root.havocai.messages.v0.RouteWaypoint.verify(message.waypoints[i]);
                            if (error)
                                return "waypoints." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Route message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Route
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Route} Route
                 */
                Route.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Route)
                        return object;
                    let message = new $root.havocai.messages.v0.Route();
                    if (object.waypoints) {
                        if (!Array.isArray(object.waypoints))
                            throw TypeError(".havocai.messages.v0.Route.waypoints: array expected");
                        message.waypoints = [];
                        for (let i = 0; i < object.waypoints.length; ++i) {
                            if (typeof object.waypoints[i] !== "object")
                                throw TypeError(".havocai.messages.v0.Route.waypoints: object expected");
                            message.waypoints[i] = $root.havocai.messages.v0.RouteWaypoint.fromObject(object.waypoints[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Route message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Route
                 * @static
                 * @param {havocai.messages.v0.Route} message Route
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Route.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.waypoints = [];
                    if (message.waypoints && message.waypoints.length) {
                        object.waypoints = [];
                        for (let j = 0; j < message.waypoints.length; ++j)
                            object.waypoints[j] = $root.havocai.messages.v0.RouteWaypoint.toObject(message.waypoints[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Route to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Route
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Route.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Route
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Route
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Route.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Route";
                };

                return Route;
            })();

            v0.Rule = (function() {

                /**
                 * Properties of a Rule.
                 * @memberof havocai.messages.v0
                 * @interface IRule
                 * @property {Array.<havocai.messages.v0.ResourceKind>|null} [resourceKinds] Rule resourceKinds
                 * @property {Array.<string>|null} [resourceIds] Rule resourceIds
                 * @property {Array.<string>|null} [verbs] Rule verbs
                 */

                /**
                 * Constructs a new Rule.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Rule.
                 * @implements IRule
                 * @constructor
                 * @param {havocai.messages.v0.IRule=} [properties] Properties to set
                 */
                function Rule(properties) {
                    this.resourceKinds = [];
                    this.resourceIds = [];
                    this.verbs = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Rule resourceKinds.
                 * @member {Array.<havocai.messages.v0.ResourceKind>} resourceKinds
                 * @memberof havocai.messages.v0.Rule
                 * @instance
                 */
                Rule.prototype.resourceKinds = $util.emptyArray;

                /**
                 * Rule resourceIds.
                 * @member {Array.<string>} resourceIds
                 * @memberof havocai.messages.v0.Rule
                 * @instance
                 */
                Rule.prototype.resourceIds = $util.emptyArray;

                /**
                 * Rule verbs.
                 * @member {Array.<string>} verbs
                 * @memberof havocai.messages.v0.Rule
                 * @instance
                 */
                Rule.prototype.verbs = $util.emptyArray;

                /**
                 * Creates a new Rule instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Rule
                 * @static
                 * @param {havocai.messages.v0.IRule=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Rule} Rule instance
                 */
                Rule.create = function create(properties) {
                    return new Rule(properties);
                };

                /**
                 * Encodes the specified Rule message. Does not implicitly {@link havocai.messages.v0.Rule.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Rule
                 * @static
                 * @param {havocai.messages.v0.IRule} message Rule message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Rule.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resourceKinds != null && message.resourceKinds.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.resourceKinds.length; ++i)
                            writer.int32(message.resourceKinds[i]);
                        writer.ldelim();
                    }
                    if (message.resourceIds != null && message.resourceIds.length)
                        for (let i = 0; i < message.resourceIds.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.resourceIds[i]);
                    if (message.verbs != null && message.verbs.length)
                        for (let i = 0; i < message.verbs.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.verbs[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Rule message, length delimited. Does not implicitly {@link havocai.messages.v0.Rule.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Rule
                 * @static
                 * @param {havocai.messages.v0.IRule} message Rule message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Rule.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Rule message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Rule
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Rule} Rule
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Rule.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Rule();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.resourceKinds && message.resourceKinds.length))
                                    message.resourceKinds = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.resourceKinds.push(reader.int32());
                                } else
                                    message.resourceKinds.push(reader.int32());
                                break;
                            }
                        case 2: {
                                if (!(message.resourceIds && message.resourceIds.length))
                                    message.resourceIds = [];
                                message.resourceIds.push(reader.string());
                                break;
                            }
                        case 3: {
                                if (!(message.verbs && message.verbs.length))
                                    message.verbs = [];
                                message.verbs.push(reader.string());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Rule message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Rule
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Rule} Rule
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Rule.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Rule message.
                 * @function verify
                 * @memberof havocai.messages.v0.Rule
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Rule.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resourceKinds != null && message.hasOwnProperty("resourceKinds")) {
                        if (!Array.isArray(message.resourceKinds))
                            return "resourceKinds: array expected";
                        for (let i = 0; i < message.resourceKinds.length; ++i)
                            switch (message.resourceKinds[i]) {
                            default:
                                return "resourceKinds: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                                break;
                            }
                    }
                    if (message.resourceIds != null && message.hasOwnProperty("resourceIds")) {
                        if (!Array.isArray(message.resourceIds))
                            return "resourceIds: array expected";
                        for (let i = 0; i < message.resourceIds.length; ++i)
                            if (!$util.isString(message.resourceIds[i]))
                                return "resourceIds: string[] expected";
                    }
                    if (message.verbs != null && message.hasOwnProperty("verbs")) {
                        if (!Array.isArray(message.verbs))
                            return "verbs: array expected";
                        for (let i = 0; i < message.verbs.length; ++i)
                            if (!$util.isString(message.verbs[i]))
                                return "verbs: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Rule message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Rule
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Rule} Rule
                 */
                Rule.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Rule)
                        return object;
                    let message = new $root.havocai.messages.v0.Rule();
                    if (object.resourceKinds) {
                        if (!Array.isArray(object.resourceKinds))
                            throw TypeError(".havocai.messages.v0.Rule.resourceKinds: array expected");
                        message.resourceKinds = [];
                        for (let i = 0; i < object.resourceKinds.length; ++i)
                            switch (object.resourceKinds[i]) {
                            default:
                                if (typeof object.resourceKinds[i] === "number") {
                                    message.resourceKinds[i] = object.resourceKinds[i];
                                    break;
                                }
                            case "RESOURCE_KIND_UNKNOWN":
                            case 0:
                                message.resourceKinds[i] = 0;
                                break;
                            case "RESOURCE_KIND_SECTOR":
                            case 1:
                                message.resourceKinds[i] = 1;
                                break;
                            case "RESOURCE_KIND_ZONE":
                            case 2:
                                message.resourceKinds[i] = 2;
                                break;
                            case "RESOURCE_KIND_TEAM":
                            case 3:
                                message.resourceKinds[i] = 3;
                                break;
                            case "RESOURCE_KIND_BOAT":
                            case 4:
                                message.resourceKinds[i] = 4;
                                break;
                            case "RESOURCE_KIND_TRACK":
                            case 6:
                                message.resourceKinds[i] = 6;
                                break;
                            case "RESOURCE_KIND_PLAY_DEFINITION":
                            case 7:
                                message.resourceKinds[i] = 7;
                                break;
                            case "RESOURCE_KIND_PLAY_EXECUTION":
                            case 8:
                                message.resourceKinds[i] = 8;
                                break;
                            case "RESOURCE_KIND_PLAY_RUNNER":
                            case 9:
                                message.resourceKinds[i] = 9;
                                break;
                            case "RESOURCE_KIND_SIMULATION":
                            case 10:
                                message.resourceKinds[i] = 10;
                                break;
                            }
                    }
                    if (object.resourceIds) {
                        if (!Array.isArray(object.resourceIds))
                            throw TypeError(".havocai.messages.v0.Rule.resourceIds: array expected");
                        message.resourceIds = [];
                        for (let i = 0; i < object.resourceIds.length; ++i)
                            message.resourceIds[i] = String(object.resourceIds[i]);
                    }
                    if (object.verbs) {
                        if (!Array.isArray(object.verbs))
                            throw TypeError(".havocai.messages.v0.Rule.verbs: array expected");
                        message.verbs = [];
                        for (let i = 0; i < object.verbs.length; ++i)
                            message.verbs[i] = String(object.verbs[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Rule message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Rule
                 * @static
                 * @param {havocai.messages.v0.Rule} message Rule
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Rule.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.resourceKinds = [];
                        object.resourceIds = [];
                        object.verbs = [];
                    }
                    if (message.resourceKinds && message.resourceKinds.length) {
                        object.resourceKinds = [];
                        for (let j = 0; j < message.resourceKinds.length; ++j)
                            object.resourceKinds[j] = options.enums === String ? $root.havocai.messages.v0.ResourceKind[message.resourceKinds[j]] === undefined ? message.resourceKinds[j] : $root.havocai.messages.v0.ResourceKind[message.resourceKinds[j]] : message.resourceKinds[j];
                    }
                    if (message.resourceIds && message.resourceIds.length) {
                        object.resourceIds = [];
                        for (let j = 0; j < message.resourceIds.length; ++j)
                            object.resourceIds[j] = message.resourceIds[j];
                    }
                    if (message.verbs && message.verbs.length) {
                        object.verbs = [];
                        for (let j = 0; j < message.verbs.length; ++j)
                            object.verbs[j] = message.verbs[j];
                    }
                    return object;
                };

                /**
                 * Converts this Rule to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Rule
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Rule.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Rule
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Rule
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Rule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Rule";
                };

                return Rule;
            })();

            v0.ExecuteCommand = (function() {

                /**
                 * Properties of an ExecuteCommand.
                 * @memberof havocai.messages.v0
                 * @interface IExecuteCommand
                 * @property {havocai.messages.v0.Command|null} [command] ExecuteCommand command
                 * @property {string|null} [taskExecutionId] ExecuteCommand taskExecutionId
                 */

                /**
                 * Constructs a new ExecuteCommand.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents an ExecuteCommand.
                 * @implements IExecuteCommand
                 * @constructor
                 * @param {havocai.messages.v0.IExecuteCommand=} [properties] Properties to set
                 */
                function ExecuteCommand(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExecuteCommand command.
                 * @member {havocai.messages.v0.Command} command
                 * @memberof havocai.messages.v0.ExecuteCommand
                 * @instance
                 */
                ExecuteCommand.prototype.command = 0;

                /**
                 * ExecuteCommand taskExecutionId.
                 * @member {string} taskExecutionId
                 * @memberof havocai.messages.v0.ExecuteCommand
                 * @instance
                 */
                ExecuteCommand.prototype.taskExecutionId = "";

                /**
                 * Creates a new ExecuteCommand instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.ExecuteCommand
                 * @static
                 * @param {havocai.messages.v0.IExecuteCommand=} [properties] Properties to set
                 * @returns {havocai.messages.v0.ExecuteCommand} ExecuteCommand instance
                 */
                ExecuteCommand.create = function create(properties) {
                    return new ExecuteCommand(properties);
                };

                /**
                 * Encodes the specified ExecuteCommand message. Does not implicitly {@link havocai.messages.v0.ExecuteCommand.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.ExecuteCommand
                 * @static
                 * @param {havocai.messages.v0.IExecuteCommand} message ExecuteCommand message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecuteCommand.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.command);
                    if (message.taskExecutionId != null && Object.hasOwnProperty.call(message, "taskExecutionId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.taskExecutionId);
                    return writer;
                };

                /**
                 * Encodes the specified ExecuteCommand message, length delimited. Does not implicitly {@link havocai.messages.v0.ExecuteCommand.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.ExecuteCommand
                 * @static
                 * @param {havocai.messages.v0.IExecuteCommand} message ExecuteCommand message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecuteCommand.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExecuteCommand message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.ExecuteCommand
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.ExecuteCommand} ExecuteCommand
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecuteCommand.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.ExecuteCommand();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.command = reader.int32();
                                break;
                            }
                        case 2: {
                                message.taskExecutionId = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExecuteCommand message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.ExecuteCommand
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.ExecuteCommand} ExecuteCommand
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecuteCommand.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExecuteCommand message.
                 * @function verify
                 * @memberof havocai.messages.v0.ExecuteCommand
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecuteCommand.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.command != null && message.hasOwnProperty("command"))
                        switch (message.command) {
                        default:
                            return "command: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    if (message.taskExecutionId != null && message.hasOwnProperty("taskExecutionId"))
                        if (!$util.isString(message.taskExecutionId))
                            return "taskExecutionId: string expected";
                    return null;
                };

                /**
                 * Creates an ExecuteCommand message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.ExecuteCommand
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.ExecuteCommand} ExecuteCommand
                 */
                ExecuteCommand.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.ExecuteCommand)
                        return object;
                    let message = new $root.havocai.messages.v0.ExecuteCommand();
                    switch (object.command) {
                    default:
                        if (typeof object.command === "number") {
                            message.command = object.command;
                            break;
                        }
                        break;
                    case "COMMAND_UNKNOWN":
                    case 0:
                        message.command = 0;
                        break;
                    case "COMMAND_CANCEL":
                    case 1:
                        message.command = 1;
                        break;
                    case "COMMAND_GO":
                    case 2:
                        message.command = 2;
                        break;
                    case "COMMAND_AUTHORIZE":
                    case 3:
                        message.command = 3;
                        break;
                    case "COMMAND_CUSTOM":
                    case 4:
                        message.command = 4;
                        break;
                    case "COMMAND_AUTHORIZE_TASK":
                    case 5:
                        message.command = 5;
                        break;
                    case "COMMAND_EXECUTE_TASK":
                    case 6:
                        message.command = 6;
                        break;
                    case "COMMAND_TRIGGER_PAYLOAD":
                    case 7:
                        message.command = 7;
                        break;
                    }
                    if (object.taskExecutionId != null)
                        message.taskExecutionId = String(object.taskExecutionId);
                    return message;
                };

                /**
                 * Creates a plain object from an ExecuteCommand message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.ExecuteCommand
                 * @static
                 * @param {havocai.messages.v0.ExecuteCommand} message ExecuteCommand
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExecuteCommand.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.command = options.enums === String ? "COMMAND_UNKNOWN" : 0;
                        object.taskExecutionId = "";
                    }
                    if (message.command != null && message.hasOwnProperty("command"))
                        object.command = options.enums === String ? $root.havocai.messages.v0.Command[message.command] === undefined ? message.command : $root.havocai.messages.v0.Command[message.command] : message.command;
                    if (message.taskExecutionId != null && message.hasOwnProperty("taskExecutionId"))
                        object.taskExecutionId = message.taskExecutionId;
                    return object;
                };

                /**
                 * Converts this ExecuteCommand to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.ExecuteCommand
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExecuteCommand.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ExecuteCommand
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.ExecuteCommand
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ExecuteCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.ExecuteCommand";
                };

                return ExecuteCommand;
            })();

            v0.Sector = (function() {

                /**
                 * Properties of a Sector.
                 * @memberof havocai.messages.v0
                 * @interface ISector
                 * @property {havocai.messages.v0.IMetadata|null} [meta] Sector meta
                 * @property {Array.<havocai.messages.v0.IGeoPoint>|null} [area] Sector area
                 * @property {Array.<havocai.messages.v0.IGeoFence>|null} [geoFences] Sector geoFences
                 * @property {Array.<havocai.messages.v0.IMarker>|null} [markers] Sector markers
                 * @property {havocai.messages.v0.IUser|null} [commandUser] Sector commandUser
                 * @property {havocai.messages.v0.ISectorStatus|null} [status] Sector status
                 */

                /**
                 * Constructs a new Sector.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Sector.
                 * @implements ISector
                 * @constructor
                 * @param {havocai.messages.v0.ISector=} [properties] Properties to set
                 */
                function Sector(properties) {
                    this.area = [];
                    this.geoFences = [];
                    this.markers = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Sector meta.
                 * @member {havocai.messages.v0.IMetadata|null|undefined} meta
                 * @memberof havocai.messages.v0.Sector
                 * @instance
                 */
                Sector.prototype.meta = null;

                /**
                 * Sector area.
                 * @member {Array.<havocai.messages.v0.IGeoPoint>} area
                 * @memberof havocai.messages.v0.Sector
                 * @instance
                 */
                Sector.prototype.area = $util.emptyArray;

                /**
                 * Sector geoFences.
                 * @member {Array.<havocai.messages.v0.IGeoFence>} geoFences
                 * @memberof havocai.messages.v0.Sector
                 * @instance
                 */
                Sector.prototype.geoFences = $util.emptyArray;

                /**
                 * Sector markers.
                 * @member {Array.<havocai.messages.v0.IMarker>} markers
                 * @memberof havocai.messages.v0.Sector
                 * @instance
                 */
                Sector.prototype.markers = $util.emptyArray;

                /**
                 * Sector commandUser.
                 * @member {havocai.messages.v0.IUser|null|undefined} commandUser
                 * @memberof havocai.messages.v0.Sector
                 * @instance
                 */
                Sector.prototype.commandUser = null;

                /**
                 * Sector status.
                 * @member {havocai.messages.v0.ISectorStatus|null|undefined} status
                 * @memberof havocai.messages.v0.Sector
                 * @instance
                 */
                Sector.prototype.status = null;

                /**
                 * Creates a new Sector instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Sector
                 * @static
                 * @param {havocai.messages.v0.ISector=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Sector} Sector instance
                 */
                Sector.create = function create(properties) {
                    return new Sector(properties);
                };

                /**
                 * Encodes the specified Sector message. Does not implicitly {@link havocai.messages.v0.Sector.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Sector
                 * @static
                 * @param {havocai.messages.v0.ISector} message Sector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Sector.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.meta != null && Object.hasOwnProperty.call(message, "meta"))
                        $root.havocai.messages.v0.Metadata.encode(message.meta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.area != null && message.area.length)
                        for (let i = 0; i < message.area.length; ++i)
                            $root.havocai.messages.v0.GeoPoint.encode(message.area[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.geoFences != null && message.geoFences.length)
                        for (let i = 0; i < message.geoFences.length; ++i)
                            $root.havocai.messages.v0.GeoFence.encode(message.geoFences[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.markers != null && message.markers.length)
                        for (let i = 0; i < message.markers.length; ++i)
                            $root.havocai.messages.v0.Marker.encode(message.markers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        $root.havocai.messages.v0.SectorStatus.encode(message.status, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.commandUser != null && Object.hasOwnProperty.call(message, "commandUser"))
                        $root.havocai.messages.v0.User.encode(message.commandUser, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Sector message, length delimited. Does not implicitly {@link havocai.messages.v0.Sector.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Sector
                 * @static
                 * @param {havocai.messages.v0.ISector} message Sector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Sector.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Sector message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Sector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Sector} Sector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Sector.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Sector();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.meta = $root.havocai.messages.v0.Metadata.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                if (!(message.area && message.area.length))
                                    message.area = [];
                                message.area.push($root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                if (!(message.geoFences && message.geoFences.length))
                                    message.geoFences = [];
                                message.geoFences.push($root.havocai.messages.v0.GeoFence.decode(reader, reader.uint32()));
                                break;
                            }
                        case 4: {
                                if (!(message.markers && message.markers.length))
                                    message.markers = [];
                                message.markers.push($root.havocai.messages.v0.Marker.decode(reader, reader.uint32()));
                                break;
                            }
                        case 6: {
                                message.commandUser = $root.havocai.messages.v0.User.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.status = $root.havocai.messages.v0.SectorStatus.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Sector message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Sector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Sector} Sector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Sector.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Sector message.
                 * @function verify
                 * @memberof havocai.messages.v0.Sector
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Sector.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.meta != null && message.hasOwnProperty("meta")) {
                        let error = $root.havocai.messages.v0.Metadata.verify(message.meta);
                        if (error)
                            return "meta." + error;
                    }
                    if (message.area != null && message.hasOwnProperty("area")) {
                        if (!Array.isArray(message.area))
                            return "area: array expected";
                        for (let i = 0; i < message.area.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoPoint.verify(message.area[i]);
                            if (error)
                                return "area." + error;
                        }
                    }
                    if (message.geoFences != null && message.hasOwnProperty("geoFences")) {
                        if (!Array.isArray(message.geoFences))
                            return "geoFences: array expected";
                        for (let i = 0; i < message.geoFences.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoFence.verify(message.geoFences[i]);
                            if (error)
                                return "geoFences." + error;
                        }
                    }
                    if (message.markers != null && message.hasOwnProperty("markers")) {
                        if (!Array.isArray(message.markers))
                            return "markers: array expected";
                        for (let i = 0; i < message.markers.length; ++i) {
                            let error = $root.havocai.messages.v0.Marker.verify(message.markers[i]);
                            if (error)
                                return "markers." + error;
                        }
                    }
                    if (message.commandUser != null && message.hasOwnProperty("commandUser")) {
                        let error = $root.havocai.messages.v0.User.verify(message.commandUser);
                        if (error)
                            return "commandUser." + error;
                    }
                    if (message.status != null && message.hasOwnProperty("status")) {
                        let error = $root.havocai.messages.v0.SectorStatus.verify(message.status);
                        if (error)
                            return "status." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Sector message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Sector
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Sector} Sector
                 */
                Sector.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Sector)
                        return object;
                    let message = new $root.havocai.messages.v0.Sector();
                    if (object.meta != null) {
                        if (typeof object.meta !== "object")
                            throw TypeError(".havocai.messages.v0.Sector.meta: object expected");
                        message.meta = $root.havocai.messages.v0.Metadata.fromObject(object.meta);
                    }
                    if (object.area) {
                        if (!Array.isArray(object.area))
                            throw TypeError(".havocai.messages.v0.Sector.area: array expected");
                        message.area = [];
                        for (let i = 0; i < object.area.length; ++i) {
                            if (typeof object.area[i] !== "object")
                                throw TypeError(".havocai.messages.v0.Sector.area: object expected");
                            message.area[i] = $root.havocai.messages.v0.GeoPoint.fromObject(object.area[i]);
                        }
                    }
                    if (object.geoFences) {
                        if (!Array.isArray(object.geoFences))
                            throw TypeError(".havocai.messages.v0.Sector.geoFences: array expected");
                        message.geoFences = [];
                        for (let i = 0; i < object.geoFences.length; ++i) {
                            if (typeof object.geoFences[i] !== "object")
                                throw TypeError(".havocai.messages.v0.Sector.geoFences: object expected");
                            message.geoFences[i] = $root.havocai.messages.v0.GeoFence.fromObject(object.geoFences[i]);
                        }
                    }
                    if (object.markers) {
                        if (!Array.isArray(object.markers))
                            throw TypeError(".havocai.messages.v0.Sector.markers: array expected");
                        message.markers = [];
                        for (let i = 0; i < object.markers.length; ++i) {
                            if (typeof object.markers[i] !== "object")
                                throw TypeError(".havocai.messages.v0.Sector.markers: object expected");
                            message.markers[i] = $root.havocai.messages.v0.Marker.fromObject(object.markers[i]);
                        }
                    }
                    if (object.commandUser != null) {
                        if (typeof object.commandUser !== "object")
                            throw TypeError(".havocai.messages.v0.Sector.commandUser: object expected");
                        message.commandUser = $root.havocai.messages.v0.User.fromObject(object.commandUser);
                    }
                    if (object.status != null) {
                        if (typeof object.status !== "object")
                            throw TypeError(".havocai.messages.v0.Sector.status: object expected");
                        message.status = $root.havocai.messages.v0.SectorStatus.fromObject(object.status);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Sector message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Sector
                 * @static
                 * @param {havocai.messages.v0.Sector} message Sector
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Sector.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.area = [];
                        object.geoFences = [];
                        object.markers = [];
                    }
                    if (options.defaults) {
                        object.meta = null;
                        object.status = null;
                        object.commandUser = null;
                    }
                    if (message.meta != null && message.hasOwnProperty("meta"))
                        object.meta = $root.havocai.messages.v0.Metadata.toObject(message.meta, options);
                    if (message.area && message.area.length) {
                        object.area = [];
                        for (let j = 0; j < message.area.length; ++j)
                            object.area[j] = $root.havocai.messages.v0.GeoPoint.toObject(message.area[j], options);
                    }
                    if (message.geoFences && message.geoFences.length) {
                        object.geoFences = [];
                        for (let j = 0; j < message.geoFences.length; ++j)
                            object.geoFences[j] = $root.havocai.messages.v0.GeoFence.toObject(message.geoFences[j], options);
                    }
                    if (message.markers && message.markers.length) {
                        object.markers = [];
                        for (let j = 0; j < message.markers.length; ++j)
                            object.markers[j] = $root.havocai.messages.v0.Marker.toObject(message.markers[j], options);
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = $root.havocai.messages.v0.SectorStatus.toObject(message.status, options);
                    if (message.commandUser != null && message.hasOwnProperty("commandUser"))
                        object.commandUser = $root.havocai.messages.v0.User.toObject(message.commandUser, options);
                    return object;
                };

                /**
                 * Converts this Sector to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Sector
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Sector.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Sector
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Sector
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Sector.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Sector";
                };

                return Sector;
            })();

            v0.SectorStatus = (function() {

                /**
                 * Properties of a SectorStatus.
                 * @memberof havocai.messages.v0
                 * @interface ISectorStatus
                 * @property {number|Long|null} [revisionTime] SectorStatus revisionTime
                 * @property {Array.<havocai.messages.v0.IResourceRef>|null} [teams] SectorStatus teams
                 * @property {Array.<havocai.messages.v0.IResourceRef>|null} [assignedBoats] SectorStatus assignedBoats
                 * @property {Array.<havocai.messages.v0.IResourceRef>|null} [unassignedBoats] SectorStatus unassignedBoats
                 */

                /**
                 * Constructs a new SectorStatus.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a SectorStatus.
                 * @implements ISectorStatus
                 * @constructor
                 * @param {havocai.messages.v0.ISectorStatus=} [properties] Properties to set
                 */
                function SectorStatus(properties) {
                    this.teams = [];
                    this.assignedBoats = [];
                    this.unassignedBoats = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SectorStatus revisionTime.
                 * @member {number|Long} revisionTime
                 * @memberof havocai.messages.v0.SectorStatus
                 * @instance
                 */
                SectorStatus.prototype.revisionTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * SectorStatus teams.
                 * @member {Array.<havocai.messages.v0.IResourceRef>} teams
                 * @memberof havocai.messages.v0.SectorStatus
                 * @instance
                 */
                SectorStatus.prototype.teams = $util.emptyArray;

                /**
                 * SectorStatus assignedBoats.
                 * @member {Array.<havocai.messages.v0.IResourceRef>} assignedBoats
                 * @memberof havocai.messages.v0.SectorStatus
                 * @instance
                 */
                SectorStatus.prototype.assignedBoats = $util.emptyArray;

                /**
                 * SectorStatus unassignedBoats.
                 * @member {Array.<havocai.messages.v0.IResourceRef>} unassignedBoats
                 * @memberof havocai.messages.v0.SectorStatus
                 * @instance
                 */
                SectorStatus.prototype.unassignedBoats = $util.emptyArray;

                /**
                 * Creates a new SectorStatus instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.SectorStatus
                 * @static
                 * @param {havocai.messages.v0.ISectorStatus=} [properties] Properties to set
                 * @returns {havocai.messages.v0.SectorStatus} SectorStatus instance
                 */
                SectorStatus.create = function create(properties) {
                    return new SectorStatus(properties);
                };

                /**
                 * Encodes the specified SectorStatus message. Does not implicitly {@link havocai.messages.v0.SectorStatus.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.SectorStatus
                 * @static
                 * @param {havocai.messages.v0.ISectorStatus} message SectorStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SectorStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.revisionTime != null && Object.hasOwnProperty.call(message, "revisionTime"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.revisionTime);
                    if (message.teams != null && message.teams.length)
                        for (let i = 0; i < message.teams.length; ++i)
                            $root.havocai.messages.v0.ResourceRef.encode(message.teams[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.assignedBoats != null && message.assignedBoats.length)
                        for (let i = 0; i < message.assignedBoats.length; ++i)
                            $root.havocai.messages.v0.ResourceRef.encode(message.assignedBoats[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.unassignedBoats != null && message.unassignedBoats.length)
                        for (let i = 0; i < message.unassignedBoats.length; ++i)
                            $root.havocai.messages.v0.ResourceRef.encode(message.unassignedBoats[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SectorStatus message, length delimited. Does not implicitly {@link havocai.messages.v0.SectorStatus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.SectorStatus
                 * @static
                 * @param {havocai.messages.v0.ISectorStatus} message SectorStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SectorStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SectorStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.SectorStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.SectorStatus} SectorStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SectorStatus.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.SectorStatus();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.revisionTime = reader.int64();
                                break;
                            }
                        case 2: {
                                if (!(message.teams && message.teams.length))
                                    message.teams = [];
                                message.teams.push($root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                if (!(message.assignedBoats && message.assignedBoats.length))
                                    message.assignedBoats = [];
                                message.assignedBoats.push($root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32()));
                                break;
                            }
                        case 4: {
                                if (!(message.unassignedBoats && message.unassignedBoats.length))
                                    message.unassignedBoats = [];
                                message.unassignedBoats.push($root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SectorStatus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.SectorStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.SectorStatus} SectorStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SectorStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SectorStatus message.
                 * @function verify
                 * @memberof havocai.messages.v0.SectorStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SectorStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.revisionTime != null && message.hasOwnProperty("revisionTime"))
                        if (!$util.isInteger(message.revisionTime) && !(message.revisionTime && $util.isInteger(message.revisionTime.low) && $util.isInteger(message.revisionTime.high)))
                            return "revisionTime: integer|Long expected";
                    if (message.teams != null && message.hasOwnProperty("teams")) {
                        if (!Array.isArray(message.teams))
                            return "teams: array expected";
                        for (let i = 0; i < message.teams.length; ++i) {
                            let error = $root.havocai.messages.v0.ResourceRef.verify(message.teams[i]);
                            if (error)
                                return "teams." + error;
                        }
                    }
                    if (message.assignedBoats != null && message.hasOwnProperty("assignedBoats")) {
                        if (!Array.isArray(message.assignedBoats))
                            return "assignedBoats: array expected";
                        for (let i = 0; i < message.assignedBoats.length; ++i) {
                            let error = $root.havocai.messages.v0.ResourceRef.verify(message.assignedBoats[i]);
                            if (error)
                                return "assignedBoats." + error;
                        }
                    }
                    if (message.unassignedBoats != null && message.hasOwnProperty("unassignedBoats")) {
                        if (!Array.isArray(message.unassignedBoats))
                            return "unassignedBoats: array expected";
                        for (let i = 0; i < message.unassignedBoats.length; ++i) {
                            let error = $root.havocai.messages.v0.ResourceRef.verify(message.unassignedBoats[i]);
                            if (error)
                                return "unassignedBoats." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SectorStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.SectorStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.SectorStatus} SectorStatus
                 */
                SectorStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.SectorStatus)
                        return object;
                    let message = new $root.havocai.messages.v0.SectorStatus();
                    if (object.revisionTime != null)
                        if ($util.Long)
                            (message.revisionTime = $util.Long.fromValue(object.revisionTime)).unsigned = false;
                        else if (typeof object.revisionTime === "string")
                            message.revisionTime = parseInt(object.revisionTime, 10);
                        else if (typeof object.revisionTime === "number")
                            message.revisionTime = object.revisionTime;
                        else if (typeof object.revisionTime === "object")
                            message.revisionTime = new $util.LongBits(object.revisionTime.low >>> 0, object.revisionTime.high >>> 0).toNumber();
                    if (object.teams) {
                        if (!Array.isArray(object.teams))
                            throw TypeError(".havocai.messages.v0.SectorStatus.teams: array expected");
                        message.teams = [];
                        for (let i = 0; i < object.teams.length; ++i) {
                            if (typeof object.teams[i] !== "object")
                                throw TypeError(".havocai.messages.v0.SectorStatus.teams: object expected");
                            message.teams[i] = $root.havocai.messages.v0.ResourceRef.fromObject(object.teams[i]);
                        }
                    }
                    if (object.assignedBoats) {
                        if (!Array.isArray(object.assignedBoats))
                            throw TypeError(".havocai.messages.v0.SectorStatus.assignedBoats: array expected");
                        message.assignedBoats = [];
                        for (let i = 0; i < object.assignedBoats.length; ++i) {
                            if (typeof object.assignedBoats[i] !== "object")
                                throw TypeError(".havocai.messages.v0.SectorStatus.assignedBoats: object expected");
                            message.assignedBoats[i] = $root.havocai.messages.v0.ResourceRef.fromObject(object.assignedBoats[i]);
                        }
                    }
                    if (object.unassignedBoats) {
                        if (!Array.isArray(object.unassignedBoats))
                            throw TypeError(".havocai.messages.v0.SectorStatus.unassignedBoats: array expected");
                        message.unassignedBoats = [];
                        for (let i = 0; i < object.unassignedBoats.length; ++i) {
                            if (typeof object.unassignedBoats[i] !== "object")
                                throw TypeError(".havocai.messages.v0.SectorStatus.unassignedBoats: object expected");
                            message.unassignedBoats[i] = $root.havocai.messages.v0.ResourceRef.fromObject(object.unassignedBoats[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SectorStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.SectorStatus
                 * @static
                 * @param {havocai.messages.v0.SectorStatus} message SectorStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SectorStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.teams = [];
                        object.assignedBoats = [];
                        object.unassignedBoats = [];
                    }
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.revisionTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.revisionTime = options.longs === String ? "0" : 0;
                    if (message.revisionTime != null && message.hasOwnProperty("revisionTime"))
                        if (typeof message.revisionTime === "number")
                            object.revisionTime = options.longs === String ? String(message.revisionTime) : message.revisionTime;
                        else
                            object.revisionTime = options.longs === String ? $util.Long.prototype.toString.call(message.revisionTime) : options.longs === Number ? new $util.LongBits(message.revisionTime.low >>> 0, message.revisionTime.high >>> 0).toNumber() : message.revisionTime;
                    if (message.teams && message.teams.length) {
                        object.teams = [];
                        for (let j = 0; j < message.teams.length; ++j)
                            object.teams[j] = $root.havocai.messages.v0.ResourceRef.toObject(message.teams[j], options);
                    }
                    if (message.assignedBoats && message.assignedBoats.length) {
                        object.assignedBoats = [];
                        for (let j = 0; j < message.assignedBoats.length; ++j)
                            object.assignedBoats[j] = $root.havocai.messages.v0.ResourceRef.toObject(message.assignedBoats[j], options);
                    }
                    if (message.unassignedBoats && message.unassignedBoats.length) {
                        object.unassignedBoats = [];
                        for (let j = 0; j < message.unassignedBoats.length; ++j)
                            object.unassignedBoats[j] = $root.havocai.messages.v0.ResourceRef.toObject(message.unassignedBoats[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SectorStatus to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.SectorStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SectorStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SectorStatus
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.SectorStatus
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SectorStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.SectorStatus";
                };

                return SectorStatus;
            })();

            v0.SectorList = (function() {

                /**
                 * Properties of a SectorList.
                 * @memberof havocai.messages.v0
                 * @interface ISectorList
                 * @property {Array.<havocai.messages.v0.ISector>|null} [values] SectorList values
                 */

                /**
                 * Constructs a new SectorList.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a SectorList.
                 * @implements ISectorList
                 * @constructor
                 * @param {havocai.messages.v0.ISectorList=} [properties] Properties to set
                 */
                function SectorList(properties) {
                    this.values = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SectorList values.
                 * @member {Array.<havocai.messages.v0.ISector>} values
                 * @memberof havocai.messages.v0.SectorList
                 * @instance
                 */
                SectorList.prototype.values = $util.emptyArray;

                /**
                 * Creates a new SectorList instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.SectorList
                 * @static
                 * @param {havocai.messages.v0.ISectorList=} [properties] Properties to set
                 * @returns {havocai.messages.v0.SectorList} SectorList instance
                 */
                SectorList.create = function create(properties) {
                    return new SectorList(properties);
                };

                /**
                 * Encodes the specified SectorList message. Does not implicitly {@link havocai.messages.v0.SectorList.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.SectorList
                 * @static
                 * @param {havocai.messages.v0.ISectorList} message SectorList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SectorList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (let i = 0; i < message.values.length; ++i)
                            $root.havocai.messages.v0.Sector.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SectorList message, length delimited. Does not implicitly {@link havocai.messages.v0.SectorList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.SectorList
                 * @static
                 * @param {havocai.messages.v0.ISectorList} message SectorList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SectorList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SectorList message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.SectorList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.SectorList} SectorList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SectorList.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.SectorList();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.values && message.values.length))
                                    message.values = [];
                                message.values.push($root.havocai.messages.v0.Sector.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SectorList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.SectorList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.SectorList} SectorList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SectorList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SectorList message.
                 * @function verify
                 * @memberof havocai.messages.v0.SectorList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SectorList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (let i = 0; i < message.values.length; ++i) {
                            let error = $root.havocai.messages.v0.Sector.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SectorList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.SectorList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.SectorList} SectorList
                 */
                SectorList.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.SectorList)
                        return object;
                    let message = new $root.havocai.messages.v0.SectorList();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".havocai.messages.v0.SectorList.values: array expected");
                        message.values = [];
                        for (let i = 0; i < object.values.length; ++i) {
                            if (typeof object.values[i] !== "object")
                                throw TypeError(".havocai.messages.v0.SectorList.values: object expected");
                            message.values[i] = $root.havocai.messages.v0.Sector.fromObject(object.values[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SectorList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.SectorList
                 * @static
                 * @param {havocai.messages.v0.SectorList} message SectorList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SectorList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (let j = 0; j < message.values.length; ++j)
                            object.values[j] = $root.havocai.messages.v0.Sector.toObject(message.values[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SectorList to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.SectorList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SectorList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SectorList
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.SectorList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SectorList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.SectorList";
                };

                return SectorList;
            })();

            v0.Zone = (function() {

                /**
                 * Properties of a Zone.
                 * @memberof havocai.messages.v0
                 * @interface IZone
                 * @property {havocai.messages.v0.IMetadata|null} [meta] Zone meta
                 * @property {havocai.messages.v0.ZoneType|null} [type] Zone type
                 * @property {havocai.messages.v0.IResourceRef|null} [sector] Zone sector
                 * @property {string|null} [imageUrl] Zone imageUrl
                 * @property {Array.<havocai.messages.v0.IWaypoint>|null} [waypoints] Zone waypoints
                 * @property {Array.<havocai.messages.v0.IGeoPoint>|null} [area] Zone area
                 * @property {Array.<havocai.messages.v0.IMarker>|null} [markers] Zone markers
                 */

                /**
                 * Constructs a new Zone.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Zone.
                 * @implements IZone
                 * @constructor
                 * @param {havocai.messages.v0.IZone=} [properties] Properties to set
                 */
                function Zone(properties) {
                    this.waypoints = [];
                    this.area = [];
                    this.markers = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Zone meta.
                 * @member {havocai.messages.v0.IMetadata|null|undefined} meta
                 * @memberof havocai.messages.v0.Zone
                 * @instance
                 */
                Zone.prototype.meta = null;

                /**
                 * Zone type.
                 * @member {havocai.messages.v0.ZoneType} type
                 * @memberof havocai.messages.v0.Zone
                 * @instance
                 */
                Zone.prototype.type = 0;

                /**
                 * Zone sector.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} sector
                 * @memberof havocai.messages.v0.Zone
                 * @instance
                 */
                Zone.prototype.sector = null;

                /**
                 * Zone imageUrl.
                 * @member {string} imageUrl
                 * @memberof havocai.messages.v0.Zone
                 * @instance
                 */
                Zone.prototype.imageUrl = "";

                /**
                 * Zone waypoints.
                 * @member {Array.<havocai.messages.v0.IWaypoint>} waypoints
                 * @memberof havocai.messages.v0.Zone
                 * @instance
                 */
                Zone.prototype.waypoints = $util.emptyArray;

                /**
                 * Zone area.
                 * @member {Array.<havocai.messages.v0.IGeoPoint>} area
                 * @memberof havocai.messages.v0.Zone
                 * @instance
                 */
                Zone.prototype.area = $util.emptyArray;

                /**
                 * Zone markers.
                 * @member {Array.<havocai.messages.v0.IMarker>} markers
                 * @memberof havocai.messages.v0.Zone
                 * @instance
                 */
                Zone.prototype.markers = $util.emptyArray;

                /**
                 * Creates a new Zone instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Zone
                 * @static
                 * @param {havocai.messages.v0.IZone=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Zone} Zone instance
                 */
                Zone.create = function create(properties) {
                    return new Zone(properties);
                };

                /**
                 * Encodes the specified Zone message. Does not implicitly {@link havocai.messages.v0.Zone.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Zone
                 * @static
                 * @param {havocai.messages.v0.IZone} message Zone message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Zone.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.meta != null && Object.hasOwnProperty.call(message, "meta"))
                        $root.havocai.messages.v0.Metadata.encode(message.meta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.imageUrl != null && Object.hasOwnProperty.call(message, "imageUrl"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.imageUrl);
                    if (message.waypoints != null && message.waypoints.length)
                        for (let i = 0; i < message.waypoints.length; ++i)
                            $root.havocai.messages.v0.Waypoint.encode(message.waypoints[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.area != null && message.area.length)
                        for (let i = 0; i < message.area.length; ++i)
                            $root.havocai.messages.v0.GeoPoint.encode(message.area[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.markers != null && message.markers.length)
                        for (let i = 0; i < message.markers.length; ++i)
                            $root.havocai.messages.v0.Marker.encode(message.markers[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.sector != null && Object.hasOwnProperty.call(message, "sector"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.sector, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Zone message, length delimited. Does not implicitly {@link havocai.messages.v0.Zone.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Zone
                 * @static
                 * @param {havocai.messages.v0.IZone} message Zone message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Zone.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Zone message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Zone
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Zone} Zone
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Zone.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Zone();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.meta = $root.havocai.messages.v0.Metadata.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.type = reader.int32();
                                break;
                            }
                        case 7: {
                                message.sector = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.imageUrl = reader.string();
                                break;
                            }
                        case 4: {
                                if (!(message.waypoints && message.waypoints.length))
                                    message.waypoints = [];
                                message.waypoints.push($root.havocai.messages.v0.Waypoint.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                if (!(message.area && message.area.length))
                                    message.area = [];
                                message.area.push($root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32()));
                                break;
                            }
                        case 6: {
                                if (!(message.markers && message.markers.length))
                                    message.markers = [];
                                message.markers.push($root.havocai.messages.v0.Marker.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Zone message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Zone
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Zone} Zone
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Zone.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Zone message.
                 * @function verify
                 * @memberof havocai.messages.v0.Zone
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Zone.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.meta != null && message.hasOwnProperty("meta")) {
                        let error = $root.havocai.messages.v0.Metadata.verify(message.meta);
                        if (error)
                            return "meta." + error;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.sector != null && message.hasOwnProperty("sector")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.sector);
                        if (error)
                            return "sector." + error;
                    }
                    if (message.imageUrl != null && message.hasOwnProperty("imageUrl"))
                        if (!$util.isString(message.imageUrl))
                            return "imageUrl: string expected";
                    if (message.waypoints != null && message.hasOwnProperty("waypoints")) {
                        if (!Array.isArray(message.waypoints))
                            return "waypoints: array expected";
                        for (let i = 0; i < message.waypoints.length; ++i) {
                            let error = $root.havocai.messages.v0.Waypoint.verify(message.waypoints[i]);
                            if (error)
                                return "waypoints." + error;
                        }
                    }
                    if (message.area != null && message.hasOwnProperty("area")) {
                        if (!Array.isArray(message.area))
                            return "area: array expected";
                        for (let i = 0; i < message.area.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoPoint.verify(message.area[i]);
                            if (error)
                                return "area." + error;
                        }
                    }
                    if (message.markers != null && message.hasOwnProperty("markers")) {
                        if (!Array.isArray(message.markers))
                            return "markers: array expected";
                        for (let i = 0; i < message.markers.length; ++i) {
                            let error = $root.havocai.messages.v0.Marker.verify(message.markers[i]);
                            if (error)
                                return "markers." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Zone message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Zone
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Zone} Zone
                 */
                Zone.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Zone)
                        return object;
                    let message = new $root.havocai.messages.v0.Zone();
                    if (object.meta != null) {
                        if (typeof object.meta !== "object")
                            throw TypeError(".havocai.messages.v0.Zone.meta: object expected");
                        message.meta = $root.havocai.messages.v0.Metadata.fromObject(object.meta);
                    }
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "ZONE_TYPE_UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "ZONE_TYPE_BEACH":
                    case 1:
                        message.type = 1;
                        break;
                    case "ZONE_TYPE_OVERLAY":
                    case 2:
                        message.type = 2;
                        break;
                    case "ZONE_TYPE_ENGAGEMENT":
                    case 3:
                        message.type = 3;
                        break;
                    case "ZONE_TYPE_ROUTE":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.sector != null) {
                        if (typeof object.sector !== "object")
                            throw TypeError(".havocai.messages.v0.Zone.sector: object expected");
                        message.sector = $root.havocai.messages.v0.ResourceRef.fromObject(object.sector);
                    }
                    if (object.imageUrl != null)
                        message.imageUrl = String(object.imageUrl);
                    if (object.waypoints) {
                        if (!Array.isArray(object.waypoints))
                            throw TypeError(".havocai.messages.v0.Zone.waypoints: array expected");
                        message.waypoints = [];
                        for (let i = 0; i < object.waypoints.length; ++i) {
                            if (typeof object.waypoints[i] !== "object")
                                throw TypeError(".havocai.messages.v0.Zone.waypoints: object expected");
                            message.waypoints[i] = $root.havocai.messages.v0.Waypoint.fromObject(object.waypoints[i]);
                        }
                    }
                    if (object.area) {
                        if (!Array.isArray(object.area))
                            throw TypeError(".havocai.messages.v0.Zone.area: array expected");
                        message.area = [];
                        for (let i = 0; i < object.area.length; ++i) {
                            if (typeof object.area[i] !== "object")
                                throw TypeError(".havocai.messages.v0.Zone.area: object expected");
                            message.area[i] = $root.havocai.messages.v0.GeoPoint.fromObject(object.area[i]);
                        }
                    }
                    if (object.markers) {
                        if (!Array.isArray(object.markers))
                            throw TypeError(".havocai.messages.v0.Zone.markers: array expected");
                        message.markers = [];
                        for (let i = 0; i < object.markers.length; ++i) {
                            if (typeof object.markers[i] !== "object")
                                throw TypeError(".havocai.messages.v0.Zone.markers: object expected");
                            message.markers[i] = $root.havocai.messages.v0.Marker.fromObject(object.markers[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Zone message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Zone
                 * @static
                 * @param {havocai.messages.v0.Zone} message Zone
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Zone.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.waypoints = [];
                        object.area = [];
                        object.markers = [];
                    }
                    if (options.defaults) {
                        object.meta = null;
                        object.type = options.enums === String ? "ZONE_TYPE_UNKNOWN" : 0;
                        object.imageUrl = "";
                        object.sector = null;
                    }
                    if (message.meta != null && message.hasOwnProperty("meta"))
                        object.meta = $root.havocai.messages.v0.Metadata.toObject(message.meta, options);
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.havocai.messages.v0.ZoneType[message.type] === undefined ? message.type : $root.havocai.messages.v0.ZoneType[message.type] : message.type;
                    if (message.imageUrl != null && message.hasOwnProperty("imageUrl"))
                        object.imageUrl = message.imageUrl;
                    if (message.waypoints && message.waypoints.length) {
                        object.waypoints = [];
                        for (let j = 0; j < message.waypoints.length; ++j)
                            object.waypoints[j] = $root.havocai.messages.v0.Waypoint.toObject(message.waypoints[j], options);
                    }
                    if (message.area && message.area.length) {
                        object.area = [];
                        for (let j = 0; j < message.area.length; ++j)
                            object.area[j] = $root.havocai.messages.v0.GeoPoint.toObject(message.area[j], options);
                    }
                    if (message.markers && message.markers.length) {
                        object.markers = [];
                        for (let j = 0; j < message.markers.length; ++j)
                            object.markers[j] = $root.havocai.messages.v0.Marker.toObject(message.markers[j], options);
                    }
                    if (message.sector != null && message.hasOwnProperty("sector"))
                        object.sector = $root.havocai.messages.v0.ResourceRef.toObject(message.sector, options);
                    return object;
                };

                /**
                 * Converts this Zone to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Zone
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Zone.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Zone
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Zone
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Zone.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Zone";
                };

                return Zone;
            })();

            v0.ZoneList = (function() {

                /**
                 * Properties of a ZoneList.
                 * @memberof havocai.messages.v0
                 * @interface IZoneList
                 * @property {Array.<havocai.messages.v0.IZone>|null} [values] ZoneList values
                 */

                /**
                 * Constructs a new ZoneList.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a ZoneList.
                 * @implements IZoneList
                 * @constructor
                 * @param {havocai.messages.v0.IZoneList=} [properties] Properties to set
                 */
                function ZoneList(properties) {
                    this.values = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ZoneList values.
                 * @member {Array.<havocai.messages.v0.IZone>} values
                 * @memberof havocai.messages.v0.ZoneList
                 * @instance
                 */
                ZoneList.prototype.values = $util.emptyArray;

                /**
                 * Creates a new ZoneList instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.ZoneList
                 * @static
                 * @param {havocai.messages.v0.IZoneList=} [properties] Properties to set
                 * @returns {havocai.messages.v0.ZoneList} ZoneList instance
                 */
                ZoneList.create = function create(properties) {
                    return new ZoneList(properties);
                };

                /**
                 * Encodes the specified ZoneList message. Does not implicitly {@link havocai.messages.v0.ZoneList.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.ZoneList
                 * @static
                 * @param {havocai.messages.v0.IZoneList} message ZoneList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ZoneList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (let i = 0; i < message.values.length; ++i)
                            $root.havocai.messages.v0.Zone.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ZoneList message, length delimited. Does not implicitly {@link havocai.messages.v0.ZoneList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.ZoneList
                 * @static
                 * @param {havocai.messages.v0.IZoneList} message ZoneList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ZoneList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ZoneList message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.ZoneList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.ZoneList} ZoneList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ZoneList.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.ZoneList();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.values && message.values.length))
                                    message.values = [];
                                message.values.push($root.havocai.messages.v0.Zone.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ZoneList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.ZoneList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.ZoneList} ZoneList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ZoneList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ZoneList message.
                 * @function verify
                 * @memberof havocai.messages.v0.ZoneList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ZoneList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (let i = 0; i < message.values.length; ++i) {
                            let error = $root.havocai.messages.v0.Zone.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ZoneList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.ZoneList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.ZoneList} ZoneList
                 */
                ZoneList.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.ZoneList)
                        return object;
                    let message = new $root.havocai.messages.v0.ZoneList();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".havocai.messages.v0.ZoneList.values: array expected");
                        message.values = [];
                        for (let i = 0; i < object.values.length; ++i) {
                            if (typeof object.values[i] !== "object")
                                throw TypeError(".havocai.messages.v0.ZoneList.values: object expected");
                            message.values[i] = $root.havocai.messages.v0.Zone.fromObject(object.values[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ZoneList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.ZoneList
                 * @static
                 * @param {havocai.messages.v0.ZoneList} message ZoneList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ZoneList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (let j = 0; j < message.values.length; ++j)
                            object.values[j] = $root.havocai.messages.v0.Zone.toObject(message.values[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ZoneList to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.ZoneList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ZoneList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ZoneList
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.ZoneList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ZoneList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.ZoneList";
                };

                return ZoneList;
            })();

            v0.Track = (function() {

                /**
                 * Properties of a Track.
                 * @memberof havocai.messages.v0
                 * @interface ITrack
                 * @property {havocai.messages.v0.IMetadata|null} [meta] Track meta
                 * @property {havocai.messages.v0.TrackType|null} [type] Track type
                 * @property {havocai.messages.v0.IGeoPose|null} [position] Track position
                 * @property {number|null} [heading] Track heading
                 * @property {number|null} [course] Track course
                 * @property {number|null} [speed] Track speed
                 * @property {havocai.messages.v0.Affiliation|null} [affiliation] Track affiliation
                 * @property {havocai.messages.v0.CredibilityRating|null} [typeCredibility] Track typeCredibility
                 * @property {havocai.messages.v0.CredibilityRating|null} [positionCredibility] Track positionCredibility
                 * @property {havocai.messages.v0.CredibilityRating|null} [affiliationCredibility] Track affiliationCredibility
                 * @property {Array.<havocai.messages.v0.IGeoImage>|null} [images] Track images
                 * @property {havocai.messages.v0.ITrackStatus|null} [status] Track status
                 */

                /**
                 * Constructs a new Track.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Track.
                 * @implements ITrack
                 * @constructor
                 * @param {havocai.messages.v0.ITrack=} [properties] Properties to set
                 */
                function Track(properties) {
                    this.images = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Track meta.
                 * @member {havocai.messages.v0.IMetadata|null|undefined} meta
                 * @memberof havocai.messages.v0.Track
                 * @instance
                 */
                Track.prototype.meta = null;

                /**
                 * Track type.
                 * @member {havocai.messages.v0.TrackType} type
                 * @memberof havocai.messages.v0.Track
                 * @instance
                 */
                Track.prototype.type = 0;

                /**
                 * Track position.
                 * @member {havocai.messages.v0.IGeoPose|null|undefined} position
                 * @memberof havocai.messages.v0.Track
                 * @instance
                 */
                Track.prototype.position = null;

                /**
                 * Track heading.
                 * @member {number} heading
                 * @memberof havocai.messages.v0.Track
                 * @instance
                 */
                Track.prototype.heading = 0;

                /**
                 * Track course.
                 * @member {number} course
                 * @memberof havocai.messages.v0.Track
                 * @instance
                 */
                Track.prototype.course = 0;

                /**
                 * Track speed.
                 * @member {number} speed
                 * @memberof havocai.messages.v0.Track
                 * @instance
                 */
                Track.prototype.speed = 0;

                /**
                 * Track affiliation.
                 * @member {havocai.messages.v0.Affiliation} affiliation
                 * @memberof havocai.messages.v0.Track
                 * @instance
                 */
                Track.prototype.affiliation = 0;

                /**
                 * Track typeCredibility.
                 * @member {havocai.messages.v0.CredibilityRating} typeCredibility
                 * @memberof havocai.messages.v0.Track
                 * @instance
                 */
                Track.prototype.typeCredibility = 0;

                /**
                 * Track positionCredibility.
                 * @member {havocai.messages.v0.CredibilityRating} positionCredibility
                 * @memberof havocai.messages.v0.Track
                 * @instance
                 */
                Track.prototype.positionCredibility = 0;

                /**
                 * Track affiliationCredibility.
                 * @member {havocai.messages.v0.CredibilityRating} affiliationCredibility
                 * @memberof havocai.messages.v0.Track
                 * @instance
                 */
                Track.prototype.affiliationCredibility = 0;

                /**
                 * Track images.
                 * @member {Array.<havocai.messages.v0.IGeoImage>} images
                 * @memberof havocai.messages.v0.Track
                 * @instance
                 */
                Track.prototype.images = $util.emptyArray;

                /**
                 * Track status.
                 * @member {havocai.messages.v0.ITrackStatus|null|undefined} status
                 * @memberof havocai.messages.v0.Track
                 * @instance
                 */
                Track.prototype.status = null;

                /**
                 * Creates a new Track instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Track
                 * @static
                 * @param {havocai.messages.v0.ITrack=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Track} Track instance
                 */
                Track.create = function create(properties) {
                    return new Track(properties);
                };

                /**
                 * Encodes the specified Track message. Does not implicitly {@link havocai.messages.v0.Track.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Track
                 * @static
                 * @param {havocai.messages.v0.ITrack} message Track message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Track.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.meta != null && Object.hasOwnProperty.call(message, "meta"))
                        $root.havocai.messages.v0.Metadata.encode(message.meta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                        $root.havocai.messages.v0.GeoPose.encode(message.position, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.affiliation != null && Object.hasOwnProperty.call(message, "affiliation"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.affiliation);
                    if (message.typeCredibility != null && Object.hasOwnProperty.call(message, "typeCredibility"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.typeCredibility);
                    if (message.positionCredibility != null && Object.hasOwnProperty.call(message, "positionCredibility"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.positionCredibility);
                    if (message.affiliationCredibility != null && Object.hasOwnProperty.call(message, "affiliationCredibility"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.affiliationCredibility);
                    if (message.heading != null && Object.hasOwnProperty.call(message, "heading"))
                        writer.uint32(/* id 8, wireType 1 =*/65).double(message.heading);
                    if (message.images != null && message.images.length)
                        for (let i = 0; i < message.images.length; ++i)
                            $root.havocai.messages.v0.GeoImage.encode(message.images[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                        writer.uint32(/* id 10, wireType 1 =*/81).double(message.speed);
                    if (message.course != null && Object.hasOwnProperty.call(message, "course"))
                        writer.uint32(/* id 11, wireType 1 =*/89).double(message.course);
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        $root.havocai.messages.v0.TrackStatus.encode(message.status, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Track message, length delimited. Does not implicitly {@link havocai.messages.v0.Track.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Track
                 * @static
                 * @param {havocai.messages.v0.ITrack} message Track message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Track.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Track message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Track
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Track} Track
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Track.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Track();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.meta = $root.havocai.messages.v0.Metadata.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.type = reader.int32();
                                break;
                            }
                        case 3: {
                                message.position = $root.havocai.messages.v0.GeoPose.decode(reader, reader.uint32());
                                break;
                            }
                        case 8: {
                                message.heading = reader.double();
                                break;
                            }
                        case 11: {
                                message.course = reader.double();
                                break;
                            }
                        case 10: {
                                message.speed = reader.double();
                                break;
                            }
                        case 4: {
                                message.affiliation = reader.int32();
                                break;
                            }
                        case 5: {
                                message.typeCredibility = reader.int32();
                                break;
                            }
                        case 6: {
                                message.positionCredibility = reader.int32();
                                break;
                            }
                        case 7: {
                                message.affiliationCredibility = reader.int32();
                                break;
                            }
                        case 9: {
                                if (!(message.images && message.images.length))
                                    message.images = [];
                                message.images.push($root.havocai.messages.v0.GeoImage.decode(reader, reader.uint32()));
                                break;
                            }
                        case 15: {
                                message.status = $root.havocai.messages.v0.TrackStatus.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Track message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Track
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Track} Track
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Track.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Track message.
                 * @function verify
                 * @memberof havocai.messages.v0.Track
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Track.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.meta != null && message.hasOwnProperty("meta")) {
                        let error = $root.havocai.messages.v0.Metadata.verify(message.meta);
                        if (error)
                            return "meta." + error;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 98:
                        case 99:
                            break;
                        }
                    if (message.position != null && message.hasOwnProperty("position")) {
                        let error = $root.havocai.messages.v0.GeoPose.verify(message.position);
                        if (error)
                            return "position." + error;
                    }
                    if (message.heading != null && message.hasOwnProperty("heading"))
                        if (typeof message.heading !== "number")
                            return "heading: number expected";
                    if (message.course != null && message.hasOwnProperty("course"))
                        if (typeof message.course !== "number")
                            return "course: number expected";
                    if (message.speed != null && message.hasOwnProperty("speed"))
                        if (typeof message.speed !== "number")
                            return "speed: number expected";
                    if (message.affiliation != null && message.hasOwnProperty("affiliation"))
                        switch (message.affiliation) {
                        default:
                            return "affiliation: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.typeCredibility != null && message.hasOwnProperty("typeCredibility"))
                        switch (message.typeCredibility) {
                        default:
                            return "typeCredibility: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.positionCredibility != null && message.hasOwnProperty("positionCredibility"))
                        switch (message.positionCredibility) {
                        default:
                            return "positionCredibility: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.affiliationCredibility != null && message.hasOwnProperty("affiliationCredibility"))
                        switch (message.affiliationCredibility) {
                        default:
                            return "affiliationCredibility: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.images != null && message.hasOwnProperty("images")) {
                        if (!Array.isArray(message.images))
                            return "images: array expected";
                        for (let i = 0; i < message.images.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoImage.verify(message.images[i]);
                            if (error)
                                return "images." + error;
                        }
                    }
                    if (message.status != null && message.hasOwnProperty("status")) {
                        let error = $root.havocai.messages.v0.TrackStatus.verify(message.status);
                        if (error)
                            return "status." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Track message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Track
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Track} Track
                 */
                Track.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Track)
                        return object;
                    let message = new $root.havocai.messages.v0.Track();
                    if (object.meta != null) {
                        if (typeof object.meta !== "object")
                            throw TypeError(".havocai.messages.v0.Track.meta: object expected");
                        message.meta = $root.havocai.messages.v0.Metadata.fromObject(object.meta);
                    }
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "TRACK_TYPE_UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "TRACK_TYPE_AIS":
                    case 1:
                        message.type = 1;
                        break;
                    case "TRACK_TYPE_RADAR":
                    case 2:
                        message.type = 2;
                        break;
                    case "TRACK_TYPE_EO":
                    case 3:
                        message.type = 3;
                        break;
                    case "TRACK_TYPE_FUSED":
                    case 4:
                        message.type = 4;
                        break;
                    case "TRACK_TYPE_USER_CREATED":
                    case 5:
                        message.type = 5;
                        break;
                    case "TRACK_TYPE_EXTERNAL_SYSTEM":
                    case 6:
                        message.type = 6;
                        break;
                    case "TRACK_TYPE_RF":
                    case 7:
                        message.type = 7;
                        break;
                    case "TRACK_TYPE_PERSON":
                    case 8:
                        message.type = 8;
                        break;
                    case "TRACK_TYPE_MISSILE":
                    case 9:
                        message.type = 9;
                        break;
                    case "TRACK_TYPE_TORPEDO":
                    case 10:
                        message.type = 10;
                        break;
                    case "TRACK_TYPE_RUBBER_DUCKIE":
                    case 98:
                        message.type = 98;
                        break;
                    case "TRACK_TYPE_NERF_DART":
                    case 99:
                        message.type = 99;
                        break;
                    }
                    if (object.position != null) {
                        if (typeof object.position !== "object")
                            throw TypeError(".havocai.messages.v0.Track.position: object expected");
                        message.position = $root.havocai.messages.v0.GeoPose.fromObject(object.position);
                    }
                    if (object.heading != null)
                        message.heading = Number(object.heading);
                    if (object.course != null)
                        message.course = Number(object.course);
                    if (object.speed != null)
                        message.speed = Number(object.speed);
                    switch (object.affiliation) {
                    default:
                        if (typeof object.affiliation === "number") {
                            message.affiliation = object.affiliation;
                            break;
                        }
                        break;
                    case "AFFILIATION_UNKNOWN":
                    case 0:
                        message.affiliation = 0;
                        break;
                    case "AFFILIATION_ASSUMED_FRIENDLY":
                    case 1:
                        message.affiliation = 1;
                        break;
                    case "AFFILIATION_FRIENDLY":
                    case 2:
                        message.affiliation = 2;
                        break;
                    case "AFFILIATION_NEUTRAL":
                    case 3:
                        message.affiliation = 3;
                        break;
                    case "AFFILIATION_SUSPECT":
                    case 4:
                        message.affiliation = 4;
                        break;
                    case "AFFILIATION_HOSTILE":
                    case 5:
                        message.affiliation = 5;
                        break;
                    }
                    switch (object.typeCredibility) {
                    default:
                        if (typeof object.typeCredibility === "number") {
                            message.typeCredibility = object.typeCredibility;
                            break;
                        }
                        break;
                    case "CREDIBILITY_UNKNOWN":
                    case 0:
                        message.typeCredibility = 0;
                        break;
                    case "CREDIBILITY_IMPROBABLE":
                    case 1:
                        message.typeCredibility = 1;
                        break;
                    case "CREDIBILITY_DOUBTFUL":
                    case 2:
                        message.typeCredibility = 2;
                        break;
                    case "CREDIBILITY_POSSIBLE":
                    case 3:
                        message.typeCredibility = 3;
                        break;
                    case "CREDIBILITY_PROBABLE":
                    case 4:
                        message.typeCredibility = 4;
                        break;
                    case "CREDIBILITY_CONFIRMED":
                    case 5:
                        message.typeCredibility = 5;
                        break;
                    }
                    switch (object.positionCredibility) {
                    default:
                        if (typeof object.positionCredibility === "number") {
                            message.positionCredibility = object.positionCredibility;
                            break;
                        }
                        break;
                    case "CREDIBILITY_UNKNOWN":
                    case 0:
                        message.positionCredibility = 0;
                        break;
                    case "CREDIBILITY_IMPROBABLE":
                    case 1:
                        message.positionCredibility = 1;
                        break;
                    case "CREDIBILITY_DOUBTFUL":
                    case 2:
                        message.positionCredibility = 2;
                        break;
                    case "CREDIBILITY_POSSIBLE":
                    case 3:
                        message.positionCredibility = 3;
                        break;
                    case "CREDIBILITY_PROBABLE":
                    case 4:
                        message.positionCredibility = 4;
                        break;
                    case "CREDIBILITY_CONFIRMED":
                    case 5:
                        message.positionCredibility = 5;
                        break;
                    }
                    switch (object.affiliationCredibility) {
                    default:
                        if (typeof object.affiliationCredibility === "number") {
                            message.affiliationCredibility = object.affiliationCredibility;
                            break;
                        }
                        break;
                    case "CREDIBILITY_UNKNOWN":
                    case 0:
                        message.affiliationCredibility = 0;
                        break;
                    case "CREDIBILITY_IMPROBABLE":
                    case 1:
                        message.affiliationCredibility = 1;
                        break;
                    case "CREDIBILITY_DOUBTFUL":
                    case 2:
                        message.affiliationCredibility = 2;
                        break;
                    case "CREDIBILITY_POSSIBLE":
                    case 3:
                        message.affiliationCredibility = 3;
                        break;
                    case "CREDIBILITY_PROBABLE":
                    case 4:
                        message.affiliationCredibility = 4;
                        break;
                    case "CREDIBILITY_CONFIRMED":
                    case 5:
                        message.affiliationCredibility = 5;
                        break;
                    }
                    if (object.images) {
                        if (!Array.isArray(object.images))
                            throw TypeError(".havocai.messages.v0.Track.images: array expected");
                        message.images = [];
                        for (let i = 0; i < object.images.length; ++i) {
                            if (typeof object.images[i] !== "object")
                                throw TypeError(".havocai.messages.v0.Track.images: object expected");
                            message.images[i] = $root.havocai.messages.v0.GeoImage.fromObject(object.images[i]);
                        }
                    }
                    if (object.status != null) {
                        if (typeof object.status !== "object")
                            throw TypeError(".havocai.messages.v0.Track.status: object expected");
                        message.status = $root.havocai.messages.v0.TrackStatus.fromObject(object.status);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Track message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Track
                 * @static
                 * @param {havocai.messages.v0.Track} message Track
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Track.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.images = [];
                    if (options.defaults) {
                        object.meta = null;
                        object.type = options.enums === String ? "TRACK_TYPE_UNKNOWN" : 0;
                        object.position = null;
                        object.affiliation = options.enums === String ? "AFFILIATION_UNKNOWN" : 0;
                        object.typeCredibility = options.enums === String ? "CREDIBILITY_UNKNOWN" : 0;
                        object.positionCredibility = options.enums === String ? "CREDIBILITY_UNKNOWN" : 0;
                        object.affiliationCredibility = options.enums === String ? "CREDIBILITY_UNKNOWN" : 0;
                        object.heading = 0;
                        object.speed = 0;
                        object.course = 0;
                        object.status = null;
                    }
                    if (message.meta != null && message.hasOwnProperty("meta"))
                        object.meta = $root.havocai.messages.v0.Metadata.toObject(message.meta, options);
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.havocai.messages.v0.TrackType[message.type] === undefined ? message.type : $root.havocai.messages.v0.TrackType[message.type] : message.type;
                    if (message.position != null && message.hasOwnProperty("position"))
                        object.position = $root.havocai.messages.v0.GeoPose.toObject(message.position, options);
                    if (message.affiliation != null && message.hasOwnProperty("affiliation"))
                        object.affiliation = options.enums === String ? $root.havocai.messages.v0.Affiliation[message.affiliation] === undefined ? message.affiliation : $root.havocai.messages.v0.Affiliation[message.affiliation] : message.affiliation;
                    if (message.typeCredibility != null && message.hasOwnProperty("typeCredibility"))
                        object.typeCredibility = options.enums === String ? $root.havocai.messages.v0.CredibilityRating[message.typeCredibility] === undefined ? message.typeCredibility : $root.havocai.messages.v0.CredibilityRating[message.typeCredibility] : message.typeCredibility;
                    if (message.positionCredibility != null && message.hasOwnProperty("positionCredibility"))
                        object.positionCredibility = options.enums === String ? $root.havocai.messages.v0.CredibilityRating[message.positionCredibility] === undefined ? message.positionCredibility : $root.havocai.messages.v0.CredibilityRating[message.positionCredibility] : message.positionCredibility;
                    if (message.affiliationCredibility != null && message.hasOwnProperty("affiliationCredibility"))
                        object.affiliationCredibility = options.enums === String ? $root.havocai.messages.v0.CredibilityRating[message.affiliationCredibility] === undefined ? message.affiliationCredibility : $root.havocai.messages.v0.CredibilityRating[message.affiliationCredibility] : message.affiliationCredibility;
                    if (message.heading != null && message.hasOwnProperty("heading"))
                        object.heading = options.json && !isFinite(message.heading) ? String(message.heading) : message.heading;
                    if (message.images && message.images.length) {
                        object.images = [];
                        for (let j = 0; j < message.images.length; ++j)
                            object.images[j] = $root.havocai.messages.v0.GeoImage.toObject(message.images[j], options);
                    }
                    if (message.speed != null && message.hasOwnProperty("speed"))
                        object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
                    if (message.course != null && message.hasOwnProperty("course"))
                        object.course = options.json && !isFinite(message.course) ? String(message.course) : message.course;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = $root.havocai.messages.v0.TrackStatus.toObject(message.status, options);
                    return object;
                };

                /**
                 * Converts this Track to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Track
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Track.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Track
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Track
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Track.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Track";
                };

                return Track;
            })();

            v0.TrackStatus = (function() {

                /**
                 * Properties of a TrackStatus.
                 * @memberof havocai.messages.v0
                 * @interface ITrackStatus
                 * @property {number|Long|null} [revisionTime] TrackStatus revisionTime
                 * @property {Array.<havocai.messages.v0.IGeoPose>|null} [trace] TrackStatus trace
                 * @property {number|null} [typeConfidence] TrackStatus typeConfidence
                 * @property {number|null} [positionConfidence] TrackStatus positionConfidence
                 * @property {number|null} [affiliationConfidence] TrackStatus affiliationConfidence
                 */

                /**
                 * Constructs a new TrackStatus.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a TrackStatus.
                 * @implements ITrackStatus
                 * @constructor
                 * @param {havocai.messages.v0.ITrackStatus=} [properties] Properties to set
                 */
                function TrackStatus(properties) {
                    this.trace = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TrackStatus revisionTime.
                 * @member {number|Long} revisionTime
                 * @memberof havocai.messages.v0.TrackStatus
                 * @instance
                 */
                TrackStatus.prototype.revisionTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TrackStatus trace.
                 * @member {Array.<havocai.messages.v0.IGeoPose>} trace
                 * @memberof havocai.messages.v0.TrackStatus
                 * @instance
                 */
                TrackStatus.prototype.trace = $util.emptyArray;

                /**
                 * TrackStatus typeConfidence.
                 * @member {number} typeConfidence
                 * @memberof havocai.messages.v0.TrackStatus
                 * @instance
                 */
                TrackStatus.prototype.typeConfidence = 0;

                /**
                 * TrackStatus positionConfidence.
                 * @member {number} positionConfidence
                 * @memberof havocai.messages.v0.TrackStatus
                 * @instance
                 */
                TrackStatus.prototype.positionConfidence = 0;

                /**
                 * TrackStatus affiliationConfidence.
                 * @member {number} affiliationConfidence
                 * @memberof havocai.messages.v0.TrackStatus
                 * @instance
                 */
                TrackStatus.prototype.affiliationConfidence = 0;

                /**
                 * Creates a new TrackStatus instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.TrackStatus
                 * @static
                 * @param {havocai.messages.v0.ITrackStatus=} [properties] Properties to set
                 * @returns {havocai.messages.v0.TrackStatus} TrackStatus instance
                 */
                TrackStatus.create = function create(properties) {
                    return new TrackStatus(properties);
                };

                /**
                 * Encodes the specified TrackStatus message. Does not implicitly {@link havocai.messages.v0.TrackStatus.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.TrackStatus
                 * @static
                 * @param {havocai.messages.v0.ITrackStatus} message TrackStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrackStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.revisionTime != null && Object.hasOwnProperty.call(message, "revisionTime"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.revisionTime);
                    if (message.trace != null && message.trace.length)
                        for (let i = 0; i < message.trace.length; ++i)
                            $root.havocai.messages.v0.GeoPose.encode(message.trace[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.typeConfidence != null && Object.hasOwnProperty.call(message, "typeConfidence"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.typeConfidence);
                    if (message.positionConfidence != null && Object.hasOwnProperty.call(message, "positionConfidence"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.positionConfidence);
                    if (message.affiliationConfidence != null && Object.hasOwnProperty.call(message, "affiliationConfidence"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.affiliationConfidence);
                    return writer;
                };

                /**
                 * Encodes the specified TrackStatus message, length delimited. Does not implicitly {@link havocai.messages.v0.TrackStatus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.TrackStatus
                 * @static
                 * @param {havocai.messages.v0.ITrackStatus} message TrackStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrackStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TrackStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.TrackStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.TrackStatus} TrackStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrackStatus.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.TrackStatus();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.revisionTime = reader.int64();
                                break;
                            }
                        case 2: {
                                if (!(message.trace && message.trace.length))
                                    message.trace = [];
                                message.trace.push($root.havocai.messages.v0.GeoPose.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                message.typeConfidence = reader.float();
                                break;
                            }
                        case 4: {
                                message.positionConfidence = reader.float();
                                break;
                            }
                        case 5: {
                                message.affiliationConfidence = reader.float();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TrackStatus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.TrackStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.TrackStatus} TrackStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrackStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TrackStatus message.
                 * @function verify
                 * @memberof havocai.messages.v0.TrackStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TrackStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.revisionTime != null && message.hasOwnProperty("revisionTime"))
                        if (!$util.isInteger(message.revisionTime) && !(message.revisionTime && $util.isInteger(message.revisionTime.low) && $util.isInteger(message.revisionTime.high)))
                            return "revisionTime: integer|Long expected";
                    if (message.trace != null && message.hasOwnProperty("trace")) {
                        if (!Array.isArray(message.trace))
                            return "trace: array expected";
                        for (let i = 0; i < message.trace.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoPose.verify(message.trace[i]);
                            if (error)
                                return "trace." + error;
                        }
                    }
                    if (message.typeConfidence != null && message.hasOwnProperty("typeConfidence"))
                        if (typeof message.typeConfidence !== "number")
                            return "typeConfidence: number expected";
                    if (message.positionConfidence != null && message.hasOwnProperty("positionConfidence"))
                        if (typeof message.positionConfidence !== "number")
                            return "positionConfidence: number expected";
                    if (message.affiliationConfidence != null && message.hasOwnProperty("affiliationConfidence"))
                        if (typeof message.affiliationConfidence !== "number")
                            return "affiliationConfidence: number expected";
                    return null;
                };

                /**
                 * Creates a TrackStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.TrackStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.TrackStatus} TrackStatus
                 */
                TrackStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.TrackStatus)
                        return object;
                    let message = new $root.havocai.messages.v0.TrackStatus();
                    if (object.revisionTime != null)
                        if ($util.Long)
                            (message.revisionTime = $util.Long.fromValue(object.revisionTime)).unsigned = false;
                        else if (typeof object.revisionTime === "string")
                            message.revisionTime = parseInt(object.revisionTime, 10);
                        else if (typeof object.revisionTime === "number")
                            message.revisionTime = object.revisionTime;
                        else if (typeof object.revisionTime === "object")
                            message.revisionTime = new $util.LongBits(object.revisionTime.low >>> 0, object.revisionTime.high >>> 0).toNumber();
                    if (object.trace) {
                        if (!Array.isArray(object.trace))
                            throw TypeError(".havocai.messages.v0.TrackStatus.trace: array expected");
                        message.trace = [];
                        for (let i = 0; i < object.trace.length; ++i) {
                            if (typeof object.trace[i] !== "object")
                                throw TypeError(".havocai.messages.v0.TrackStatus.trace: object expected");
                            message.trace[i] = $root.havocai.messages.v0.GeoPose.fromObject(object.trace[i]);
                        }
                    }
                    if (object.typeConfidence != null)
                        message.typeConfidence = Number(object.typeConfidence);
                    if (object.positionConfidence != null)
                        message.positionConfidence = Number(object.positionConfidence);
                    if (object.affiliationConfidence != null)
                        message.affiliationConfidence = Number(object.affiliationConfidence);
                    return message;
                };

                /**
                 * Creates a plain object from a TrackStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.TrackStatus
                 * @static
                 * @param {havocai.messages.v0.TrackStatus} message TrackStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TrackStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.trace = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.revisionTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.revisionTime = options.longs === String ? "0" : 0;
                        object.typeConfidence = 0;
                        object.positionConfidence = 0;
                        object.affiliationConfidence = 0;
                    }
                    if (message.revisionTime != null && message.hasOwnProperty("revisionTime"))
                        if (typeof message.revisionTime === "number")
                            object.revisionTime = options.longs === String ? String(message.revisionTime) : message.revisionTime;
                        else
                            object.revisionTime = options.longs === String ? $util.Long.prototype.toString.call(message.revisionTime) : options.longs === Number ? new $util.LongBits(message.revisionTime.low >>> 0, message.revisionTime.high >>> 0).toNumber() : message.revisionTime;
                    if (message.trace && message.trace.length) {
                        object.trace = [];
                        for (let j = 0; j < message.trace.length; ++j)
                            object.trace[j] = $root.havocai.messages.v0.GeoPose.toObject(message.trace[j], options);
                    }
                    if (message.typeConfidence != null && message.hasOwnProperty("typeConfidence"))
                        object.typeConfidence = options.json && !isFinite(message.typeConfidence) ? String(message.typeConfidence) : message.typeConfidence;
                    if (message.positionConfidence != null && message.hasOwnProperty("positionConfidence"))
                        object.positionConfidence = options.json && !isFinite(message.positionConfidence) ? String(message.positionConfidence) : message.positionConfidence;
                    if (message.affiliationConfidence != null && message.hasOwnProperty("affiliationConfidence"))
                        object.affiliationConfidence = options.json && !isFinite(message.affiliationConfidence) ? String(message.affiliationConfidence) : message.affiliationConfidence;
                    return object;
                };

                /**
                 * Converts this TrackStatus to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.TrackStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TrackStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TrackStatus
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.TrackStatus
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TrackStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.TrackStatus";
                };

                return TrackStatus;
            })();

            v0.TrackList = (function() {

                /**
                 * Properties of a TrackList.
                 * @memberof havocai.messages.v0
                 * @interface ITrackList
                 * @property {Array.<havocai.messages.v0.ITrack>|null} [values] TrackList values
                 */

                /**
                 * Constructs a new TrackList.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a TrackList.
                 * @implements ITrackList
                 * @constructor
                 * @param {havocai.messages.v0.ITrackList=} [properties] Properties to set
                 */
                function TrackList(properties) {
                    this.values = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TrackList values.
                 * @member {Array.<havocai.messages.v0.ITrack>} values
                 * @memberof havocai.messages.v0.TrackList
                 * @instance
                 */
                TrackList.prototype.values = $util.emptyArray;

                /**
                 * Creates a new TrackList instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.TrackList
                 * @static
                 * @param {havocai.messages.v0.ITrackList=} [properties] Properties to set
                 * @returns {havocai.messages.v0.TrackList} TrackList instance
                 */
                TrackList.create = function create(properties) {
                    return new TrackList(properties);
                };

                /**
                 * Encodes the specified TrackList message. Does not implicitly {@link havocai.messages.v0.TrackList.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.TrackList
                 * @static
                 * @param {havocai.messages.v0.ITrackList} message TrackList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrackList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (let i = 0; i < message.values.length; ++i)
                            $root.havocai.messages.v0.Track.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TrackList message, length delimited. Does not implicitly {@link havocai.messages.v0.TrackList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.TrackList
                 * @static
                 * @param {havocai.messages.v0.ITrackList} message TrackList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrackList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TrackList message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.TrackList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.TrackList} TrackList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrackList.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.TrackList();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.values && message.values.length))
                                    message.values = [];
                                message.values.push($root.havocai.messages.v0.Track.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TrackList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.TrackList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.TrackList} TrackList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrackList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TrackList message.
                 * @function verify
                 * @memberof havocai.messages.v0.TrackList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TrackList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (let i = 0; i < message.values.length; ++i) {
                            let error = $root.havocai.messages.v0.Track.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TrackList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.TrackList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.TrackList} TrackList
                 */
                TrackList.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.TrackList)
                        return object;
                    let message = new $root.havocai.messages.v0.TrackList();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".havocai.messages.v0.TrackList.values: array expected");
                        message.values = [];
                        for (let i = 0; i < object.values.length; ++i) {
                            if (typeof object.values[i] !== "object")
                                throw TypeError(".havocai.messages.v0.TrackList.values: object expected");
                            message.values[i] = $root.havocai.messages.v0.Track.fromObject(object.values[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TrackList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.TrackList
                 * @static
                 * @param {havocai.messages.v0.TrackList} message TrackList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TrackList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (let j = 0; j < message.values.length; ++j)
                            object.values[j] = $root.havocai.messages.v0.Track.toObject(message.values[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this TrackList to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.TrackList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TrackList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TrackList
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.TrackList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TrackList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.TrackList";
                };

                return TrackList;
            })();

            v0.Team = (function() {

                /**
                 * Properties of a Team.
                 * @memberof havocai.messages.v0
                 * @interface ITeam
                 * @property {havocai.messages.v0.IMetadata|null} [meta] Team meta
                 * @property {havocai.messages.v0.IResourceRef|null} [sector] Team sector
                 * @property {Array.<havocai.messages.v0.IResourceRef>|null} [boats] Team boats
                 * @property {Array.<havocai.messages.v0.IGeoFence>|null} [geoFences] Team geoFences
                 * @property {havocai.messages.v0.IUser|null} [commandUser] Team commandUser
                 * @property {havocai.messages.v0.ITeamStatus|null} [status] Team status
                 */

                /**
                 * Constructs a new Team.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Team.
                 * @implements ITeam
                 * @constructor
                 * @param {havocai.messages.v0.ITeam=} [properties] Properties to set
                 */
                function Team(properties) {
                    this.boats = [];
                    this.geoFences = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Team meta.
                 * @member {havocai.messages.v0.IMetadata|null|undefined} meta
                 * @memberof havocai.messages.v0.Team
                 * @instance
                 */
                Team.prototype.meta = null;

                /**
                 * Team sector.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} sector
                 * @memberof havocai.messages.v0.Team
                 * @instance
                 */
                Team.prototype.sector = null;

                /**
                 * Team boats.
                 * @member {Array.<havocai.messages.v0.IResourceRef>} boats
                 * @memberof havocai.messages.v0.Team
                 * @instance
                 */
                Team.prototype.boats = $util.emptyArray;

                /**
                 * Team geoFences.
                 * @member {Array.<havocai.messages.v0.IGeoFence>} geoFences
                 * @memberof havocai.messages.v0.Team
                 * @instance
                 */
                Team.prototype.geoFences = $util.emptyArray;

                /**
                 * Team commandUser.
                 * @member {havocai.messages.v0.IUser|null|undefined} commandUser
                 * @memberof havocai.messages.v0.Team
                 * @instance
                 */
                Team.prototype.commandUser = null;

                /**
                 * Team status.
                 * @member {havocai.messages.v0.ITeamStatus|null|undefined} status
                 * @memberof havocai.messages.v0.Team
                 * @instance
                 */
                Team.prototype.status = null;

                /**
                 * Creates a new Team instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Team
                 * @static
                 * @param {havocai.messages.v0.ITeam=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Team} Team instance
                 */
                Team.create = function create(properties) {
                    return new Team(properties);
                };

                /**
                 * Encodes the specified Team message. Does not implicitly {@link havocai.messages.v0.Team.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Team
                 * @static
                 * @param {havocai.messages.v0.ITeam} message Team message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Team.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.meta != null && Object.hasOwnProperty.call(message, "meta"))
                        $root.havocai.messages.v0.Metadata.encode(message.meta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.sector != null && Object.hasOwnProperty.call(message, "sector"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.sector, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.boats != null && message.boats.length)
                        for (let i = 0; i < message.boats.length; ++i)
                            $root.havocai.messages.v0.ResourceRef.encode(message.boats[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.geoFences != null && message.geoFences.length)
                        for (let i = 0; i < message.geoFences.length; ++i)
                            $root.havocai.messages.v0.GeoFence.encode(message.geoFences[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.commandUser != null && Object.hasOwnProperty.call(message, "commandUser"))
                        $root.havocai.messages.v0.User.encode(message.commandUser, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        $root.havocai.messages.v0.TeamStatus.encode(message.status, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Team message, length delimited. Does not implicitly {@link havocai.messages.v0.Team.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Team
                 * @static
                 * @param {havocai.messages.v0.ITeam} message Team message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Team.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Team message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Team
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Team} Team
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Team.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Team();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.meta = $root.havocai.messages.v0.Metadata.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.sector = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                if (!(message.boats && message.boats.length))
                                    message.boats = [];
                                message.boats.push($root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32()));
                                break;
                            }
                        case 4: {
                                if (!(message.geoFences && message.geoFences.length))
                                    message.geoFences = [];
                                message.geoFences.push($root.havocai.messages.v0.GeoFence.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                message.commandUser = $root.havocai.messages.v0.User.decode(reader, reader.uint32());
                                break;
                            }
                        case 15: {
                                message.status = $root.havocai.messages.v0.TeamStatus.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Team message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Team
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Team} Team
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Team.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Team message.
                 * @function verify
                 * @memberof havocai.messages.v0.Team
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Team.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.meta != null && message.hasOwnProperty("meta")) {
                        let error = $root.havocai.messages.v0.Metadata.verify(message.meta);
                        if (error)
                            return "meta." + error;
                    }
                    if (message.sector != null && message.hasOwnProperty("sector")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.sector);
                        if (error)
                            return "sector." + error;
                    }
                    if (message.boats != null && message.hasOwnProperty("boats")) {
                        if (!Array.isArray(message.boats))
                            return "boats: array expected";
                        for (let i = 0; i < message.boats.length; ++i) {
                            let error = $root.havocai.messages.v0.ResourceRef.verify(message.boats[i]);
                            if (error)
                                return "boats." + error;
                        }
                    }
                    if (message.geoFences != null && message.hasOwnProperty("geoFences")) {
                        if (!Array.isArray(message.geoFences))
                            return "geoFences: array expected";
                        for (let i = 0; i < message.geoFences.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoFence.verify(message.geoFences[i]);
                            if (error)
                                return "geoFences." + error;
                        }
                    }
                    if (message.commandUser != null && message.hasOwnProperty("commandUser")) {
                        let error = $root.havocai.messages.v0.User.verify(message.commandUser);
                        if (error)
                            return "commandUser." + error;
                    }
                    if (message.status != null && message.hasOwnProperty("status")) {
                        let error = $root.havocai.messages.v0.TeamStatus.verify(message.status);
                        if (error)
                            return "status." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Team message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Team
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Team} Team
                 */
                Team.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Team)
                        return object;
                    let message = new $root.havocai.messages.v0.Team();
                    if (object.meta != null) {
                        if (typeof object.meta !== "object")
                            throw TypeError(".havocai.messages.v0.Team.meta: object expected");
                        message.meta = $root.havocai.messages.v0.Metadata.fromObject(object.meta);
                    }
                    if (object.sector != null) {
                        if (typeof object.sector !== "object")
                            throw TypeError(".havocai.messages.v0.Team.sector: object expected");
                        message.sector = $root.havocai.messages.v0.ResourceRef.fromObject(object.sector);
                    }
                    if (object.boats) {
                        if (!Array.isArray(object.boats))
                            throw TypeError(".havocai.messages.v0.Team.boats: array expected");
                        message.boats = [];
                        for (let i = 0; i < object.boats.length; ++i) {
                            if (typeof object.boats[i] !== "object")
                                throw TypeError(".havocai.messages.v0.Team.boats: object expected");
                            message.boats[i] = $root.havocai.messages.v0.ResourceRef.fromObject(object.boats[i]);
                        }
                    }
                    if (object.geoFences) {
                        if (!Array.isArray(object.geoFences))
                            throw TypeError(".havocai.messages.v0.Team.geoFences: array expected");
                        message.geoFences = [];
                        for (let i = 0; i < object.geoFences.length; ++i) {
                            if (typeof object.geoFences[i] !== "object")
                                throw TypeError(".havocai.messages.v0.Team.geoFences: object expected");
                            message.geoFences[i] = $root.havocai.messages.v0.GeoFence.fromObject(object.geoFences[i]);
                        }
                    }
                    if (object.commandUser != null) {
                        if (typeof object.commandUser !== "object")
                            throw TypeError(".havocai.messages.v0.Team.commandUser: object expected");
                        message.commandUser = $root.havocai.messages.v0.User.fromObject(object.commandUser);
                    }
                    if (object.status != null) {
                        if (typeof object.status !== "object")
                            throw TypeError(".havocai.messages.v0.Team.status: object expected");
                        message.status = $root.havocai.messages.v0.TeamStatus.fromObject(object.status);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Team message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Team
                 * @static
                 * @param {havocai.messages.v0.Team} message Team
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Team.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.boats = [];
                        object.geoFences = [];
                    }
                    if (options.defaults) {
                        object.meta = null;
                        object.sector = null;
                        object.commandUser = null;
                        object.status = null;
                    }
                    if (message.meta != null && message.hasOwnProperty("meta"))
                        object.meta = $root.havocai.messages.v0.Metadata.toObject(message.meta, options);
                    if (message.sector != null && message.hasOwnProperty("sector"))
                        object.sector = $root.havocai.messages.v0.ResourceRef.toObject(message.sector, options);
                    if (message.boats && message.boats.length) {
                        object.boats = [];
                        for (let j = 0; j < message.boats.length; ++j)
                            object.boats[j] = $root.havocai.messages.v0.ResourceRef.toObject(message.boats[j], options);
                    }
                    if (message.geoFences && message.geoFences.length) {
                        object.geoFences = [];
                        for (let j = 0; j < message.geoFences.length; ++j)
                            object.geoFences[j] = $root.havocai.messages.v0.GeoFence.toObject(message.geoFences[j], options);
                    }
                    if (message.commandUser != null && message.hasOwnProperty("commandUser"))
                        object.commandUser = $root.havocai.messages.v0.User.toObject(message.commandUser, options);
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = $root.havocai.messages.v0.TeamStatus.toObject(message.status, options);
                    return object;
                };

                /**
                 * Converts this Team to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Team
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Team.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Team
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Team
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Team.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Team";
                };

                return Team;
            })();

            v0.TeamStatus = (function() {

                /**
                 * Properties of a TeamStatus.
                 * @memberof havocai.messages.v0
                 * @interface ITeamStatus
                 * @property {number|Long|null} [revisionTime] TeamStatus revisionTime
                 * @property {havocai.messages.v0.IPlayStatus|null} [play] TeamStatus play
                 * @property {havocai.messages.v0.IResourceRef|null} [playExecution] TeamStatus playExecution
                 * @property {Array.<havocai.messages.v0.IGeoPoint>|null} [routeCorridor] TeamStatus routeCorridor
                 */

                /**
                 * Constructs a new TeamStatus.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a TeamStatus.
                 * @implements ITeamStatus
                 * @constructor
                 * @param {havocai.messages.v0.ITeamStatus=} [properties] Properties to set
                 */
                function TeamStatus(properties) {
                    this.routeCorridor = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TeamStatus revisionTime.
                 * @member {number|Long} revisionTime
                 * @memberof havocai.messages.v0.TeamStatus
                 * @instance
                 */
                TeamStatus.prototype.revisionTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TeamStatus play.
                 * @member {havocai.messages.v0.IPlayStatus|null|undefined} play
                 * @memberof havocai.messages.v0.TeamStatus
                 * @instance
                 */
                TeamStatus.prototype.play = null;

                /**
                 * TeamStatus playExecution.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} playExecution
                 * @memberof havocai.messages.v0.TeamStatus
                 * @instance
                 */
                TeamStatus.prototype.playExecution = null;

                /**
                 * TeamStatus routeCorridor.
                 * @member {Array.<havocai.messages.v0.IGeoPoint>} routeCorridor
                 * @memberof havocai.messages.v0.TeamStatus
                 * @instance
                 */
                TeamStatus.prototype.routeCorridor = $util.emptyArray;

                /**
                 * Creates a new TeamStatus instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.TeamStatus
                 * @static
                 * @param {havocai.messages.v0.ITeamStatus=} [properties] Properties to set
                 * @returns {havocai.messages.v0.TeamStatus} TeamStatus instance
                 */
                TeamStatus.create = function create(properties) {
                    return new TeamStatus(properties);
                };

                /**
                 * Encodes the specified TeamStatus message. Does not implicitly {@link havocai.messages.v0.TeamStatus.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.TeamStatus
                 * @static
                 * @param {havocai.messages.v0.ITeamStatus} message TeamStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TeamStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.revisionTime != null && Object.hasOwnProperty.call(message, "revisionTime"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.revisionTime);
                    if (message.play != null && Object.hasOwnProperty.call(message, "play"))
                        $root.havocai.messages.v0.PlayStatus.encode(message.play, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.playExecution != null && Object.hasOwnProperty.call(message, "playExecution"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.playExecution, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.routeCorridor != null && message.routeCorridor.length)
                        for (let i = 0; i < message.routeCorridor.length; ++i)
                            $root.havocai.messages.v0.GeoPoint.encode(message.routeCorridor[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TeamStatus message, length delimited. Does not implicitly {@link havocai.messages.v0.TeamStatus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.TeamStatus
                 * @static
                 * @param {havocai.messages.v0.ITeamStatus} message TeamStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TeamStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TeamStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.TeamStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.TeamStatus} TeamStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TeamStatus.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.TeamStatus();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.revisionTime = reader.int64();
                                break;
                            }
                        case 2: {
                                message.play = $root.havocai.messages.v0.PlayStatus.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.playExecution = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                if (!(message.routeCorridor && message.routeCorridor.length))
                                    message.routeCorridor = [];
                                message.routeCorridor.push($root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TeamStatus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.TeamStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.TeamStatus} TeamStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TeamStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TeamStatus message.
                 * @function verify
                 * @memberof havocai.messages.v0.TeamStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TeamStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.revisionTime != null && message.hasOwnProperty("revisionTime"))
                        if (!$util.isInteger(message.revisionTime) && !(message.revisionTime && $util.isInteger(message.revisionTime.low) && $util.isInteger(message.revisionTime.high)))
                            return "revisionTime: integer|Long expected";
                    if (message.play != null && message.hasOwnProperty("play")) {
                        let error = $root.havocai.messages.v0.PlayStatus.verify(message.play);
                        if (error)
                            return "play." + error;
                    }
                    if (message.playExecution != null && message.hasOwnProperty("playExecution")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.playExecution);
                        if (error)
                            return "playExecution." + error;
                    }
                    if (message.routeCorridor != null && message.hasOwnProperty("routeCorridor")) {
                        if (!Array.isArray(message.routeCorridor))
                            return "routeCorridor: array expected";
                        for (let i = 0; i < message.routeCorridor.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoPoint.verify(message.routeCorridor[i]);
                            if (error)
                                return "routeCorridor." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TeamStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.TeamStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.TeamStatus} TeamStatus
                 */
                TeamStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.TeamStatus)
                        return object;
                    let message = new $root.havocai.messages.v0.TeamStatus();
                    if (object.revisionTime != null)
                        if ($util.Long)
                            (message.revisionTime = $util.Long.fromValue(object.revisionTime)).unsigned = false;
                        else if (typeof object.revisionTime === "string")
                            message.revisionTime = parseInt(object.revisionTime, 10);
                        else if (typeof object.revisionTime === "number")
                            message.revisionTime = object.revisionTime;
                        else if (typeof object.revisionTime === "object")
                            message.revisionTime = new $util.LongBits(object.revisionTime.low >>> 0, object.revisionTime.high >>> 0).toNumber();
                    if (object.play != null) {
                        if (typeof object.play !== "object")
                            throw TypeError(".havocai.messages.v0.TeamStatus.play: object expected");
                        message.play = $root.havocai.messages.v0.PlayStatus.fromObject(object.play);
                    }
                    if (object.playExecution != null) {
                        if (typeof object.playExecution !== "object")
                            throw TypeError(".havocai.messages.v0.TeamStatus.playExecution: object expected");
                        message.playExecution = $root.havocai.messages.v0.ResourceRef.fromObject(object.playExecution);
                    }
                    if (object.routeCorridor) {
                        if (!Array.isArray(object.routeCorridor))
                            throw TypeError(".havocai.messages.v0.TeamStatus.routeCorridor: array expected");
                        message.routeCorridor = [];
                        for (let i = 0; i < object.routeCorridor.length; ++i) {
                            if (typeof object.routeCorridor[i] !== "object")
                                throw TypeError(".havocai.messages.v0.TeamStatus.routeCorridor: object expected");
                            message.routeCorridor[i] = $root.havocai.messages.v0.GeoPoint.fromObject(object.routeCorridor[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TeamStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.TeamStatus
                 * @static
                 * @param {havocai.messages.v0.TeamStatus} message TeamStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TeamStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.routeCorridor = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.revisionTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.revisionTime = options.longs === String ? "0" : 0;
                        object.play = null;
                        object.playExecution = null;
                    }
                    if (message.revisionTime != null && message.hasOwnProperty("revisionTime"))
                        if (typeof message.revisionTime === "number")
                            object.revisionTime = options.longs === String ? String(message.revisionTime) : message.revisionTime;
                        else
                            object.revisionTime = options.longs === String ? $util.Long.prototype.toString.call(message.revisionTime) : options.longs === Number ? new $util.LongBits(message.revisionTime.low >>> 0, message.revisionTime.high >>> 0).toNumber() : message.revisionTime;
                    if (message.play != null && message.hasOwnProperty("play"))
                        object.play = $root.havocai.messages.v0.PlayStatus.toObject(message.play, options);
                    if (message.playExecution != null && message.hasOwnProperty("playExecution"))
                        object.playExecution = $root.havocai.messages.v0.ResourceRef.toObject(message.playExecution, options);
                    if (message.routeCorridor && message.routeCorridor.length) {
                        object.routeCorridor = [];
                        for (let j = 0; j < message.routeCorridor.length; ++j)
                            object.routeCorridor[j] = $root.havocai.messages.v0.GeoPoint.toObject(message.routeCorridor[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this TeamStatus to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.TeamStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TeamStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TeamStatus
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.TeamStatus
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TeamStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.TeamStatus";
                };

                return TeamStatus;
            })();

            v0.TeamList = (function() {

                /**
                 * Properties of a TeamList.
                 * @memberof havocai.messages.v0
                 * @interface ITeamList
                 * @property {Array.<havocai.messages.v0.ITeam>|null} [values] TeamList values
                 */

                /**
                 * Constructs a new TeamList.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a TeamList.
                 * @implements ITeamList
                 * @constructor
                 * @param {havocai.messages.v0.ITeamList=} [properties] Properties to set
                 */
                function TeamList(properties) {
                    this.values = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TeamList values.
                 * @member {Array.<havocai.messages.v0.ITeam>} values
                 * @memberof havocai.messages.v0.TeamList
                 * @instance
                 */
                TeamList.prototype.values = $util.emptyArray;

                /**
                 * Creates a new TeamList instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.TeamList
                 * @static
                 * @param {havocai.messages.v0.ITeamList=} [properties] Properties to set
                 * @returns {havocai.messages.v0.TeamList} TeamList instance
                 */
                TeamList.create = function create(properties) {
                    return new TeamList(properties);
                };

                /**
                 * Encodes the specified TeamList message. Does not implicitly {@link havocai.messages.v0.TeamList.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.TeamList
                 * @static
                 * @param {havocai.messages.v0.ITeamList} message TeamList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TeamList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (let i = 0; i < message.values.length; ++i)
                            $root.havocai.messages.v0.Team.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TeamList message, length delimited. Does not implicitly {@link havocai.messages.v0.TeamList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.TeamList
                 * @static
                 * @param {havocai.messages.v0.ITeamList} message TeamList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TeamList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TeamList message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.TeamList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.TeamList} TeamList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TeamList.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.TeamList();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.values && message.values.length))
                                    message.values = [];
                                message.values.push($root.havocai.messages.v0.Team.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TeamList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.TeamList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.TeamList} TeamList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TeamList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TeamList message.
                 * @function verify
                 * @memberof havocai.messages.v0.TeamList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TeamList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (let i = 0; i < message.values.length; ++i) {
                            let error = $root.havocai.messages.v0.Team.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TeamList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.TeamList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.TeamList} TeamList
                 */
                TeamList.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.TeamList)
                        return object;
                    let message = new $root.havocai.messages.v0.TeamList();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".havocai.messages.v0.TeamList.values: array expected");
                        message.values = [];
                        for (let i = 0; i < object.values.length; ++i) {
                            if (typeof object.values[i] !== "object")
                                throw TypeError(".havocai.messages.v0.TeamList.values: object expected");
                            message.values[i] = $root.havocai.messages.v0.Team.fromObject(object.values[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TeamList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.TeamList
                 * @static
                 * @param {havocai.messages.v0.TeamList} message TeamList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TeamList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (let j = 0; j < message.values.length; ++j)
                            object.values[j] = $root.havocai.messages.v0.Team.toObject(message.values[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this TeamList to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.TeamList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TeamList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TeamList
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.TeamList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TeamList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.TeamList";
                };

                return TeamList;
            })();

            v0.Boat = (function() {

                /**
                 * Properties of a Boat.
                 * @memberof havocai.messages.v0
                 * @interface IBoat
                 * @property {havocai.messages.v0.IMetadata|null} [meta] Boat meta
                 * @property {havocai.messages.v0.IResourceRef|null} [team] Boat team
                 * @property {havocai.messages.v0.VehicleType|null} [type] Boat type
                 * @property {havocai.messages.v0.VehicleSizeClass|null} [sizeClass] Boat sizeClass
                 * @property {havocai.messages.v0.IBoatStatus|null} [status] Boat status
                 */

                /**
                 * Constructs a new Boat.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Boat.
                 * @implements IBoat
                 * @constructor
                 * @param {havocai.messages.v0.IBoat=} [properties] Properties to set
                 */
                function Boat(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Boat meta.
                 * @member {havocai.messages.v0.IMetadata|null|undefined} meta
                 * @memberof havocai.messages.v0.Boat
                 * @instance
                 */
                Boat.prototype.meta = null;

                /**
                 * Boat team.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} team
                 * @memberof havocai.messages.v0.Boat
                 * @instance
                 */
                Boat.prototype.team = null;

                /**
                 * Boat type.
                 * @member {havocai.messages.v0.VehicleType} type
                 * @memberof havocai.messages.v0.Boat
                 * @instance
                 */
                Boat.prototype.type = 0;

                /**
                 * Boat sizeClass.
                 * @member {havocai.messages.v0.VehicleSizeClass} sizeClass
                 * @memberof havocai.messages.v0.Boat
                 * @instance
                 */
                Boat.prototype.sizeClass = 0;

                /**
                 * Boat status.
                 * @member {havocai.messages.v0.IBoatStatus|null|undefined} status
                 * @memberof havocai.messages.v0.Boat
                 * @instance
                 */
                Boat.prototype.status = null;

                /**
                 * Creates a new Boat instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Boat
                 * @static
                 * @param {havocai.messages.v0.IBoat=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Boat} Boat instance
                 */
                Boat.create = function create(properties) {
                    return new Boat(properties);
                };

                /**
                 * Encodes the specified Boat message. Does not implicitly {@link havocai.messages.v0.Boat.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Boat
                 * @static
                 * @param {havocai.messages.v0.IBoat} message Boat message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Boat.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.meta != null && Object.hasOwnProperty.call(message, "meta"))
                        $root.havocai.messages.v0.Metadata.encode(message.meta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.team, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                    if (message.sizeClass != null && Object.hasOwnProperty.call(message, "sizeClass"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.sizeClass);
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        $root.havocai.messages.v0.BoatStatus.encode(message.status, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Boat message, length delimited. Does not implicitly {@link havocai.messages.v0.Boat.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Boat
                 * @static
                 * @param {havocai.messages.v0.IBoat} message Boat message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Boat.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Boat message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Boat
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Boat} Boat
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Boat.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Boat();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.meta = $root.havocai.messages.v0.Metadata.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.team = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.type = reader.int32();
                                break;
                            }
                        case 4: {
                                message.sizeClass = reader.int32();
                                break;
                            }
                        case 15: {
                                message.status = $root.havocai.messages.v0.BoatStatus.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Boat message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Boat
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Boat} Boat
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Boat.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Boat message.
                 * @function verify
                 * @memberof havocai.messages.v0.Boat
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Boat.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.meta != null && message.hasOwnProperty("meta")) {
                        let error = $root.havocai.messages.v0.Metadata.verify(message.meta);
                        if (error)
                            return "meta." + error;
                    }
                    if (message.team != null && message.hasOwnProperty("team")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.team);
                        if (error)
                            return "team." + error;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 99:
                            break;
                        }
                    if (message.sizeClass != null && message.hasOwnProperty("sizeClass"))
                        switch (message.sizeClass) {
                        default:
                            return "sizeClass: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.status != null && message.hasOwnProperty("status")) {
                        let error = $root.havocai.messages.v0.BoatStatus.verify(message.status);
                        if (error)
                            return "status." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Boat message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Boat
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Boat} Boat
                 */
                Boat.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Boat)
                        return object;
                    let message = new $root.havocai.messages.v0.Boat();
                    if (object.meta != null) {
                        if (typeof object.meta !== "object")
                            throw TypeError(".havocai.messages.v0.Boat.meta: object expected");
                        message.meta = $root.havocai.messages.v0.Metadata.fromObject(object.meta);
                    }
                    if (object.team != null) {
                        if (typeof object.team !== "object")
                            throw TypeError(".havocai.messages.v0.Boat.team: object expected");
                        message.team = $root.havocai.messages.v0.ResourceRef.fromObject(object.team);
                    }
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "VEHICLE_TYPE_UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "VEHICLE_TYPE_BOAT":
                    case 1:
                        message.type = 1;
                        break;
                    case "VEHICLE_TYPE_ROVER":
                    case 2:
                        message.type = 2;
                        break;
                    case "VEHICLE_TYPE_BARGE":
                    case 3:
                        message.type = 3;
                        break;
                    case "VEHICLE_TYPE_AERIAL_OTHER":
                    case 4:
                        message.type = 4;
                        break;
                    case "VEHICLE_TYPE_AERIAL_MULTIROTOR":
                    case 5:
                        message.type = 5;
                        break;
                    case "VEHICLE_TYPE_AERIAL_FIXED_WING":
                    case 6:
                        message.type = 6;
                        break;
                    case "VEHICLE_TYPE_AERIAL_HELICOPTER":
                    case 7:
                        message.type = 7;
                        break;
                    case "VEHICLE_TYPE_AERIAL_AIRSHIP":
                    case 8:
                        message.type = 8;
                        break;
                    case "VEHICLE_TYPE_GROUND_OTHER":
                    case 9:
                        message.type = 9;
                        break;
                    case "VEHICLE_TYPE_GROUND_WHEELED":
                    case 10:
                        message.type = 10;
                        break;
                    case "VEHICLE_TYPE_GROUND_TRACKED":
                    case 11:
                        message.type = 11;
                        break;
                    case "VEHICLE_TYPE_GROUND_LEGGED":
                    case 12:
                        message.type = 12;
                        break;
                    case "VEHICLE_TYPE_SURFACE_OTHER":
                    case 13:
                        message.type = 13;
                        break;
                    case "VEHICLE_TYPE_SURFACE_VESSEL":
                    case 14:
                        message.type = 14;
                        break;
                    case "VEHICLE_TYPE_SURFACE_HOVERCRAFT":
                    case 15:
                        message.type = 15;
                        break;
                    case "VEHICLE_TYPE_SURFACE_AMPHIBIOUS":
                    case 16:
                        message.type = 16;
                        break;
                    case "VEHICLE_TYPE_UNDERWATER_OTHER":
                    case 17:
                        message.type = 17;
                        break;
                    case "VEHICLE_TYPE_SURFACE_RUBBER_DUCKIE":
                    case 99:
                        message.type = 99;
                        break;
                    }
                    switch (object.sizeClass) {
                    default:
                        if (typeof object.sizeClass === "number") {
                            message.sizeClass = object.sizeClass;
                            break;
                        }
                        break;
                    case "VEHICLE_SIZE_CLASS_UNKNOWN":
                    case 0:
                        message.sizeClass = 0;
                        break;
                    case "VEHICLE_SIZE_CLASS_SMALL":
                    case 1:
                        message.sizeClass = 1;
                        break;
                    case "VEHICLE_SIZE_CLASS_MEDIUM":
                    case 2:
                        message.sizeClass = 2;
                        break;
                    case "VEHICLE_SIZE_CLASS_LARGE":
                    case 3:
                        message.sizeClass = 3;
                        break;
                    }
                    if (object.status != null) {
                        if (typeof object.status !== "object")
                            throw TypeError(".havocai.messages.v0.Boat.status: object expected");
                        message.status = $root.havocai.messages.v0.BoatStatus.fromObject(object.status);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Boat message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Boat
                 * @static
                 * @param {havocai.messages.v0.Boat} message Boat
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Boat.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.meta = null;
                        object.team = null;
                        object.type = options.enums === String ? "VEHICLE_TYPE_UNKNOWN" : 0;
                        object.sizeClass = options.enums === String ? "VEHICLE_SIZE_CLASS_UNKNOWN" : 0;
                        object.status = null;
                    }
                    if (message.meta != null && message.hasOwnProperty("meta"))
                        object.meta = $root.havocai.messages.v0.Metadata.toObject(message.meta, options);
                    if (message.team != null && message.hasOwnProperty("team"))
                        object.team = $root.havocai.messages.v0.ResourceRef.toObject(message.team, options);
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.havocai.messages.v0.VehicleType[message.type] === undefined ? message.type : $root.havocai.messages.v0.VehicleType[message.type] : message.type;
                    if (message.sizeClass != null && message.hasOwnProperty("sizeClass"))
                        object.sizeClass = options.enums === String ? $root.havocai.messages.v0.VehicleSizeClass[message.sizeClass] === undefined ? message.sizeClass : $root.havocai.messages.v0.VehicleSizeClass[message.sizeClass] : message.sizeClass;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = $root.havocai.messages.v0.BoatStatus.toObject(message.status, options);
                    return object;
                };

                /**
                 * Converts this Boat to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Boat
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Boat.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Boat
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Boat
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Boat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Boat";
                };

                return Boat;
            })();

            v0.BoatStatus = (function() {

                /**
                 * Properties of a BoatStatus.
                 * @memberof havocai.messages.v0
                 * @interface IBoatStatus
                 * @property {number|Long|null} [revisionTime] BoatStatus revisionTime
                 * @property {havocai.messages.v0.IGeoPose|null} [position] BoatStatus position
                 * @property {number|null} [heading] BoatStatus heading
                 * @property {number|null} [course] BoatStatus course
                 * @property {number|null} [velocityEast] BoatStatus velocityEast
                 * @property {number|null} [velocityNorth] BoatStatus velocityNorth
                 * @property {number|null} [speed] BoatStatus speed
                 * @property {havocai.messages.v0.ITask|null} [task] BoatStatus task
                 * @property {havocai.messages.v0.ITaskExecutionStatus|null} [taskExecution] BoatStatus taskExecution
                 * @property {havocai.messages.v0.IResourceRef|null} [playExecution] BoatStatus playExecution
                 * @property {Array.<havocai.messages.v0.IGeoPoint>|null} [route] BoatStatus route
                 * @property {Array.<havocai.messages.v0.IGeoPose>|null} [trace] BoatStatus trace
                 * @property {havocai.messages.v0.IResourceRef|null} [sector] BoatStatus sector
                 * @property {boolean|null} [vehicleArmed] BoatStatus vehicleArmed
                 * @property {havocai.messages.v0.VehicleInterfaceStateType|null} [vehicleInterfaceState] BoatStatus vehicleInterfaceState
                 * @property {Uint8Array|null} [thirdPartyData] BoatStatus thirdPartyData
                 * @property {Array.<havocai.messages.v0.IComponent>|null} [components] BoatStatus components
                 * @property {Array.<havocai.messages.v0.IMetric>|null} [metrics] BoatStatus metrics
                 * @property {Array.<string>|null} [videoStreamUrls] BoatStatus videoStreamUrls
                 * @property {havocai.messages.v0.CDRState|null} [cdrState] BoatStatus cdrState
                 * @property {Array.<havocai.messages.v0.IError>|null} [errors] BoatStatus errors
                 */

                /**
                 * Constructs a new BoatStatus.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a BoatStatus.
                 * @implements IBoatStatus
                 * @constructor
                 * @param {havocai.messages.v0.IBoatStatus=} [properties] Properties to set
                 */
                function BoatStatus(properties) {
                    this.route = [];
                    this.trace = [];
                    this.components = [];
                    this.metrics = [];
                    this.videoStreamUrls = [];
                    this.errors = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BoatStatus revisionTime.
                 * @member {number|Long} revisionTime
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.revisionTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * BoatStatus position.
                 * @member {havocai.messages.v0.IGeoPose|null|undefined} position
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.position = null;

                /**
                 * BoatStatus heading.
                 * @member {number} heading
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.heading = 0;

                /**
                 * BoatStatus course.
                 * @member {number} course
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.course = 0;

                /**
                 * BoatStatus velocityEast.
                 * @member {number} velocityEast
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.velocityEast = 0;

                /**
                 * BoatStatus velocityNorth.
                 * @member {number} velocityNorth
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.velocityNorth = 0;

                /**
                 * BoatStatus speed.
                 * @member {number} speed
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.speed = 0;

                /**
                 * BoatStatus task.
                 * @member {havocai.messages.v0.ITask|null|undefined} task
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.task = null;

                /**
                 * BoatStatus taskExecution.
                 * @member {havocai.messages.v0.ITaskExecutionStatus|null|undefined} taskExecution
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.taskExecution = null;

                /**
                 * BoatStatus playExecution.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} playExecution
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.playExecution = null;

                /**
                 * BoatStatus route.
                 * @member {Array.<havocai.messages.v0.IGeoPoint>} route
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.route = $util.emptyArray;

                /**
                 * BoatStatus trace.
                 * @member {Array.<havocai.messages.v0.IGeoPose>} trace
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.trace = $util.emptyArray;

                /**
                 * BoatStatus sector.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} sector
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.sector = null;

                /**
                 * BoatStatus vehicleArmed.
                 * @member {boolean} vehicleArmed
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.vehicleArmed = false;

                /**
                 * BoatStatus vehicleInterfaceState.
                 * @member {havocai.messages.v0.VehicleInterfaceStateType} vehicleInterfaceState
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.vehicleInterfaceState = 0;

                /**
                 * BoatStatus thirdPartyData.
                 * @member {Uint8Array} thirdPartyData
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.thirdPartyData = $util.newBuffer([]);

                /**
                 * BoatStatus components.
                 * @member {Array.<havocai.messages.v0.IComponent>} components
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.components = $util.emptyArray;

                /**
                 * BoatStatus metrics.
                 * @member {Array.<havocai.messages.v0.IMetric>} metrics
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.metrics = $util.emptyArray;

                /**
                 * BoatStatus videoStreamUrls.
                 * @member {Array.<string>} videoStreamUrls
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.videoStreamUrls = $util.emptyArray;

                /**
                 * BoatStatus cdrState.
                 * @member {havocai.messages.v0.CDRState} cdrState
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.cdrState = 0;

                /**
                 * BoatStatus errors.
                 * @member {Array.<havocai.messages.v0.IError>} errors
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 */
                BoatStatus.prototype.errors = $util.emptyArray;

                /**
                 * Creates a new BoatStatus instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.BoatStatus
                 * @static
                 * @param {havocai.messages.v0.IBoatStatus=} [properties] Properties to set
                 * @returns {havocai.messages.v0.BoatStatus} BoatStatus instance
                 */
                BoatStatus.create = function create(properties) {
                    return new BoatStatus(properties);
                };

                /**
                 * Encodes the specified BoatStatus message. Does not implicitly {@link havocai.messages.v0.BoatStatus.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.BoatStatus
                 * @static
                 * @param {havocai.messages.v0.IBoatStatus} message BoatStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoatStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.revisionTime != null && Object.hasOwnProperty.call(message, "revisionTime"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.revisionTime);
                    if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                        $root.havocai.messages.v0.GeoPose.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.heading != null && Object.hasOwnProperty.call(message, "heading"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.heading);
                    if (message.velocityEast != null && Object.hasOwnProperty.call(message, "velocityEast"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.velocityEast);
                    if (message.velocityNorth != null && Object.hasOwnProperty.call(message, "velocityNorth"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.velocityNorth);
                    if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.speed);
                    if (message.task != null && Object.hasOwnProperty.call(message, "task"))
                        $root.havocai.messages.v0.Task.encode(message.task, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.route != null && message.route.length)
                        for (let i = 0; i < message.route.length; ++i)
                            $root.havocai.messages.v0.GeoPoint.encode(message.route[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.trace != null && message.trace.length)
                        for (let i = 0; i < message.trace.length; ++i)
                            $root.havocai.messages.v0.GeoPose.encode(message.trace[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.sector != null && Object.hasOwnProperty.call(message, "sector"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.sector, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.vehicleInterfaceState != null && Object.hasOwnProperty.call(message, "vehicleInterfaceState"))
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.vehicleInterfaceState);
                    if (message.taskExecution != null && Object.hasOwnProperty.call(message, "taskExecution"))
                        $root.havocai.messages.v0.TaskExecutionStatus.encode(message.taskExecution, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.thirdPartyData != null && Object.hasOwnProperty.call(message, "thirdPartyData"))
                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.thirdPartyData);
                    if (message.components != null && message.components.length)
                        for (let i = 0; i < message.components.length; ++i)
                            $root.havocai.messages.v0.Component.encode(message.components[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.metrics != null && message.metrics.length)
                        for (let i = 0; i < message.metrics.length; ++i)
                            $root.havocai.messages.v0.Metric.encode(message.metrics[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.vehicleArmed != null && Object.hasOwnProperty.call(message, "vehicleArmed"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.vehicleArmed);
                    if (message.playExecution != null && Object.hasOwnProperty.call(message, "playExecution"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.playExecution, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if (message.videoStreamUrls != null && message.videoStreamUrls.length)
                        for (let i = 0; i < message.videoStreamUrls.length; ++i)
                            writer.uint32(/* id 18, wireType 2 =*/146).string(message.videoStreamUrls[i]);
                    if (message.course != null && Object.hasOwnProperty.call(message, "course"))
                        writer.uint32(/* id 19, wireType 1 =*/153).double(message.course);
                    if (message.errors != null && message.errors.length)
                        for (let i = 0; i < message.errors.length; ++i)
                            $root.havocai.messages.v0.Error.encode(message.errors[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.cdrState != null && Object.hasOwnProperty.call(message, "cdrState"))
                        writer.uint32(/* id 21, wireType 0 =*/168).int32(message.cdrState);
                    return writer;
                };

                /**
                 * Encodes the specified BoatStatus message, length delimited. Does not implicitly {@link havocai.messages.v0.BoatStatus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.BoatStatus
                 * @static
                 * @param {havocai.messages.v0.IBoatStatus} message BoatStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoatStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BoatStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.BoatStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.BoatStatus} BoatStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoatStatus.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.BoatStatus();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.revisionTime = reader.int64();
                                break;
                            }
                        case 2: {
                                message.position = $root.havocai.messages.v0.GeoPose.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.heading = reader.double();
                                break;
                            }
                        case 19: {
                                message.course = reader.double();
                                break;
                            }
                        case 4: {
                                message.velocityEast = reader.double();
                                break;
                            }
                        case 5: {
                                message.velocityNorth = reader.double();
                                break;
                            }
                        case 6: {
                                message.speed = reader.double();
                                break;
                            }
                        case 7: {
                                message.task = $root.havocai.messages.v0.Task.decode(reader, reader.uint32());
                                break;
                            }
                        case 12: {
                                message.taskExecution = $root.havocai.messages.v0.TaskExecutionStatus.decode(reader, reader.uint32());
                                break;
                            }
                        case 17: {
                                message.playExecution = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 8: {
                                if (!(message.route && message.route.length))
                                    message.route = [];
                                message.route.push($root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32()));
                                break;
                            }
                        case 9: {
                                if (!(message.trace && message.trace.length))
                                    message.trace = [];
                                message.trace.push($root.havocai.messages.v0.GeoPose.decode(reader, reader.uint32()));
                                break;
                            }
                        case 10: {
                                message.sector = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 16: {
                                message.vehicleArmed = reader.bool();
                                break;
                            }
                        case 11: {
                                message.vehicleInterfaceState = reader.int32();
                                break;
                            }
                        case 13: {
                                message.thirdPartyData = reader.bytes();
                                break;
                            }
                        case 14: {
                                if (!(message.components && message.components.length))
                                    message.components = [];
                                message.components.push($root.havocai.messages.v0.Component.decode(reader, reader.uint32()));
                                break;
                            }
                        case 15: {
                                if (!(message.metrics && message.metrics.length))
                                    message.metrics = [];
                                message.metrics.push($root.havocai.messages.v0.Metric.decode(reader, reader.uint32()));
                                break;
                            }
                        case 18: {
                                if (!(message.videoStreamUrls && message.videoStreamUrls.length))
                                    message.videoStreamUrls = [];
                                message.videoStreamUrls.push(reader.string());
                                break;
                            }
                        case 21: {
                                message.cdrState = reader.int32();
                                break;
                            }
                        case 20: {
                                if (!(message.errors && message.errors.length))
                                    message.errors = [];
                                message.errors.push($root.havocai.messages.v0.Error.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BoatStatus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.BoatStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.BoatStatus} BoatStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoatStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BoatStatus message.
                 * @function verify
                 * @memberof havocai.messages.v0.BoatStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BoatStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.revisionTime != null && message.hasOwnProperty("revisionTime"))
                        if (!$util.isInteger(message.revisionTime) && !(message.revisionTime && $util.isInteger(message.revisionTime.low) && $util.isInteger(message.revisionTime.high)))
                            return "revisionTime: integer|Long expected";
                    if (message.position != null && message.hasOwnProperty("position")) {
                        let error = $root.havocai.messages.v0.GeoPose.verify(message.position);
                        if (error)
                            return "position." + error;
                    }
                    if (message.heading != null && message.hasOwnProperty("heading"))
                        if (typeof message.heading !== "number")
                            return "heading: number expected";
                    if (message.course != null && message.hasOwnProperty("course"))
                        if (typeof message.course !== "number")
                            return "course: number expected";
                    if (message.velocityEast != null && message.hasOwnProperty("velocityEast"))
                        if (typeof message.velocityEast !== "number")
                            return "velocityEast: number expected";
                    if (message.velocityNorth != null && message.hasOwnProperty("velocityNorth"))
                        if (typeof message.velocityNorth !== "number")
                            return "velocityNorth: number expected";
                    if (message.speed != null && message.hasOwnProperty("speed"))
                        if (typeof message.speed !== "number")
                            return "speed: number expected";
                    if (message.task != null && message.hasOwnProperty("task")) {
                        let error = $root.havocai.messages.v0.Task.verify(message.task);
                        if (error)
                            return "task." + error;
                    }
                    if (message.taskExecution != null && message.hasOwnProperty("taskExecution")) {
                        let error = $root.havocai.messages.v0.TaskExecutionStatus.verify(message.taskExecution);
                        if (error)
                            return "taskExecution." + error;
                    }
                    if (message.playExecution != null && message.hasOwnProperty("playExecution")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.playExecution);
                        if (error)
                            return "playExecution." + error;
                    }
                    if (message.route != null && message.hasOwnProperty("route")) {
                        if (!Array.isArray(message.route))
                            return "route: array expected";
                        for (let i = 0; i < message.route.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoPoint.verify(message.route[i]);
                            if (error)
                                return "route." + error;
                        }
                    }
                    if (message.trace != null && message.hasOwnProperty("trace")) {
                        if (!Array.isArray(message.trace))
                            return "trace: array expected";
                        for (let i = 0; i < message.trace.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoPose.verify(message.trace[i]);
                            if (error)
                                return "trace." + error;
                        }
                    }
                    if (message.sector != null && message.hasOwnProperty("sector")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.sector);
                        if (error)
                            return "sector." + error;
                    }
                    if (message.vehicleArmed != null && message.hasOwnProperty("vehicleArmed"))
                        if (typeof message.vehicleArmed !== "boolean")
                            return "vehicleArmed: boolean expected";
                    if (message.vehicleInterfaceState != null && message.hasOwnProperty("vehicleInterfaceState"))
                        switch (message.vehicleInterfaceState) {
                        default:
                            return "vehicleInterfaceState: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    if (message.thirdPartyData != null && message.hasOwnProperty("thirdPartyData"))
                        if (!(message.thirdPartyData && typeof message.thirdPartyData.length === "number" || $util.isString(message.thirdPartyData)))
                            return "thirdPartyData: buffer expected";
                    if (message.components != null && message.hasOwnProperty("components")) {
                        if (!Array.isArray(message.components))
                            return "components: array expected";
                        for (let i = 0; i < message.components.length; ++i) {
                            let error = $root.havocai.messages.v0.Component.verify(message.components[i]);
                            if (error)
                                return "components." + error;
                        }
                    }
                    if (message.metrics != null && message.hasOwnProperty("metrics")) {
                        if (!Array.isArray(message.metrics))
                            return "metrics: array expected";
                        for (let i = 0; i < message.metrics.length; ++i) {
                            let error = $root.havocai.messages.v0.Metric.verify(message.metrics[i]);
                            if (error)
                                return "metrics." + error;
                        }
                    }
                    if (message.videoStreamUrls != null && message.hasOwnProperty("videoStreamUrls")) {
                        if (!Array.isArray(message.videoStreamUrls))
                            return "videoStreamUrls: array expected";
                        for (let i = 0; i < message.videoStreamUrls.length; ++i)
                            if (!$util.isString(message.videoStreamUrls[i]))
                                return "videoStreamUrls: string[] expected";
                    }
                    if (message.cdrState != null && message.hasOwnProperty("cdrState"))
                        switch (message.cdrState) {
                        default:
                            return "cdrState: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (let i = 0; i < message.errors.length; ++i) {
                            let error = $root.havocai.messages.v0.Error.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a BoatStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.BoatStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.BoatStatus} BoatStatus
                 */
                BoatStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.BoatStatus)
                        return object;
                    let message = new $root.havocai.messages.v0.BoatStatus();
                    if (object.revisionTime != null)
                        if ($util.Long)
                            (message.revisionTime = $util.Long.fromValue(object.revisionTime)).unsigned = false;
                        else if (typeof object.revisionTime === "string")
                            message.revisionTime = parseInt(object.revisionTime, 10);
                        else if (typeof object.revisionTime === "number")
                            message.revisionTime = object.revisionTime;
                        else if (typeof object.revisionTime === "object")
                            message.revisionTime = new $util.LongBits(object.revisionTime.low >>> 0, object.revisionTime.high >>> 0).toNumber();
                    if (object.position != null) {
                        if (typeof object.position !== "object")
                            throw TypeError(".havocai.messages.v0.BoatStatus.position: object expected");
                        message.position = $root.havocai.messages.v0.GeoPose.fromObject(object.position);
                    }
                    if (object.heading != null)
                        message.heading = Number(object.heading);
                    if (object.course != null)
                        message.course = Number(object.course);
                    if (object.velocityEast != null)
                        message.velocityEast = Number(object.velocityEast);
                    if (object.velocityNorth != null)
                        message.velocityNorth = Number(object.velocityNorth);
                    if (object.speed != null)
                        message.speed = Number(object.speed);
                    if (object.task != null) {
                        if (typeof object.task !== "object")
                            throw TypeError(".havocai.messages.v0.BoatStatus.task: object expected");
                        message.task = $root.havocai.messages.v0.Task.fromObject(object.task);
                    }
                    if (object.taskExecution != null) {
                        if (typeof object.taskExecution !== "object")
                            throw TypeError(".havocai.messages.v0.BoatStatus.taskExecution: object expected");
                        message.taskExecution = $root.havocai.messages.v0.TaskExecutionStatus.fromObject(object.taskExecution);
                    }
                    if (object.playExecution != null) {
                        if (typeof object.playExecution !== "object")
                            throw TypeError(".havocai.messages.v0.BoatStatus.playExecution: object expected");
                        message.playExecution = $root.havocai.messages.v0.ResourceRef.fromObject(object.playExecution);
                    }
                    if (object.route) {
                        if (!Array.isArray(object.route))
                            throw TypeError(".havocai.messages.v0.BoatStatus.route: array expected");
                        message.route = [];
                        for (let i = 0; i < object.route.length; ++i) {
                            if (typeof object.route[i] !== "object")
                                throw TypeError(".havocai.messages.v0.BoatStatus.route: object expected");
                            message.route[i] = $root.havocai.messages.v0.GeoPoint.fromObject(object.route[i]);
                        }
                    }
                    if (object.trace) {
                        if (!Array.isArray(object.trace))
                            throw TypeError(".havocai.messages.v0.BoatStatus.trace: array expected");
                        message.trace = [];
                        for (let i = 0; i < object.trace.length; ++i) {
                            if (typeof object.trace[i] !== "object")
                                throw TypeError(".havocai.messages.v0.BoatStatus.trace: object expected");
                            message.trace[i] = $root.havocai.messages.v0.GeoPose.fromObject(object.trace[i]);
                        }
                    }
                    if (object.sector != null) {
                        if (typeof object.sector !== "object")
                            throw TypeError(".havocai.messages.v0.BoatStatus.sector: object expected");
                        message.sector = $root.havocai.messages.v0.ResourceRef.fromObject(object.sector);
                    }
                    if (object.vehicleArmed != null)
                        message.vehicleArmed = Boolean(object.vehicleArmed);
                    switch (object.vehicleInterfaceState) {
                    default:
                        if (typeof object.vehicleInterfaceState === "number") {
                            message.vehicleInterfaceState = object.vehicleInterfaceState;
                            break;
                        }
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_UNSPECIFIED":
                    case 0:
                        message.vehicleInterfaceState = 0;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_DISARMED":
                    case 1:
                        message.vehicleInterfaceState = 1;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_FREE_FLOAT":
                    case 2:
                        message.vehicleInterfaceState = 2;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_ROUTE_FOLLOWING":
                    case 3:
                        message.vehicleInterfaceState = 3;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_CONTROLLED_DRIFT":
                    case 4:
                        message.vehicleInterfaceState = 4;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_VECTOR":
                    case 5:
                        message.vehicleInterfaceState = 5;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_FOLLOW_TARGET":
                    case 6:
                        message.vehicleInterfaceState = 6;
                        break;
                    case "VEHICLE_INTERFACE_STATE_TYPE_REMOTELY_OPERATED":
                    case 7:
                        message.vehicleInterfaceState = 7;
                        break;
                    }
                    if (object.thirdPartyData != null)
                        if (typeof object.thirdPartyData === "string")
                            $util.base64.decode(object.thirdPartyData, message.thirdPartyData = $util.newBuffer($util.base64.length(object.thirdPartyData)), 0);
                        else if (object.thirdPartyData.length >= 0)
                            message.thirdPartyData = object.thirdPartyData;
                    if (object.components) {
                        if (!Array.isArray(object.components))
                            throw TypeError(".havocai.messages.v0.BoatStatus.components: array expected");
                        message.components = [];
                        for (let i = 0; i < object.components.length; ++i) {
                            if (typeof object.components[i] !== "object")
                                throw TypeError(".havocai.messages.v0.BoatStatus.components: object expected");
                            message.components[i] = $root.havocai.messages.v0.Component.fromObject(object.components[i]);
                        }
                    }
                    if (object.metrics) {
                        if (!Array.isArray(object.metrics))
                            throw TypeError(".havocai.messages.v0.BoatStatus.metrics: array expected");
                        message.metrics = [];
                        for (let i = 0; i < object.metrics.length; ++i) {
                            if (typeof object.metrics[i] !== "object")
                                throw TypeError(".havocai.messages.v0.BoatStatus.metrics: object expected");
                            message.metrics[i] = $root.havocai.messages.v0.Metric.fromObject(object.metrics[i]);
                        }
                    }
                    if (object.videoStreamUrls) {
                        if (!Array.isArray(object.videoStreamUrls))
                            throw TypeError(".havocai.messages.v0.BoatStatus.videoStreamUrls: array expected");
                        message.videoStreamUrls = [];
                        for (let i = 0; i < object.videoStreamUrls.length; ++i)
                            message.videoStreamUrls[i] = String(object.videoStreamUrls[i]);
                    }
                    switch (object.cdrState) {
                    default:
                        if (typeof object.cdrState === "number") {
                            message.cdrState = object.cdrState;
                            break;
                        }
                        break;
                    case "CDR_STATE_UNKNOWN":
                    case 0:
                        message.cdrState = 0;
                        break;
                    case "CDR_STATE_DISABLED":
                    case 1:
                        message.cdrState = 1;
                        break;
                    case "CDR_STATE_INACTIVE":
                    case 2:
                        message.cdrState = 2;
                        break;
                    case "CDR_STATE_ACTIVE":
                    case 3:
                        message.cdrState = 3;
                        break;
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".havocai.messages.v0.BoatStatus.errors: array expected");
                        message.errors = [];
                        for (let i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".havocai.messages.v0.BoatStatus.errors: object expected");
                            message.errors[i] = $root.havocai.messages.v0.Error.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BoatStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.BoatStatus
                 * @static
                 * @param {havocai.messages.v0.BoatStatus} message BoatStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BoatStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.route = [];
                        object.trace = [];
                        object.components = [];
                        object.metrics = [];
                        object.videoStreamUrls = [];
                        object.errors = [];
                    }
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.revisionTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.revisionTime = options.longs === String ? "0" : 0;
                        object.position = null;
                        object.heading = 0;
                        object.velocityEast = 0;
                        object.velocityNorth = 0;
                        object.speed = 0;
                        object.task = null;
                        object.sector = null;
                        object.vehicleInterfaceState = options.enums === String ? "VEHICLE_INTERFACE_STATE_TYPE_UNSPECIFIED" : 0;
                        object.taskExecution = null;
                        if (options.bytes === String)
                            object.thirdPartyData = "";
                        else {
                            object.thirdPartyData = [];
                            if (options.bytes !== Array)
                                object.thirdPartyData = $util.newBuffer(object.thirdPartyData);
                        }
                        object.vehicleArmed = false;
                        object.playExecution = null;
                        object.course = 0;
                        object.cdrState = options.enums === String ? "CDR_STATE_UNKNOWN" : 0;
                    }
                    if (message.revisionTime != null && message.hasOwnProperty("revisionTime"))
                        if (typeof message.revisionTime === "number")
                            object.revisionTime = options.longs === String ? String(message.revisionTime) : message.revisionTime;
                        else
                            object.revisionTime = options.longs === String ? $util.Long.prototype.toString.call(message.revisionTime) : options.longs === Number ? new $util.LongBits(message.revisionTime.low >>> 0, message.revisionTime.high >>> 0).toNumber() : message.revisionTime;
                    if (message.position != null && message.hasOwnProperty("position"))
                        object.position = $root.havocai.messages.v0.GeoPose.toObject(message.position, options);
                    if (message.heading != null && message.hasOwnProperty("heading"))
                        object.heading = options.json && !isFinite(message.heading) ? String(message.heading) : message.heading;
                    if (message.velocityEast != null && message.hasOwnProperty("velocityEast"))
                        object.velocityEast = options.json && !isFinite(message.velocityEast) ? String(message.velocityEast) : message.velocityEast;
                    if (message.velocityNorth != null && message.hasOwnProperty("velocityNorth"))
                        object.velocityNorth = options.json && !isFinite(message.velocityNorth) ? String(message.velocityNorth) : message.velocityNorth;
                    if (message.speed != null && message.hasOwnProperty("speed"))
                        object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
                    if (message.task != null && message.hasOwnProperty("task"))
                        object.task = $root.havocai.messages.v0.Task.toObject(message.task, options);
                    if (message.route && message.route.length) {
                        object.route = [];
                        for (let j = 0; j < message.route.length; ++j)
                            object.route[j] = $root.havocai.messages.v0.GeoPoint.toObject(message.route[j], options);
                    }
                    if (message.trace && message.trace.length) {
                        object.trace = [];
                        for (let j = 0; j < message.trace.length; ++j)
                            object.trace[j] = $root.havocai.messages.v0.GeoPose.toObject(message.trace[j], options);
                    }
                    if (message.sector != null && message.hasOwnProperty("sector"))
                        object.sector = $root.havocai.messages.v0.ResourceRef.toObject(message.sector, options);
                    if (message.vehicleInterfaceState != null && message.hasOwnProperty("vehicleInterfaceState"))
                        object.vehicleInterfaceState = options.enums === String ? $root.havocai.messages.v0.VehicleInterfaceStateType[message.vehicleInterfaceState] === undefined ? message.vehicleInterfaceState : $root.havocai.messages.v0.VehicleInterfaceStateType[message.vehicleInterfaceState] : message.vehicleInterfaceState;
                    if (message.taskExecution != null && message.hasOwnProperty("taskExecution"))
                        object.taskExecution = $root.havocai.messages.v0.TaskExecutionStatus.toObject(message.taskExecution, options);
                    if (message.thirdPartyData != null && message.hasOwnProperty("thirdPartyData"))
                        object.thirdPartyData = options.bytes === String ? $util.base64.encode(message.thirdPartyData, 0, message.thirdPartyData.length) : options.bytes === Array ? Array.prototype.slice.call(message.thirdPartyData) : message.thirdPartyData;
                    if (message.components && message.components.length) {
                        object.components = [];
                        for (let j = 0; j < message.components.length; ++j)
                            object.components[j] = $root.havocai.messages.v0.Component.toObject(message.components[j], options);
                    }
                    if (message.metrics && message.metrics.length) {
                        object.metrics = [];
                        for (let j = 0; j < message.metrics.length; ++j)
                            object.metrics[j] = $root.havocai.messages.v0.Metric.toObject(message.metrics[j], options);
                    }
                    if (message.vehicleArmed != null && message.hasOwnProperty("vehicleArmed"))
                        object.vehicleArmed = message.vehicleArmed;
                    if (message.playExecution != null && message.hasOwnProperty("playExecution"))
                        object.playExecution = $root.havocai.messages.v0.ResourceRef.toObject(message.playExecution, options);
                    if (message.videoStreamUrls && message.videoStreamUrls.length) {
                        object.videoStreamUrls = [];
                        for (let j = 0; j < message.videoStreamUrls.length; ++j)
                            object.videoStreamUrls[j] = message.videoStreamUrls[j];
                    }
                    if (message.course != null && message.hasOwnProperty("course"))
                        object.course = options.json && !isFinite(message.course) ? String(message.course) : message.course;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (let j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.havocai.messages.v0.Error.toObject(message.errors[j], options);
                    }
                    if (message.cdrState != null && message.hasOwnProperty("cdrState"))
                        object.cdrState = options.enums === String ? $root.havocai.messages.v0.CDRState[message.cdrState] === undefined ? message.cdrState : $root.havocai.messages.v0.CDRState[message.cdrState] : message.cdrState;
                    return object;
                };

                /**
                 * Converts this BoatStatus to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.BoatStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BoatStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BoatStatus
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.BoatStatus
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BoatStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.BoatStatus";
                };

                return BoatStatus;
            })();

            v0.BoatList = (function() {

                /**
                 * Properties of a BoatList.
                 * @memberof havocai.messages.v0
                 * @interface IBoatList
                 * @property {Array.<havocai.messages.v0.IBoat>|null} [values] BoatList values
                 */

                /**
                 * Constructs a new BoatList.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a BoatList.
                 * @implements IBoatList
                 * @constructor
                 * @param {havocai.messages.v0.IBoatList=} [properties] Properties to set
                 */
                function BoatList(properties) {
                    this.values = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BoatList values.
                 * @member {Array.<havocai.messages.v0.IBoat>} values
                 * @memberof havocai.messages.v0.BoatList
                 * @instance
                 */
                BoatList.prototype.values = $util.emptyArray;

                /**
                 * Creates a new BoatList instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.BoatList
                 * @static
                 * @param {havocai.messages.v0.IBoatList=} [properties] Properties to set
                 * @returns {havocai.messages.v0.BoatList} BoatList instance
                 */
                BoatList.create = function create(properties) {
                    return new BoatList(properties);
                };

                /**
                 * Encodes the specified BoatList message. Does not implicitly {@link havocai.messages.v0.BoatList.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.BoatList
                 * @static
                 * @param {havocai.messages.v0.IBoatList} message BoatList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoatList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (let i = 0; i < message.values.length; ++i)
                            $root.havocai.messages.v0.Boat.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified BoatList message, length delimited. Does not implicitly {@link havocai.messages.v0.BoatList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.BoatList
                 * @static
                 * @param {havocai.messages.v0.IBoatList} message BoatList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoatList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BoatList message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.BoatList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.BoatList} BoatList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoatList.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.BoatList();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.values && message.values.length))
                                    message.values = [];
                                message.values.push($root.havocai.messages.v0.Boat.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BoatList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.BoatList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.BoatList} BoatList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoatList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BoatList message.
                 * @function verify
                 * @memberof havocai.messages.v0.BoatList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BoatList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (let i = 0; i < message.values.length; ++i) {
                            let error = $root.havocai.messages.v0.Boat.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a BoatList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.BoatList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.BoatList} BoatList
                 */
                BoatList.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.BoatList)
                        return object;
                    let message = new $root.havocai.messages.v0.BoatList();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".havocai.messages.v0.BoatList.values: array expected");
                        message.values = [];
                        for (let i = 0; i < object.values.length; ++i) {
                            if (typeof object.values[i] !== "object")
                                throw TypeError(".havocai.messages.v0.BoatList.values: object expected");
                            message.values[i] = $root.havocai.messages.v0.Boat.fromObject(object.values[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BoatList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.BoatList
                 * @static
                 * @param {havocai.messages.v0.BoatList} message BoatList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BoatList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (let j = 0; j < message.values.length; ++j)
                            object.values[j] = $root.havocai.messages.v0.Boat.toObject(message.values[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this BoatList to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.BoatList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BoatList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for BoatList
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.BoatList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                BoatList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.BoatList";
                };

                return BoatList;
            })();

            v0.Event = (function() {

                /**
                 * Properties of an Event.
                 * @memberof havocai.messages.v0
                 * @interface IEvent
                 * @property {string|null} [id] Event id
                 * @property {havocai.messages.v0.EventType|null} [type] Event type
                 * @property {number|Long|null} [creationTime] Event creationTime
                 * @property {number|Long|null} [eventTime] Event eventTime
                 * @property {havocai.messages.v0.IResourceRef|null} [resourceRef] Event resourceRef
                 * @property {havocai.messages.v0.ISector|null} [sector] Event sector
                 * @property {havocai.messages.v0.ITrack|null} [track] Event track
                 * @property {havocai.messages.v0.IZone|null} [zone] Event zone
                 * @property {havocai.messages.v0.ITeam|null} [team] Event team
                 * @property {havocai.messages.v0.IBoat|null} [boat] Event boat
                 * @property {havocai.messages.v0.IPlayDefinition|null} [playDefinition] Event playDefinition
                 * @property {havocai.messages.v0.IPlayExecution|null} [playExecution] Event playExecution
                 */

                /**
                 * Constructs a new Event.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents an Event.
                 * @implements IEvent
                 * @constructor
                 * @param {havocai.messages.v0.IEvent=} [properties] Properties to set
                 */
                function Event(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Event id.
                 * @member {string} id
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 */
                Event.prototype.id = "";

                /**
                 * Event type.
                 * @member {havocai.messages.v0.EventType} type
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 */
                Event.prototype.type = 0;

                /**
                 * Event creationTime.
                 * @member {number|Long} creationTime
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 */
                Event.prototype.creationTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Event eventTime.
                 * @member {number|Long} eventTime
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 */
                Event.prototype.eventTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Event resourceRef.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} resourceRef
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 */
                Event.prototype.resourceRef = null;

                /**
                 * Event sector.
                 * @member {havocai.messages.v0.ISector|null|undefined} sector
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 */
                Event.prototype.sector = null;

                /**
                 * Event track.
                 * @member {havocai.messages.v0.ITrack|null|undefined} track
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 */
                Event.prototype.track = null;

                /**
                 * Event zone.
                 * @member {havocai.messages.v0.IZone|null|undefined} zone
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 */
                Event.prototype.zone = null;

                /**
                 * Event team.
                 * @member {havocai.messages.v0.ITeam|null|undefined} team
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 */
                Event.prototype.team = null;

                /**
                 * Event boat.
                 * @member {havocai.messages.v0.IBoat|null|undefined} boat
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 */
                Event.prototype.boat = null;

                /**
                 * Event playDefinition.
                 * @member {havocai.messages.v0.IPlayDefinition|null|undefined} playDefinition
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 */
                Event.prototype.playDefinition = null;

                /**
                 * Event playExecution.
                 * @member {havocai.messages.v0.IPlayExecution|null|undefined} playExecution
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 */
                Event.prototype.playExecution = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Event resource.
                 * @member {"sector"|"track"|"zone"|"team"|"boat"|"playDefinition"|"playExecution"|undefined} resource
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 */
                Object.defineProperty(Event.prototype, "resource", {
                    get: $util.oneOfGetter($oneOfFields = ["sector", "track", "zone", "team", "boat", "playDefinition", "playExecution"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Event instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Event
                 * @static
                 * @param {havocai.messages.v0.IEvent=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Event} Event instance
                 */
                Event.create = function create(properties) {
                    return new Event(properties);
                };

                /**
                 * Encodes the specified Event message. Does not implicitly {@link havocai.messages.v0.Event.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Event
                 * @static
                 * @param {havocai.messages.v0.IEvent} message Event message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Event.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.creationTime != null && Object.hasOwnProperty.call(message, "creationTime"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.creationTime);
                    if (message.eventTime != null && Object.hasOwnProperty.call(message, "eventTime"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.eventTime);
                    if (message.resourceRef != null && Object.hasOwnProperty.call(message, "resourceRef"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.resourceRef, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.sector != null && Object.hasOwnProperty.call(message, "sector"))
                        $root.havocai.messages.v0.Sector.encode(message.sector, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.track != null && Object.hasOwnProperty.call(message, "track"))
                        $root.havocai.messages.v0.Track.encode(message.track, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.zone != null && Object.hasOwnProperty.call(message, "zone"))
                        $root.havocai.messages.v0.Zone.encode(message.zone, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                        $root.havocai.messages.v0.Team.encode(message.team, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.boat != null && Object.hasOwnProperty.call(message, "boat"))
                        $root.havocai.messages.v0.Boat.encode(message.boat, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.playDefinition != null && Object.hasOwnProperty.call(message, "playDefinition"))
                        $root.havocai.messages.v0.PlayDefinition.encode(message.playDefinition, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.playExecution != null && Object.hasOwnProperty.call(message, "playExecution"))
                        $root.havocai.messages.v0.PlayExecution.encode(message.playExecution, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Event message, length delimited. Does not implicitly {@link havocai.messages.v0.Event.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Event
                 * @static
                 * @param {havocai.messages.v0.IEvent} message Event message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Event.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Event message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Event
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Event} Event
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Event.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Event();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.id = reader.string();
                                break;
                            }
                        case 2: {
                                message.type = reader.int32();
                                break;
                            }
                        case 3: {
                                message.creationTime = reader.int64();
                                break;
                            }
                        case 4: {
                                message.eventTime = reader.int64();
                                break;
                            }
                        case 5: {
                                message.resourceRef = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 6: {
                                message.sector = $root.havocai.messages.v0.Sector.decode(reader, reader.uint32());
                                break;
                            }
                        case 7: {
                                message.track = $root.havocai.messages.v0.Track.decode(reader, reader.uint32());
                                break;
                            }
                        case 8: {
                                message.zone = $root.havocai.messages.v0.Zone.decode(reader, reader.uint32());
                                break;
                            }
                        case 9: {
                                message.team = $root.havocai.messages.v0.Team.decode(reader, reader.uint32());
                                break;
                            }
                        case 10: {
                                message.boat = $root.havocai.messages.v0.Boat.decode(reader, reader.uint32());
                                break;
                            }
                        case 11: {
                                message.playDefinition = $root.havocai.messages.v0.PlayDefinition.decode(reader, reader.uint32());
                                break;
                            }
                        case 12: {
                                message.playExecution = $root.havocai.messages.v0.PlayExecution.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Event message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Event
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Event} Event
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Event.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Event message.
                 * @function verify
                 * @memberof havocai.messages.v0.Event
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Event.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.creationTime != null && message.hasOwnProperty("creationTime"))
                        if (!$util.isInteger(message.creationTime) && !(message.creationTime && $util.isInteger(message.creationTime.low) && $util.isInteger(message.creationTime.high)))
                            return "creationTime: integer|Long expected";
                    if (message.eventTime != null && message.hasOwnProperty("eventTime"))
                        if (!$util.isInteger(message.eventTime) && !(message.eventTime && $util.isInteger(message.eventTime.low) && $util.isInteger(message.eventTime.high)))
                            return "eventTime: integer|Long expected";
                    if (message.resourceRef != null && message.hasOwnProperty("resourceRef")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.resourceRef);
                        if (error)
                            return "resourceRef." + error;
                    }
                    if (message.sector != null && message.hasOwnProperty("sector")) {
                        properties.resource = 1;
                        {
                            let error = $root.havocai.messages.v0.Sector.verify(message.sector);
                            if (error)
                                return "sector." + error;
                        }
                    }
                    if (message.track != null && message.hasOwnProperty("track")) {
                        if (properties.resource === 1)
                            return "resource: multiple values";
                        properties.resource = 1;
                        {
                            let error = $root.havocai.messages.v0.Track.verify(message.track);
                            if (error)
                                return "track." + error;
                        }
                    }
                    if (message.zone != null && message.hasOwnProperty("zone")) {
                        if (properties.resource === 1)
                            return "resource: multiple values";
                        properties.resource = 1;
                        {
                            let error = $root.havocai.messages.v0.Zone.verify(message.zone);
                            if (error)
                                return "zone." + error;
                        }
                    }
                    if (message.team != null && message.hasOwnProperty("team")) {
                        if (properties.resource === 1)
                            return "resource: multiple values";
                        properties.resource = 1;
                        {
                            let error = $root.havocai.messages.v0.Team.verify(message.team);
                            if (error)
                                return "team." + error;
                        }
                    }
                    if (message.boat != null && message.hasOwnProperty("boat")) {
                        if (properties.resource === 1)
                            return "resource: multiple values";
                        properties.resource = 1;
                        {
                            let error = $root.havocai.messages.v0.Boat.verify(message.boat);
                            if (error)
                                return "boat." + error;
                        }
                    }
                    if (message.playDefinition != null && message.hasOwnProperty("playDefinition")) {
                        if (properties.resource === 1)
                            return "resource: multiple values";
                        properties.resource = 1;
                        {
                            let error = $root.havocai.messages.v0.PlayDefinition.verify(message.playDefinition);
                            if (error)
                                return "playDefinition." + error;
                        }
                    }
                    if (message.playExecution != null && message.hasOwnProperty("playExecution")) {
                        if (properties.resource === 1)
                            return "resource: multiple values";
                        properties.resource = 1;
                        {
                            let error = $root.havocai.messages.v0.PlayExecution.verify(message.playExecution);
                            if (error)
                                return "playExecution." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Event message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Event
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Event} Event
                 */
                Event.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Event)
                        return object;
                    let message = new $root.havocai.messages.v0.Event();
                    if (object.id != null)
                        message.id = String(object.id);
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "EVENT_TYPE_UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "EVENT_TYPE_NOTIFICATION":
                    case 1:
                        message.type = 1;
                        break;
                    case "EVENT_TYPE_RESOURCE_CREATED":
                    case 2:
                        message.type = 2;
                        break;
                    case "EVENT_TYPE_RESOURCE_UPDATED":
                    case 3:
                        message.type = 3;
                        break;
                    case "EVENT_TYPE_RESOURCE_DELETED":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.creationTime != null)
                        if ($util.Long)
                            (message.creationTime = $util.Long.fromValue(object.creationTime)).unsigned = false;
                        else if (typeof object.creationTime === "string")
                            message.creationTime = parseInt(object.creationTime, 10);
                        else if (typeof object.creationTime === "number")
                            message.creationTime = object.creationTime;
                        else if (typeof object.creationTime === "object")
                            message.creationTime = new $util.LongBits(object.creationTime.low >>> 0, object.creationTime.high >>> 0).toNumber();
                    if (object.eventTime != null)
                        if ($util.Long)
                            (message.eventTime = $util.Long.fromValue(object.eventTime)).unsigned = false;
                        else if (typeof object.eventTime === "string")
                            message.eventTime = parseInt(object.eventTime, 10);
                        else if (typeof object.eventTime === "number")
                            message.eventTime = object.eventTime;
                        else if (typeof object.eventTime === "object")
                            message.eventTime = new $util.LongBits(object.eventTime.low >>> 0, object.eventTime.high >>> 0).toNumber();
                    if (object.resourceRef != null) {
                        if (typeof object.resourceRef !== "object")
                            throw TypeError(".havocai.messages.v0.Event.resourceRef: object expected");
                        message.resourceRef = $root.havocai.messages.v0.ResourceRef.fromObject(object.resourceRef);
                    }
                    if (object.sector != null) {
                        if (typeof object.sector !== "object")
                            throw TypeError(".havocai.messages.v0.Event.sector: object expected");
                        message.sector = $root.havocai.messages.v0.Sector.fromObject(object.sector);
                    }
                    if (object.track != null) {
                        if (typeof object.track !== "object")
                            throw TypeError(".havocai.messages.v0.Event.track: object expected");
                        message.track = $root.havocai.messages.v0.Track.fromObject(object.track);
                    }
                    if (object.zone != null) {
                        if (typeof object.zone !== "object")
                            throw TypeError(".havocai.messages.v0.Event.zone: object expected");
                        message.zone = $root.havocai.messages.v0.Zone.fromObject(object.zone);
                    }
                    if (object.team != null) {
                        if (typeof object.team !== "object")
                            throw TypeError(".havocai.messages.v0.Event.team: object expected");
                        message.team = $root.havocai.messages.v0.Team.fromObject(object.team);
                    }
                    if (object.boat != null) {
                        if (typeof object.boat !== "object")
                            throw TypeError(".havocai.messages.v0.Event.boat: object expected");
                        message.boat = $root.havocai.messages.v0.Boat.fromObject(object.boat);
                    }
                    if (object.playDefinition != null) {
                        if (typeof object.playDefinition !== "object")
                            throw TypeError(".havocai.messages.v0.Event.playDefinition: object expected");
                        message.playDefinition = $root.havocai.messages.v0.PlayDefinition.fromObject(object.playDefinition);
                    }
                    if (object.playExecution != null) {
                        if (typeof object.playExecution !== "object")
                            throw TypeError(".havocai.messages.v0.Event.playExecution: object expected");
                        message.playExecution = $root.havocai.messages.v0.PlayExecution.fromObject(object.playExecution);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Event message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Event
                 * @static
                 * @param {havocai.messages.v0.Event} message Event
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Event.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.type = options.enums === String ? "EVENT_TYPE_UNKNOWN" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.creationTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.creationTime = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.eventTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.eventTime = options.longs === String ? "0" : 0;
                        object.resourceRef = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.havocai.messages.v0.EventType[message.type] === undefined ? message.type : $root.havocai.messages.v0.EventType[message.type] : message.type;
                    if (message.creationTime != null && message.hasOwnProperty("creationTime"))
                        if (typeof message.creationTime === "number")
                            object.creationTime = options.longs === String ? String(message.creationTime) : message.creationTime;
                        else
                            object.creationTime = options.longs === String ? $util.Long.prototype.toString.call(message.creationTime) : options.longs === Number ? new $util.LongBits(message.creationTime.low >>> 0, message.creationTime.high >>> 0).toNumber() : message.creationTime;
                    if (message.eventTime != null && message.hasOwnProperty("eventTime"))
                        if (typeof message.eventTime === "number")
                            object.eventTime = options.longs === String ? String(message.eventTime) : message.eventTime;
                        else
                            object.eventTime = options.longs === String ? $util.Long.prototype.toString.call(message.eventTime) : options.longs === Number ? new $util.LongBits(message.eventTime.low >>> 0, message.eventTime.high >>> 0).toNumber() : message.eventTime;
                    if (message.resourceRef != null && message.hasOwnProperty("resourceRef"))
                        object.resourceRef = $root.havocai.messages.v0.ResourceRef.toObject(message.resourceRef, options);
                    if (message.sector != null && message.hasOwnProperty("sector")) {
                        object.sector = $root.havocai.messages.v0.Sector.toObject(message.sector, options);
                        if (options.oneofs)
                            object.resource = "sector";
                    }
                    if (message.track != null && message.hasOwnProperty("track")) {
                        object.track = $root.havocai.messages.v0.Track.toObject(message.track, options);
                        if (options.oneofs)
                            object.resource = "track";
                    }
                    if (message.zone != null && message.hasOwnProperty("zone")) {
                        object.zone = $root.havocai.messages.v0.Zone.toObject(message.zone, options);
                        if (options.oneofs)
                            object.resource = "zone";
                    }
                    if (message.team != null && message.hasOwnProperty("team")) {
                        object.team = $root.havocai.messages.v0.Team.toObject(message.team, options);
                        if (options.oneofs)
                            object.resource = "team";
                    }
                    if (message.boat != null && message.hasOwnProperty("boat")) {
                        object.boat = $root.havocai.messages.v0.Boat.toObject(message.boat, options);
                        if (options.oneofs)
                            object.resource = "boat";
                    }
                    if (message.playDefinition != null && message.hasOwnProperty("playDefinition")) {
                        object.playDefinition = $root.havocai.messages.v0.PlayDefinition.toObject(message.playDefinition, options);
                        if (options.oneofs)
                            object.resource = "playDefinition";
                    }
                    if (message.playExecution != null && message.hasOwnProperty("playExecution")) {
                        object.playExecution = $root.havocai.messages.v0.PlayExecution.toObject(message.playExecution, options);
                        if (options.oneofs)
                            object.resource = "playExecution";
                    }
                    return object;
                };

                /**
                 * Converts this Event to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Event
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Event.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Event
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Event
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Event.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Event";
                };

                return Event;
            })();

            v0.EventList = (function() {

                /**
                 * Properties of an EventList.
                 * @memberof havocai.messages.v0
                 * @interface IEventList
                 * @property {Array.<havocai.messages.v0.IEvent>|null} [values] EventList values
                 */

                /**
                 * Constructs a new EventList.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents an EventList.
                 * @implements IEventList
                 * @constructor
                 * @param {havocai.messages.v0.IEventList=} [properties] Properties to set
                 */
                function EventList(properties) {
                    this.values = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EventList values.
                 * @member {Array.<havocai.messages.v0.IEvent>} values
                 * @memberof havocai.messages.v0.EventList
                 * @instance
                 */
                EventList.prototype.values = $util.emptyArray;

                /**
                 * Creates a new EventList instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.EventList
                 * @static
                 * @param {havocai.messages.v0.IEventList=} [properties] Properties to set
                 * @returns {havocai.messages.v0.EventList} EventList instance
                 */
                EventList.create = function create(properties) {
                    return new EventList(properties);
                };

                /**
                 * Encodes the specified EventList message. Does not implicitly {@link havocai.messages.v0.EventList.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.EventList
                 * @static
                 * @param {havocai.messages.v0.IEventList} message EventList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (let i = 0; i < message.values.length; ++i)
                            $root.havocai.messages.v0.Event.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified EventList message, length delimited. Does not implicitly {@link havocai.messages.v0.EventList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.EventList
                 * @static
                 * @param {havocai.messages.v0.IEventList} message EventList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EventList message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.EventList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.EventList} EventList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventList.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.EventList();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.values && message.values.length))
                                    message.values = [];
                                message.values.push($root.havocai.messages.v0.Event.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EventList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.EventList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.EventList} EventList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EventList message.
                 * @function verify
                 * @memberof havocai.messages.v0.EventList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EventList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (let i = 0; i < message.values.length; ++i) {
                            let error = $root.havocai.messages.v0.Event.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an EventList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.EventList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.EventList} EventList
                 */
                EventList.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.EventList)
                        return object;
                    let message = new $root.havocai.messages.v0.EventList();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".havocai.messages.v0.EventList.values: array expected");
                        message.values = [];
                        for (let i = 0; i < object.values.length; ++i) {
                            if (typeof object.values[i] !== "object")
                                throw TypeError(".havocai.messages.v0.EventList.values: object expected");
                            message.values[i] = $root.havocai.messages.v0.Event.fromObject(object.values[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an EventList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.EventList
                 * @static
                 * @param {havocai.messages.v0.EventList} message EventList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (let j = 0; j < message.values.length; ++j)
                            object.values[j] = $root.havocai.messages.v0.Event.toObject(message.values[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this EventList to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.EventList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EventList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for EventList
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.EventList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EventList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.EventList";
                };

                return EventList;
            })();

            v0.PlayDefinition = (function() {

                /**
                 * Properties of a PlayDefinition.
                 * @memberof havocai.messages.v0
                 * @interface IPlayDefinition
                 * @property {havocai.messages.v0.IMetadata|null} [meta] PlayDefinition meta
                 * @property {havocai.messages.v0.IPlayDefinitionSpec|null} [spec] PlayDefinition spec
                 */

                /**
                 * Constructs a new PlayDefinition.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PlayDefinition.
                 * @implements IPlayDefinition
                 * @constructor
                 * @param {havocai.messages.v0.IPlayDefinition=} [properties] Properties to set
                 */
                function PlayDefinition(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlayDefinition meta.
                 * @member {havocai.messages.v0.IMetadata|null|undefined} meta
                 * @memberof havocai.messages.v0.PlayDefinition
                 * @instance
                 */
                PlayDefinition.prototype.meta = null;

                /**
                 * PlayDefinition spec.
                 * @member {havocai.messages.v0.IPlayDefinitionSpec|null|undefined} spec
                 * @memberof havocai.messages.v0.PlayDefinition
                 * @instance
                 */
                PlayDefinition.prototype.spec = null;

                /**
                 * Creates a new PlayDefinition instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PlayDefinition
                 * @static
                 * @param {havocai.messages.v0.IPlayDefinition=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PlayDefinition} PlayDefinition instance
                 */
                PlayDefinition.create = function create(properties) {
                    return new PlayDefinition(properties);
                };

                /**
                 * Encodes the specified PlayDefinition message. Does not implicitly {@link havocai.messages.v0.PlayDefinition.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PlayDefinition
                 * @static
                 * @param {havocai.messages.v0.IPlayDefinition} message PlayDefinition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayDefinition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.meta != null && Object.hasOwnProperty.call(message, "meta"))
                        $root.havocai.messages.v0.Metadata.encode(message.meta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.spec != null && Object.hasOwnProperty.call(message, "spec"))
                        $root.havocai.messages.v0.PlayDefinitionSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PlayDefinition message, length delimited. Does not implicitly {@link havocai.messages.v0.PlayDefinition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PlayDefinition
                 * @static
                 * @param {havocai.messages.v0.IPlayDefinition} message PlayDefinition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayDefinition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlayDefinition message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PlayDefinition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PlayDefinition} PlayDefinition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayDefinition.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PlayDefinition();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.meta = $root.havocai.messages.v0.Metadata.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.spec = $root.havocai.messages.v0.PlayDefinitionSpec.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlayDefinition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PlayDefinition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PlayDefinition} PlayDefinition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayDefinition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlayDefinition message.
                 * @function verify
                 * @memberof havocai.messages.v0.PlayDefinition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayDefinition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.meta != null && message.hasOwnProperty("meta")) {
                        let error = $root.havocai.messages.v0.Metadata.verify(message.meta);
                        if (error)
                            return "meta." + error;
                    }
                    if (message.spec != null && message.hasOwnProperty("spec")) {
                        let error = $root.havocai.messages.v0.PlayDefinitionSpec.verify(message.spec);
                        if (error)
                            return "spec." + error;
                    }
                    return null;
                };

                /**
                 * Creates a PlayDefinition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PlayDefinition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PlayDefinition} PlayDefinition
                 */
                PlayDefinition.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PlayDefinition)
                        return object;
                    let message = new $root.havocai.messages.v0.PlayDefinition();
                    if (object.meta != null) {
                        if (typeof object.meta !== "object")
                            throw TypeError(".havocai.messages.v0.PlayDefinition.meta: object expected");
                        message.meta = $root.havocai.messages.v0.Metadata.fromObject(object.meta);
                    }
                    if (object.spec != null) {
                        if (typeof object.spec !== "object")
                            throw TypeError(".havocai.messages.v0.PlayDefinition.spec: object expected");
                        message.spec = $root.havocai.messages.v0.PlayDefinitionSpec.fromObject(object.spec);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlayDefinition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PlayDefinition
                 * @static
                 * @param {havocai.messages.v0.PlayDefinition} message PlayDefinition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayDefinition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.meta = null;
                        object.spec = null;
                    }
                    if (message.meta != null && message.hasOwnProperty("meta"))
                        object.meta = $root.havocai.messages.v0.Metadata.toObject(message.meta, options);
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        object.spec = $root.havocai.messages.v0.PlayDefinitionSpec.toObject(message.spec, options);
                    return object;
                };

                /**
                 * Converts this PlayDefinition to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PlayDefinition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayDefinition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlayDefinition
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PlayDefinition
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlayDefinition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PlayDefinition";
                };

                return PlayDefinition;
            })();

            v0.PlayDefinitionList = (function() {

                /**
                 * Properties of a PlayDefinitionList.
                 * @memberof havocai.messages.v0
                 * @interface IPlayDefinitionList
                 * @property {Array.<havocai.messages.v0.IPlayDefinition>|null} [values] PlayDefinitionList values
                 */

                /**
                 * Constructs a new PlayDefinitionList.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PlayDefinitionList.
                 * @implements IPlayDefinitionList
                 * @constructor
                 * @param {havocai.messages.v0.IPlayDefinitionList=} [properties] Properties to set
                 */
                function PlayDefinitionList(properties) {
                    this.values = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlayDefinitionList values.
                 * @member {Array.<havocai.messages.v0.IPlayDefinition>} values
                 * @memberof havocai.messages.v0.PlayDefinitionList
                 * @instance
                 */
                PlayDefinitionList.prototype.values = $util.emptyArray;

                /**
                 * Creates a new PlayDefinitionList instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PlayDefinitionList
                 * @static
                 * @param {havocai.messages.v0.IPlayDefinitionList=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PlayDefinitionList} PlayDefinitionList instance
                 */
                PlayDefinitionList.create = function create(properties) {
                    return new PlayDefinitionList(properties);
                };

                /**
                 * Encodes the specified PlayDefinitionList message. Does not implicitly {@link havocai.messages.v0.PlayDefinitionList.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PlayDefinitionList
                 * @static
                 * @param {havocai.messages.v0.IPlayDefinitionList} message PlayDefinitionList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayDefinitionList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (let i = 0; i < message.values.length; ++i)
                            $root.havocai.messages.v0.PlayDefinition.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PlayDefinitionList message, length delimited. Does not implicitly {@link havocai.messages.v0.PlayDefinitionList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PlayDefinitionList
                 * @static
                 * @param {havocai.messages.v0.IPlayDefinitionList} message PlayDefinitionList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayDefinitionList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlayDefinitionList message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PlayDefinitionList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PlayDefinitionList} PlayDefinitionList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayDefinitionList.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PlayDefinitionList();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.values && message.values.length))
                                    message.values = [];
                                message.values.push($root.havocai.messages.v0.PlayDefinition.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlayDefinitionList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PlayDefinitionList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PlayDefinitionList} PlayDefinitionList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayDefinitionList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlayDefinitionList message.
                 * @function verify
                 * @memberof havocai.messages.v0.PlayDefinitionList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayDefinitionList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (let i = 0; i < message.values.length; ++i) {
                            let error = $root.havocai.messages.v0.PlayDefinition.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a PlayDefinitionList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PlayDefinitionList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PlayDefinitionList} PlayDefinitionList
                 */
                PlayDefinitionList.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PlayDefinitionList)
                        return object;
                    let message = new $root.havocai.messages.v0.PlayDefinitionList();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".havocai.messages.v0.PlayDefinitionList.values: array expected");
                        message.values = [];
                        for (let i = 0; i < object.values.length; ++i) {
                            if (typeof object.values[i] !== "object")
                                throw TypeError(".havocai.messages.v0.PlayDefinitionList.values: object expected");
                            message.values[i] = $root.havocai.messages.v0.PlayDefinition.fromObject(object.values[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlayDefinitionList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PlayDefinitionList
                 * @static
                 * @param {havocai.messages.v0.PlayDefinitionList} message PlayDefinitionList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayDefinitionList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (let j = 0; j < message.values.length; ++j)
                            object.values[j] = $root.havocai.messages.v0.PlayDefinition.toObject(message.values[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this PlayDefinitionList to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PlayDefinitionList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayDefinitionList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlayDefinitionList
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PlayDefinitionList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlayDefinitionList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PlayDefinitionList";
                };

                return PlayDefinitionList;
            })();

            v0.PlayExecution = (function() {

                /**
                 * Properties of a PlayExecution.
                 * @memberof havocai.messages.v0
                 * @interface IPlayExecution
                 * @property {havocai.messages.v0.IMetadata|null} [meta] PlayExecution meta
                 * @property {havocai.messages.v0.IPlayExecutionSpec|null} [spec] PlayExecution spec
                 * @property {havocai.messages.v0.IPlayExecutionStatus|null} [status] PlayExecution status
                 */

                /**
                 * Constructs a new PlayExecution.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PlayExecution.
                 * @implements IPlayExecution
                 * @constructor
                 * @param {havocai.messages.v0.IPlayExecution=} [properties] Properties to set
                 */
                function PlayExecution(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlayExecution meta.
                 * @member {havocai.messages.v0.IMetadata|null|undefined} meta
                 * @memberof havocai.messages.v0.PlayExecution
                 * @instance
                 */
                PlayExecution.prototype.meta = null;

                /**
                 * PlayExecution spec.
                 * @member {havocai.messages.v0.IPlayExecutionSpec|null|undefined} spec
                 * @memberof havocai.messages.v0.PlayExecution
                 * @instance
                 */
                PlayExecution.prototype.spec = null;

                /**
                 * PlayExecution status.
                 * @member {havocai.messages.v0.IPlayExecutionStatus|null|undefined} status
                 * @memberof havocai.messages.v0.PlayExecution
                 * @instance
                 */
                PlayExecution.prototype.status = null;

                /**
                 * Creates a new PlayExecution instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PlayExecution
                 * @static
                 * @param {havocai.messages.v0.IPlayExecution=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PlayExecution} PlayExecution instance
                 */
                PlayExecution.create = function create(properties) {
                    return new PlayExecution(properties);
                };

                /**
                 * Encodes the specified PlayExecution message. Does not implicitly {@link havocai.messages.v0.PlayExecution.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PlayExecution
                 * @static
                 * @param {havocai.messages.v0.IPlayExecution} message PlayExecution message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayExecution.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.meta != null && Object.hasOwnProperty.call(message, "meta"))
                        $root.havocai.messages.v0.Metadata.encode(message.meta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.spec != null && Object.hasOwnProperty.call(message, "spec"))
                        $root.havocai.messages.v0.PlayExecutionSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        $root.havocai.messages.v0.PlayExecutionStatus.encode(message.status, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PlayExecution message, length delimited. Does not implicitly {@link havocai.messages.v0.PlayExecution.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PlayExecution
                 * @static
                 * @param {havocai.messages.v0.IPlayExecution} message PlayExecution message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayExecution.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlayExecution message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PlayExecution
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PlayExecution} PlayExecution
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayExecution.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PlayExecution();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.meta = $root.havocai.messages.v0.Metadata.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.spec = $root.havocai.messages.v0.PlayExecutionSpec.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.status = $root.havocai.messages.v0.PlayExecutionStatus.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlayExecution message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PlayExecution
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PlayExecution} PlayExecution
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayExecution.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlayExecution message.
                 * @function verify
                 * @memberof havocai.messages.v0.PlayExecution
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayExecution.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.meta != null && message.hasOwnProperty("meta")) {
                        let error = $root.havocai.messages.v0.Metadata.verify(message.meta);
                        if (error)
                            return "meta." + error;
                    }
                    if (message.spec != null && message.hasOwnProperty("spec")) {
                        let error = $root.havocai.messages.v0.PlayExecutionSpec.verify(message.spec);
                        if (error)
                            return "spec." + error;
                    }
                    if (message.status != null && message.hasOwnProperty("status")) {
                        let error = $root.havocai.messages.v0.PlayExecutionStatus.verify(message.status);
                        if (error)
                            return "status." + error;
                    }
                    return null;
                };

                /**
                 * Creates a PlayExecution message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PlayExecution
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PlayExecution} PlayExecution
                 */
                PlayExecution.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PlayExecution)
                        return object;
                    let message = new $root.havocai.messages.v0.PlayExecution();
                    if (object.meta != null) {
                        if (typeof object.meta !== "object")
                            throw TypeError(".havocai.messages.v0.PlayExecution.meta: object expected");
                        message.meta = $root.havocai.messages.v0.Metadata.fromObject(object.meta);
                    }
                    if (object.spec != null) {
                        if (typeof object.spec !== "object")
                            throw TypeError(".havocai.messages.v0.PlayExecution.spec: object expected");
                        message.spec = $root.havocai.messages.v0.PlayExecutionSpec.fromObject(object.spec);
                    }
                    if (object.status != null) {
                        if (typeof object.status !== "object")
                            throw TypeError(".havocai.messages.v0.PlayExecution.status: object expected");
                        message.status = $root.havocai.messages.v0.PlayExecutionStatus.fromObject(object.status);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlayExecution message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PlayExecution
                 * @static
                 * @param {havocai.messages.v0.PlayExecution} message PlayExecution
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayExecution.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.meta = null;
                        object.spec = null;
                        object.status = null;
                    }
                    if (message.meta != null && message.hasOwnProperty("meta"))
                        object.meta = $root.havocai.messages.v0.Metadata.toObject(message.meta, options);
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        object.spec = $root.havocai.messages.v0.PlayExecutionSpec.toObject(message.spec, options);
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = $root.havocai.messages.v0.PlayExecutionStatus.toObject(message.status, options);
                    return object;
                };

                /**
                 * Converts this PlayExecution to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PlayExecution
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayExecution.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlayExecution
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PlayExecution
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlayExecution.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PlayExecution";
                };

                return PlayExecution;
            })();

            v0.PlayExecutionSpec = (function() {

                /**
                 * Properties of a PlayExecutionSpec.
                 * @memberof havocai.messages.v0
                 * @interface IPlayExecutionSpec
                 * @property {havocai.messages.v0.IResourceRef|null} [playDefinition] PlayExecutionSpec playDefinition
                 * @property {havocai.messages.v0.IResourceRef|null} [team] PlayExecutionSpec team
                 * @property {Array.<havocai.messages.v0.ITaskExecution>|null} [tasks] PlayExecutionSpec tasks
                 * @property {number|null} [avoidanceDistance] PlayExecutionSpec avoidanceDistance
                 * @property {havocai.messages.v0.PlayState|null} [targetState] PlayExecutionSpec targetState
                 */

                /**
                 * Constructs a new PlayExecutionSpec.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PlayExecutionSpec.
                 * @implements IPlayExecutionSpec
                 * @constructor
                 * @param {havocai.messages.v0.IPlayExecutionSpec=} [properties] Properties to set
                 */
                function PlayExecutionSpec(properties) {
                    this.tasks = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlayExecutionSpec playDefinition.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} playDefinition
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @instance
                 */
                PlayExecutionSpec.prototype.playDefinition = null;

                /**
                 * PlayExecutionSpec team.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} team
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @instance
                 */
                PlayExecutionSpec.prototype.team = null;

                /**
                 * PlayExecutionSpec tasks.
                 * @member {Array.<havocai.messages.v0.ITaskExecution>} tasks
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @instance
                 */
                PlayExecutionSpec.prototype.tasks = $util.emptyArray;

                /**
                 * PlayExecutionSpec avoidanceDistance.
                 * @member {number|null|undefined} avoidanceDistance
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @instance
                 */
                PlayExecutionSpec.prototype.avoidanceDistance = null;

                /**
                 * PlayExecutionSpec targetState.
                 * @member {havocai.messages.v0.PlayState} targetState
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @instance
                 */
                PlayExecutionSpec.prototype.targetState = 0;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * PlayExecutionSpec _avoidanceDistance.
                 * @member {"avoidanceDistance"|undefined} _avoidanceDistance
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @instance
                 */
                Object.defineProperty(PlayExecutionSpec.prototype, "_avoidanceDistance", {
                    get: $util.oneOfGetter($oneOfFields = ["avoidanceDistance"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new PlayExecutionSpec instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @static
                 * @param {havocai.messages.v0.IPlayExecutionSpec=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PlayExecutionSpec} PlayExecutionSpec instance
                 */
                PlayExecutionSpec.create = function create(properties) {
                    return new PlayExecutionSpec(properties);
                };

                /**
                 * Encodes the specified PlayExecutionSpec message. Does not implicitly {@link havocai.messages.v0.PlayExecutionSpec.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @static
                 * @param {havocai.messages.v0.IPlayExecutionSpec} message PlayExecutionSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayExecutionSpec.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.playDefinition != null && Object.hasOwnProperty.call(message, "playDefinition"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.playDefinition, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.team, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.tasks != null && message.tasks.length)
                        for (let i = 0; i < message.tasks.length; ++i)
                            $root.havocai.messages.v0.TaskExecution.encode(message.tasks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.avoidanceDistance != null && Object.hasOwnProperty.call(message, "avoidanceDistance"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.avoidanceDistance);
                    if (message.targetState != null && Object.hasOwnProperty.call(message, "targetState"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.targetState);
                    return writer;
                };

                /**
                 * Encodes the specified PlayExecutionSpec message, length delimited. Does not implicitly {@link havocai.messages.v0.PlayExecutionSpec.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @static
                 * @param {havocai.messages.v0.IPlayExecutionSpec} message PlayExecutionSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayExecutionSpec.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlayExecutionSpec message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PlayExecutionSpec} PlayExecutionSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayExecutionSpec.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PlayExecutionSpec();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.playDefinition = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.team = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                if (!(message.tasks && message.tasks.length))
                                    message.tasks = [];
                                message.tasks.push($root.havocai.messages.v0.TaskExecution.decode(reader, reader.uint32()));
                                break;
                            }
                        case 4: {
                                message.avoidanceDistance = reader.double();
                                break;
                            }
                        case 5: {
                                message.targetState = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlayExecutionSpec message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PlayExecutionSpec} PlayExecutionSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayExecutionSpec.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlayExecutionSpec message.
                 * @function verify
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayExecutionSpec.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.playDefinition != null && message.hasOwnProperty("playDefinition")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.playDefinition);
                        if (error)
                            return "playDefinition." + error;
                    }
                    if (message.team != null && message.hasOwnProperty("team")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.team);
                        if (error)
                            return "team." + error;
                    }
                    if (message.tasks != null && message.hasOwnProperty("tasks")) {
                        if (!Array.isArray(message.tasks))
                            return "tasks: array expected";
                        for (let i = 0; i < message.tasks.length; ++i) {
                            let error = $root.havocai.messages.v0.TaskExecution.verify(message.tasks[i]);
                            if (error)
                                return "tasks." + error;
                        }
                    }
                    if (message.avoidanceDistance != null && message.hasOwnProperty("avoidanceDistance")) {
                        properties._avoidanceDistance = 1;
                        if (typeof message.avoidanceDistance !== "number")
                            return "avoidanceDistance: number expected";
                    }
                    if (message.targetState != null && message.hasOwnProperty("targetState"))
                        switch (message.targetState) {
                        default:
                            return "targetState: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a PlayExecutionSpec message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PlayExecutionSpec} PlayExecutionSpec
                 */
                PlayExecutionSpec.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PlayExecutionSpec)
                        return object;
                    let message = new $root.havocai.messages.v0.PlayExecutionSpec();
                    if (object.playDefinition != null) {
                        if (typeof object.playDefinition !== "object")
                            throw TypeError(".havocai.messages.v0.PlayExecutionSpec.playDefinition: object expected");
                        message.playDefinition = $root.havocai.messages.v0.ResourceRef.fromObject(object.playDefinition);
                    }
                    if (object.team != null) {
                        if (typeof object.team !== "object")
                            throw TypeError(".havocai.messages.v0.PlayExecutionSpec.team: object expected");
                        message.team = $root.havocai.messages.v0.ResourceRef.fromObject(object.team);
                    }
                    if (object.tasks) {
                        if (!Array.isArray(object.tasks))
                            throw TypeError(".havocai.messages.v0.PlayExecutionSpec.tasks: array expected");
                        message.tasks = [];
                        for (let i = 0; i < object.tasks.length; ++i) {
                            if (typeof object.tasks[i] !== "object")
                                throw TypeError(".havocai.messages.v0.PlayExecutionSpec.tasks: object expected");
                            message.tasks[i] = $root.havocai.messages.v0.TaskExecution.fromObject(object.tasks[i]);
                        }
                    }
                    if (object.avoidanceDistance != null)
                        message.avoidanceDistance = Number(object.avoidanceDistance);
                    switch (object.targetState) {
                    default:
                        if (typeof object.targetState === "number") {
                            message.targetState = object.targetState;
                            break;
                        }
                        break;
                    case "PLAY_STATE_UNKNOWN":
                    case 0:
                        message.targetState = 0;
                        break;
                    case "PLAY_STATE_IDLE":
                    case 1:
                        message.targetState = 1;
                        break;
                    case "PLAY_STATE_PENDING":
                    case 2:
                        message.targetState = 2;
                        break;
                    case "PLAY_STATE_ACTIVE":
                    case 3:
                        message.targetState = 3;
                        break;
                    case "PLAY_STATE_COMPLETE":
                    case 4:
                        message.targetState = 4;
                        break;
                    case "PLAY_STATE_CANCELED":
                    case 5:
                        message.targetState = 5;
                        break;
                    case "PLAY_STATE_FAILED":
                    case 6:
                        message.targetState = 6;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlayExecutionSpec message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @static
                 * @param {havocai.messages.v0.PlayExecutionSpec} message PlayExecutionSpec
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayExecutionSpec.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.tasks = [];
                    if (options.defaults) {
                        object.playDefinition = null;
                        object.team = null;
                        object.targetState = options.enums === String ? "PLAY_STATE_UNKNOWN" : 0;
                    }
                    if (message.playDefinition != null && message.hasOwnProperty("playDefinition"))
                        object.playDefinition = $root.havocai.messages.v0.ResourceRef.toObject(message.playDefinition, options);
                    if (message.team != null && message.hasOwnProperty("team"))
                        object.team = $root.havocai.messages.v0.ResourceRef.toObject(message.team, options);
                    if (message.tasks && message.tasks.length) {
                        object.tasks = [];
                        for (let j = 0; j < message.tasks.length; ++j)
                            object.tasks[j] = $root.havocai.messages.v0.TaskExecution.toObject(message.tasks[j], options);
                    }
                    if (message.avoidanceDistance != null && message.hasOwnProperty("avoidanceDistance")) {
                        object.avoidanceDistance = options.json && !isFinite(message.avoidanceDistance) ? String(message.avoidanceDistance) : message.avoidanceDistance;
                        if (options.oneofs)
                            object._avoidanceDistance = "avoidanceDistance";
                    }
                    if (message.targetState != null && message.hasOwnProperty("targetState"))
                        object.targetState = options.enums === String ? $root.havocai.messages.v0.PlayState[message.targetState] === undefined ? message.targetState : $root.havocai.messages.v0.PlayState[message.targetState] : message.targetState;
                    return object;
                };

                /**
                 * Converts this PlayExecutionSpec to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayExecutionSpec.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlayExecutionSpec
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PlayExecutionSpec
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlayExecutionSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PlayExecutionSpec";
                };

                return PlayExecutionSpec;
            })();

            v0.PlayExecutionStatus = (function() {

                /**
                 * Properties of a PlayExecutionStatus.
                 * @memberof havocai.messages.v0
                 * @interface IPlayExecutionStatus
                 * @property {havocai.messages.v0.PlayState|null} [state] PlayExecutionStatus state
                 * @property {Array.<havocai.messages.v0.ITaskExecutionStatus>|null} [taskStatuses] PlayExecutionStatus taskStatuses
                 */

                /**
                 * Constructs a new PlayExecutionStatus.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PlayExecutionStatus.
                 * @implements IPlayExecutionStatus
                 * @constructor
                 * @param {havocai.messages.v0.IPlayExecutionStatus=} [properties] Properties to set
                 */
                function PlayExecutionStatus(properties) {
                    this.taskStatuses = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlayExecutionStatus state.
                 * @member {havocai.messages.v0.PlayState} state
                 * @memberof havocai.messages.v0.PlayExecutionStatus
                 * @instance
                 */
                PlayExecutionStatus.prototype.state = 0;

                /**
                 * PlayExecutionStatus taskStatuses.
                 * @member {Array.<havocai.messages.v0.ITaskExecutionStatus>} taskStatuses
                 * @memberof havocai.messages.v0.PlayExecutionStatus
                 * @instance
                 */
                PlayExecutionStatus.prototype.taskStatuses = $util.emptyArray;

                /**
                 * Creates a new PlayExecutionStatus instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PlayExecutionStatus
                 * @static
                 * @param {havocai.messages.v0.IPlayExecutionStatus=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PlayExecutionStatus} PlayExecutionStatus instance
                 */
                PlayExecutionStatus.create = function create(properties) {
                    return new PlayExecutionStatus(properties);
                };

                /**
                 * Encodes the specified PlayExecutionStatus message. Does not implicitly {@link havocai.messages.v0.PlayExecutionStatus.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PlayExecutionStatus
                 * @static
                 * @param {havocai.messages.v0.IPlayExecutionStatus} message PlayExecutionStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayExecutionStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                    if (message.taskStatuses != null && message.taskStatuses.length)
                        for (let i = 0; i < message.taskStatuses.length; ++i)
                            $root.havocai.messages.v0.TaskExecutionStatus.encode(message.taskStatuses[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PlayExecutionStatus message, length delimited. Does not implicitly {@link havocai.messages.v0.PlayExecutionStatus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PlayExecutionStatus
                 * @static
                 * @param {havocai.messages.v0.IPlayExecutionStatus} message PlayExecutionStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayExecutionStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlayExecutionStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PlayExecutionStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PlayExecutionStatus} PlayExecutionStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayExecutionStatus.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PlayExecutionStatus();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.state = reader.int32();
                                break;
                            }
                        case 2: {
                                if (!(message.taskStatuses && message.taskStatuses.length))
                                    message.taskStatuses = [];
                                message.taskStatuses.push($root.havocai.messages.v0.TaskExecutionStatus.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlayExecutionStatus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PlayExecutionStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PlayExecutionStatus} PlayExecutionStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayExecutionStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlayExecutionStatus message.
                 * @function verify
                 * @memberof havocai.messages.v0.PlayExecutionStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayExecutionStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.taskStatuses != null && message.hasOwnProperty("taskStatuses")) {
                        if (!Array.isArray(message.taskStatuses))
                            return "taskStatuses: array expected";
                        for (let i = 0; i < message.taskStatuses.length; ++i) {
                            let error = $root.havocai.messages.v0.TaskExecutionStatus.verify(message.taskStatuses[i]);
                            if (error)
                                return "taskStatuses." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a PlayExecutionStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PlayExecutionStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PlayExecutionStatus} PlayExecutionStatus
                 */
                PlayExecutionStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PlayExecutionStatus)
                        return object;
                    let message = new $root.havocai.messages.v0.PlayExecutionStatus();
                    switch (object.state) {
                    default:
                        if (typeof object.state === "number") {
                            message.state = object.state;
                            break;
                        }
                        break;
                    case "PLAY_STATE_UNKNOWN":
                    case 0:
                        message.state = 0;
                        break;
                    case "PLAY_STATE_IDLE":
                    case 1:
                        message.state = 1;
                        break;
                    case "PLAY_STATE_PENDING":
                    case 2:
                        message.state = 2;
                        break;
                    case "PLAY_STATE_ACTIVE":
                    case 3:
                        message.state = 3;
                        break;
                    case "PLAY_STATE_COMPLETE":
                    case 4:
                        message.state = 4;
                        break;
                    case "PLAY_STATE_CANCELED":
                    case 5:
                        message.state = 5;
                        break;
                    case "PLAY_STATE_FAILED":
                    case 6:
                        message.state = 6;
                        break;
                    }
                    if (object.taskStatuses) {
                        if (!Array.isArray(object.taskStatuses))
                            throw TypeError(".havocai.messages.v0.PlayExecutionStatus.taskStatuses: array expected");
                        message.taskStatuses = [];
                        for (let i = 0; i < object.taskStatuses.length; ++i) {
                            if (typeof object.taskStatuses[i] !== "object")
                                throw TypeError(".havocai.messages.v0.PlayExecutionStatus.taskStatuses: object expected");
                            message.taskStatuses[i] = $root.havocai.messages.v0.TaskExecutionStatus.fromObject(object.taskStatuses[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlayExecutionStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PlayExecutionStatus
                 * @static
                 * @param {havocai.messages.v0.PlayExecutionStatus} message PlayExecutionStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayExecutionStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.taskStatuses = [];
                    if (options.defaults)
                        object.state = options.enums === String ? "PLAY_STATE_UNKNOWN" : 0;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = options.enums === String ? $root.havocai.messages.v0.PlayState[message.state] === undefined ? message.state : $root.havocai.messages.v0.PlayState[message.state] : message.state;
                    if (message.taskStatuses && message.taskStatuses.length) {
                        object.taskStatuses = [];
                        for (let j = 0; j < message.taskStatuses.length; ++j)
                            object.taskStatuses[j] = $root.havocai.messages.v0.TaskExecutionStatus.toObject(message.taskStatuses[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this PlayExecutionStatus to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PlayExecutionStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayExecutionStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlayExecutionStatus
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PlayExecutionStatus
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlayExecutionStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PlayExecutionStatus";
                };

                return PlayExecutionStatus;
            })();

            v0.TaskExecutionStatus = (function() {

                /**
                 * Properties of a TaskExecutionStatus.
                 * @memberof havocai.messages.v0
                 * @interface ITaskExecutionStatus
                 * @property {havocai.messages.v0.TaskState|null} [state] TaskExecutionStatus state
                 * @property {havocai.messages.v0.TaskType|null} [type] TaskExecutionStatus type
                 * @property {string|null} [taskExecutionId] TaskExecutionStatus taskExecutionId
                 * @property {string|null} [taskDefinitionId] TaskExecutionStatus taskDefinitionId
                 * @property {number|null} [boatCount] TaskExecutionStatus boatCount
                 * @property {number|Long|null} [eta] TaskExecutionStatus eta
                 * @property {number|Long|null} [lastEta] TaskExecutionStatus lastEta
                 * @property {Array.<string>|null} [conditionalsPending] TaskExecutionStatus conditionalsPending
                 * @property {Array.<string>|null} [conditionalsMet] TaskExecutionStatus conditionalsMet
                 */

                /**
                 * Constructs a new TaskExecutionStatus.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a TaskExecutionStatus.
                 * @implements ITaskExecutionStatus
                 * @constructor
                 * @param {havocai.messages.v0.ITaskExecutionStatus=} [properties] Properties to set
                 */
                function TaskExecutionStatus(properties) {
                    this.conditionalsPending = [];
                    this.conditionalsMet = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TaskExecutionStatus state.
                 * @member {havocai.messages.v0.TaskState} state
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @instance
                 */
                TaskExecutionStatus.prototype.state = 0;

                /**
                 * TaskExecutionStatus type.
                 * @member {havocai.messages.v0.TaskType} type
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @instance
                 */
                TaskExecutionStatus.prototype.type = 0;

                /**
                 * TaskExecutionStatus taskExecutionId.
                 * @member {string} taskExecutionId
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @instance
                 */
                TaskExecutionStatus.prototype.taskExecutionId = "";

                /**
                 * TaskExecutionStatus taskDefinitionId.
                 * @member {string} taskDefinitionId
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @instance
                 */
                TaskExecutionStatus.prototype.taskDefinitionId = "";

                /**
                 * TaskExecutionStatus boatCount.
                 * @member {number} boatCount
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @instance
                 */
                TaskExecutionStatus.prototype.boatCount = 0;

                /**
                 * TaskExecutionStatus eta.
                 * @member {number|Long} eta
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @instance
                 */
                TaskExecutionStatus.prototype.eta = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TaskExecutionStatus lastEta.
                 * @member {number|Long} lastEta
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @instance
                 */
                TaskExecutionStatus.prototype.lastEta = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TaskExecutionStatus conditionalsPending.
                 * @member {Array.<string>} conditionalsPending
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @instance
                 */
                TaskExecutionStatus.prototype.conditionalsPending = $util.emptyArray;

                /**
                 * TaskExecutionStatus conditionalsMet.
                 * @member {Array.<string>} conditionalsMet
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @instance
                 */
                TaskExecutionStatus.prototype.conditionalsMet = $util.emptyArray;

                /**
                 * Creates a new TaskExecutionStatus instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @static
                 * @param {havocai.messages.v0.ITaskExecutionStatus=} [properties] Properties to set
                 * @returns {havocai.messages.v0.TaskExecutionStatus} TaskExecutionStatus instance
                 */
                TaskExecutionStatus.create = function create(properties) {
                    return new TaskExecutionStatus(properties);
                };

                /**
                 * Encodes the specified TaskExecutionStatus message. Does not implicitly {@link havocai.messages.v0.TaskExecutionStatus.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @static
                 * @param {havocai.messages.v0.ITaskExecutionStatus} message TaskExecutionStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.taskExecutionId != null && Object.hasOwnProperty.call(message, "taskExecutionId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.taskExecutionId);
                    if (message.taskDefinitionId != null && Object.hasOwnProperty.call(message, "taskDefinitionId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.taskDefinitionId);
                    if (message.boatCount != null && Object.hasOwnProperty.call(message, "boatCount"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.boatCount);
                    if (message.eta != null && Object.hasOwnProperty.call(message, "eta"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.eta);
                    if (message.lastEta != null && Object.hasOwnProperty.call(message, "lastEta"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.lastEta);
                    if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.state);
                    if (message.conditionalsPending != null && message.conditionalsPending.length)
                        for (let i = 0; i < message.conditionalsPending.length; ++i)
                            writer.uint32(/* id 8, wireType 2 =*/66).string(message.conditionalsPending[i]);
                    if (message.conditionalsMet != null && message.conditionalsMet.length)
                        for (let i = 0; i < message.conditionalsMet.length; ++i)
                            writer.uint32(/* id 9, wireType 2 =*/74).string(message.conditionalsMet[i]);
                    return writer;
                };

                /**
                 * Encodes the specified TaskExecutionStatus message, length delimited. Does not implicitly {@link havocai.messages.v0.TaskExecutionStatus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @static
                 * @param {havocai.messages.v0.ITaskExecutionStatus} message TaskExecutionStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TaskExecutionStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TaskExecutionStatus message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.TaskExecutionStatus} TaskExecutionStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionStatus.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.TaskExecutionStatus();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 7: {
                                message.state = reader.int32();
                                break;
                            }
                        case 1: {
                                message.type = reader.int32();
                                break;
                            }
                        case 2: {
                                message.taskExecutionId = reader.string();
                                break;
                            }
                        case 3: {
                                message.taskDefinitionId = reader.string();
                                break;
                            }
                        case 4: {
                                message.boatCount = reader.uint32();
                                break;
                            }
                        case 5: {
                                message.eta = reader.int64();
                                break;
                            }
                        case 6: {
                                message.lastEta = reader.int64();
                                break;
                            }
                        case 8: {
                                if (!(message.conditionalsPending && message.conditionalsPending.length))
                                    message.conditionalsPending = [];
                                message.conditionalsPending.push(reader.string());
                                break;
                            }
                        case 9: {
                                if (!(message.conditionalsMet && message.conditionalsMet.length))
                                    message.conditionalsMet = [];
                                message.conditionalsMet.push(reader.string());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TaskExecutionStatus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.TaskExecutionStatus} TaskExecutionStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TaskExecutionStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TaskExecutionStatus message.
                 * @function verify
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TaskExecutionStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                            break;
                        }
                    if (message.taskExecutionId != null && message.hasOwnProperty("taskExecutionId"))
                        if (!$util.isString(message.taskExecutionId))
                            return "taskExecutionId: string expected";
                    if (message.taskDefinitionId != null && message.hasOwnProperty("taskDefinitionId"))
                        if (!$util.isString(message.taskDefinitionId))
                            return "taskDefinitionId: string expected";
                    if (message.boatCount != null && message.hasOwnProperty("boatCount"))
                        if (!$util.isInteger(message.boatCount))
                            return "boatCount: integer expected";
                    if (message.eta != null && message.hasOwnProperty("eta"))
                        if (!$util.isInteger(message.eta) && !(message.eta && $util.isInteger(message.eta.low) && $util.isInteger(message.eta.high)))
                            return "eta: integer|Long expected";
                    if (message.lastEta != null && message.hasOwnProperty("lastEta"))
                        if (!$util.isInteger(message.lastEta) && !(message.lastEta && $util.isInteger(message.lastEta.low) && $util.isInteger(message.lastEta.high)))
                            return "lastEta: integer|Long expected";
                    if (message.conditionalsPending != null && message.hasOwnProperty("conditionalsPending")) {
                        if (!Array.isArray(message.conditionalsPending))
                            return "conditionalsPending: array expected";
                        for (let i = 0; i < message.conditionalsPending.length; ++i)
                            if (!$util.isString(message.conditionalsPending[i]))
                                return "conditionalsPending: string[] expected";
                    }
                    if (message.conditionalsMet != null && message.hasOwnProperty("conditionalsMet")) {
                        if (!Array.isArray(message.conditionalsMet))
                            return "conditionalsMet: array expected";
                        for (let i = 0; i < message.conditionalsMet.length; ++i)
                            if (!$util.isString(message.conditionalsMet[i]))
                                return "conditionalsMet: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a TaskExecutionStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.TaskExecutionStatus} TaskExecutionStatus
                 */
                TaskExecutionStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.TaskExecutionStatus)
                        return object;
                    let message = new $root.havocai.messages.v0.TaskExecutionStatus();
                    switch (object.state) {
                    default:
                        if (typeof object.state === "number") {
                            message.state = object.state;
                            break;
                        }
                        break;
                    case "TASK_STATE_UNKNOWN":
                    case 0:
                        message.state = 0;
                        break;
                    case "TASK_STATE_ACTIVE":
                    case 1:
                        message.state = 1;
                        break;
                    case "TASK_STATE_AWAITING_CONDITIONAL":
                    case 2:
                        message.state = 2;
                        break;
                    case "TASK_STATE_COMPLETE":
                    case 3:
                        message.state = 3;
                        break;
                    case "TASK_STATE_CANCELED":
                    case 4:
                        message.state = 4;
                        break;
                    case "TASK_STATE_FAILED":
                    case 5:
                        message.state = 5;
                        break;
                    }
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "TASK_TYPE_UNSPECIFIED":
                    case 0:
                        message.type = 0;
                        break;
                    case "TASK_TYPE_ROUTE":
                    case 1:
                        message.type = 1;
                        break;
                    case "TASK_TYPE_SEARCH":
                    case 2:
                        message.type = 2;
                        break;
                    case "TASK_TYPE_ENGAGE":
                    case 3:
                        message.type = 3;
                        break;
                    case "TASK_TYPE_COOPERATIVE_FORMATION":
                    case 4:
                        message.type = 4;
                        break;
                    case "TASK_TYPE_GEO_FORMATION":
                    case 5:
                        message.type = 5;
                        break;
                    case "TASK_TYPE_ESCORT":
                    case 6:
                        message.type = 6;
                        break;
                    case "TASK_TYPE_CHECKOUT":
                    case 7:
                        message.type = 7;
                        break;
                    case "TASK_TYPE_PATROL":
                    case 8:
                        message.type = 8;
                        break;
                    case "TASK_TYPE_DRIFT":
                    case 9:
                        message.type = 9;
                        break;
                    }
                    if (object.taskExecutionId != null)
                        message.taskExecutionId = String(object.taskExecutionId);
                    if (object.taskDefinitionId != null)
                        message.taskDefinitionId = String(object.taskDefinitionId);
                    if (object.boatCount != null)
                        message.boatCount = object.boatCount >>> 0;
                    if (object.eta != null)
                        if ($util.Long)
                            (message.eta = $util.Long.fromValue(object.eta)).unsigned = false;
                        else if (typeof object.eta === "string")
                            message.eta = parseInt(object.eta, 10);
                        else if (typeof object.eta === "number")
                            message.eta = object.eta;
                        else if (typeof object.eta === "object")
                            message.eta = new $util.LongBits(object.eta.low >>> 0, object.eta.high >>> 0).toNumber();
                    if (object.lastEta != null)
                        if ($util.Long)
                            (message.lastEta = $util.Long.fromValue(object.lastEta)).unsigned = false;
                        else if (typeof object.lastEta === "string")
                            message.lastEta = parseInt(object.lastEta, 10);
                        else if (typeof object.lastEta === "number")
                            message.lastEta = object.lastEta;
                        else if (typeof object.lastEta === "object")
                            message.lastEta = new $util.LongBits(object.lastEta.low >>> 0, object.lastEta.high >>> 0).toNumber();
                    if (object.conditionalsPending) {
                        if (!Array.isArray(object.conditionalsPending))
                            throw TypeError(".havocai.messages.v0.TaskExecutionStatus.conditionalsPending: array expected");
                        message.conditionalsPending = [];
                        for (let i = 0; i < object.conditionalsPending.length; ++i)
                            message.conditionalsPending[i] = String(object.conditionalsPending[i]);
                    }
                    if (object.conditionalsMet) {
                        if (!Array.isArray(object.conditionalsMet))
                            throw TypeError(".havocai.messages.v0.TaskExecutionStatus.conditionalsMet: array expected");
                        message.conditionalsMet = [];
                        for (let i = 0; i < object.conditionalsMet.length; ++i)
                            message.conditionalsMet[i] = String(object.conditionalsMet[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TaskExecutionStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @static
                 * @param {havocai.messages.v0.TaskExecutionStatus} message TaskExecutionStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TaskExecutionStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.conditionalsPending = [];
                        object.conditionalsMet = [];
                    }
                    if (options.defaults) {
                        object.type = options.enums === String ? "TASK_TYPE_UNSPECIFIED" : 0;
                        object.taskExecutionId = "";
                        object.taskDefinitionId = "";
                        object.boatCount = 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.eta = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.eta = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.lastEta = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.lastEta = options.longs === String ? "0" : 0;
                        object.state = options.enums === String ? "TASK_STATE_UNKNOWN" : 0;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.havocai.messages.v0.TaskType[message.type] === undefined ? message.type : $root.havocai.messages.v0.TaskType[message.type] : message.type;
                    if (message.taskExecutionId != null && message.hasOwnProperty("taskExecutionId"))
                        object.taskExecutionId = message.taskExecutionId;
                    if (message.taskDefinitionId != null && message.hasOwnProperty("taskDefinitionId"))
                        object.taskDefinitionId = message.taskDefinitionId;
                    if (message.boatCount != null && message.hasOwnProperty("boatCount"))
                        object.boatCount = message.boatCount;
                    if (message.eta != null && message.hasOwnProperty("eta"))
                        if (typeof message.eta === "number")
                            object.eta = options.longs === String ? String(message.eta) : message.eta;
                        else
                            object.eta = options.longs === String ? $util.Long.prototype.toString.call(message.eta) : options.longs === Number ? new $util.LongBits(message.eta.low >>> 0, message.eta.high >>> 0).toNumber() : message.eta;
                    if (message.lastEta != null && message.hasOwnProperty("lastEta"))
                        if (typeof message.lastEta === "number")
                            object.lastEta = options.longs === String ? String(message.lastEta) : message.lastEta;
                        else
                            object.lastEta = options.longs === String ? $util.Long.prototype.toString.call(message.lastEta) : options.longs === Number ? new $util.LongBits(message.lastEta.low >>> 0, message.lastEta.high >>> 0).toNumber() : message.lastEta;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = options.enums === String ? $root.havocai.messages.v0.TaskState[message.state] === undefined ? message.state : $root.havocai.messages.v0.TaskState[message.state] : message.state;
                    if (message.conditionalsPending && message.conditionalsPending.length) {
                        object.conditionalsPending = [];
                        for (let j = 0; j < message.conditionalsPending.length; ++j)
                            object.conditionalsPending[j] = message.conditionalsPending[j];
                    }
                    if (message.conditionalsMet && message.conditionalsMet.length) {
                        object.conditionalsMet = [];
                        for (let j = 0; j < message.conditionalsMet.length; ++j)
                            object.conditionalsMet[j] = message.conditionalsMet[j];
                    }
                    return object;
                };

                /**
                 * Converts this TaskExecutionStatus to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TaskExecutionStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TaskExecutionStatus
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.TaskExecutionStatus
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TaskExecutionStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.TaskExecutionStatus";
                };

                return TaskExecutionStatus;
            })();

            v0.PlayExecutionList = (function() {

                /**
                 * Properties of a PlayExecutionList.
                 * @memberof havocai.messages.v0
                 * @interface IPlayExecutionList
                 * @property {Array.<havocai.messages.v0.IPlayExecution>|null} [values] PlayExecutionList values
                 */

                /**
                 * Constructs a new PlayExecutionList.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PlayExecutionList.
                 * @implements IPlayExecutionList
                 * @constructor
                 * @param {havocai.messages.v0.IPlayExecutionList=} [properties] Properties to set
                 */
                function PlayExecutionList(properties) {
                    this.values = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlayExecutionList values.
                 * @member {Array.<havocai.messages.v0.IPlayExecution>} values
                 * @memberof havocai.messages.v0.PlayExecutionList
                 * @instance
                 */
                PlayExecutionList.prototype.values = $util.emptyArray;

                /**
                 * Creates a new PlayExecutionList instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PlayExecutionList
                 * @static
                 * @param {havocai.messages.v0.IPlayExecutionList=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PlayExecutionList} PlayExecutionList instance
                 */
                PlayExecutionList.create = function create(properties) {
                    return new PlayExecutionList(properties);
                };

                /**
                 * Encodes the specified PlayExecutionList message. Does not implicitly {@link havocai.messages.v0.PlayExecutionList.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PlayExecutionList
                 * @static
                 * @param {havocai.messages.v0.IPlayExecutionList} message PlayExecutionList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayExecutionList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (let i = 0; i < message.values.length; ++i)
                            $root.havocai.messages.v0.PlayExecution.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PlayExecutionList message, length delimited. Does not implicitly {@link havocai.messages.v0.PlayExecutionList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PlayExecutionList
                 * @static
                 * @param {havocai.messages.v0.IPlayExecutionList} message PlayExecutionList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayExecutionList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlayExecutionList message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PlayExecutionList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PlayExecutionList} PlayExecutionList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayExecutionList.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PlayExecutionList();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.values && message.values.length))
                                    message.values = [];
                                message.values.push($root.havocai.messages.v0.PlayExecution.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlayExecutionList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PlayExecutionList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PlayExecutionList} PlayExecutionList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayExecutionList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlayExecutionList message.
                 * @function verify
                 * @memberof havocai.messages.v0.PlayExecutionList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayExecutionList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (let i = 0; i < message.values.length; ++i) {
                            let error = $root.havocai.messages.v0.PlayExecution.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a PlayExecutionList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PlayExecutionList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PlayExecutionList} PlayExecutionList
                 */
                PlayExecutionList.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PlayExecutionList)
                        return object;
                    let message = new $root.havocai.messages.v0.PlayExecutionList();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".havocai.messages.v0.PlayExecutionList.values: array expected");
                        message.values = [];
                        for (let i = 0; i < object.values.length; ++i) {
                            if (typeof object.values[i] !== "object")
                                throw TypeError(".havocai.messages.v0.PlayExecutionList.values: object expected");
                            message.values[i] = $root.havocai.messages.v0.PlayExecution.fromObject(object.values[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlayExecutionList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PlayExecutionList
                 * @static
                 * @param {havocai.messages.v0.PlayExecutionList} message PlayExecutionList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayExecutionList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (let j = 0; j < message.values.length; ++j)
                            object.values[j] = $root.havocai.messages.v0.PlayExecution.toObject(message.values[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this PlayExecutionList to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PlayExecutionList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayExecutionList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlayExecutionList
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PlayExecutionList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlayExecutionList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PlayExecutionList";
                };

                return PlayExecutionList;
            })();

            v0.PlayRunner = (function() {

                /**
                 * Properties of a PlayRunner.
                 * @memberof havocai.messages.v0
                 * @interface IPlayRunner
                 * @property {havocai.messages.v0.IMetadata|null} [meta] PlayRunner meta
                 * @property {havocai.messages.v0.IPlayRunnerSpec|null} [spec] PlayRunner spec
                 */

                /**
                 * Constructs a new PlayRunner.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PlayRunner.
                 * @implements IPlayRunner
                 * @constructor
                 * @param {havocai.messages.v0.IPlayRunner=} [properties] Properties to set
                 */
                function PlayRunner(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlayRunner meta.
                 * @member {havocai.messages.v0.IMetadata|null|undefined} meta
                 * @memberof havocai.messages.v0.PlayRunner
                 * @instance
                 */
                PlayRunner.prototype.meta = null;

                /**
                 * PlayRunner spec.
                 * @member {havocai.messages.v0.IPlayRunnerSpec|null|undefined} spec
                 * @memberof havocai.messages.v0.PlayRunner
                 * @instance
                 */
                PlayRunner.prototype.spec = null;

                /**
                 * Creates a new PlayRunner instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PlayRunner
                 * @static
                 * @param {havocai.messages.v0.IPlayRunner=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PlayRunner} PlayRunner instance
                 */
                PlayRunner.create = function create(properties) {
                    return new PlayRunner(properties);
                };

                /**
                 * Encodes the specified PlayRunner message. Does not implicitly {@link havocai.messages.v0.PlayRunner.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PlayRunner
                 * @static
                 * @param {havocai.messages.v0.IPlayRunner} message PlayRunner message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayRunner.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.meta != null && Object.hasOwnProperty.call(message, "meta"))
                        $root.havocai.messages.v0.Metadata.encode(message.meta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.spec != null && Object.hasOwnProperty.call(message, "spec"))
                        $root.havocai.messages.v0.PlayRunnerSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PlayRunner message, length delimited. Does not implicitly {@link havocai.messages.v0.PlayRunner.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PlayRunner
                 * @static
                 * @param {havocai.messages.v0.IPlayRunner} message PlayRunner message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayRunner.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlayRunner message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PlayRunner
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PlayRunner} PlayRunner
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayRunner.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PlayRunner();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.meta = $root.havocai.messages.v0.Metadata.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.spec = $root.havocai.messages.v0.PlayRunnerSpec.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlayRunner message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PlayRunner
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PlayRunner} PlayRunner
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayRunner.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlayRunner message.
                 * @function verify
                 * @memberof havocai.messages.v0.PlayRunner
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayRunner.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.meta != null && message.hasOwnProperty("meta")) {
                        let error = $root.havocai.messages.v0.Metadata.verify(message.meta);
                        if (error)
                            return "meta." + error;
                    }
                    if (message.spec != null && message.hasOwnProperty("spec")) {
                        let error = $root.havocai.messages.v0.PlayRunnerSpec.verify(message.spec);
                        if (error)
                            return "spec." + error;
                    }
                    return null;
                };

                /**
                 * Creates a PlayRunner message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PlayRunner
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PlayRunner} PlayRunner
                 */
                PlayRunner.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PlayRunner)
                        return object;
                    let message = new $root.havocai.messages.v0.PlayRunner();
                    if (object.meta != null) {
                        if (typeof object.meta !== "object")
                            throw TypeError(".havocai.messages.v0.PlayRunner.meta: object expected");
                        message.meta = $root.havocai.messages.v0.Metadata.fromObject(object.meta);
                    }
                    if (object.spec != null) {
                        if (typeof object.spec !== "object")
                            throw TypeError(".havocai.messages.v0.PlayRunner.spec: object expected");
                        message.spec = $root.havocai.messages.v0.PlayRunnerSpec.fromObject(object.spec);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlayRunner message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PlayRunner
                 * @static
                 * @param {havocai.messages.v0.PlayRunner} message PlayRunner
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayRunner.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.meta = null;
                        object.spec = null;
                    }
                    if (message.meta != null && message.hasOwnProperty("meta"))
                        object.meta = $root.havocai.messages.v0.Metadata.toObject(message.meta, options);
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        object.spec = $root.havocai.messages.v0.PlayRunnerSpec.toObject(message.spec, options);
                    return object;
                };

                /**
                 * Converts this PlayRunner to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PlayRunner
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayRunner.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlayRunner
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PlayRunner
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlayRunner.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PlayRunner";
                };

                return PlayRunner;
            })();

            v0.PlayRunnerSpec = (function() {

                /**
                 * Properties of a PlayRunnerSpec.
                 * @memberof havocai.messages.v0
                 * @interface IPlayRunnerSpec
                 * @property {havocai.messages.v0.IResourceRef|null} [playExecution] PlayRunnerSpec playExecution
                 */

                /**
                 * Constructs a new PlayRunnerSpec.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PlayRunnerSpec.
                 * @implements IPlayRunnerSpec
                 * @constructor
                 * @param {havocai.messages.v0.IPlayRunnerSpec=} [properties] Properties to set
                 */
                function PlayRunnerSpec(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlayRunnerSpec playExecution.
                 * @member {havocai.messages.v0.IResourceRef|null|undefined} playExecution
                 * @memberof havocai.messages.v0.PlayRunnerSpec
                 * @instance
                 */
                PlayRunnerSpec.prototype.playExecution = null;

                /**
                 * Creates a new PlayRunnerSpec instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PlayRunnerSpec
                 * @static
                 * @param {havocai.messages.v0.IPlayRunnerSpec=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PlayRunnerSpec} PlayRunnerSpec instance
                 */
                PlayRunnerSpec.create = function create(properties) {
                    return new PlayRunnerSpec(properties);
                };

                /**
                 * Encodes the specified PlayRunnerSpec message. Does not implicitly {@link havocai.messages.v0.PlayRunnerSpec.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PlayRunnerSpec
                 * @static
                 * @param {havocai.messages.v0.IPlayRunnerSpec} message PlayRunnerSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayRunnerSpec.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.playExecution != null && Object.hasOwnProperty.call(message, "playExecution"))
                        $root.havocai.messages.v0.ResourceRef.encode(message.playExecution, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PlayRunnerSpec message, length delimited. Does not implicitly {@link havocai.messages.v0.PlayRunnerSpec.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PlayRunnerSpec
                 * @static
                 * @param {havocai.messages.v0.IPlayRunnerSpec} message PlayRunnerSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayRunnerSpec.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlayRunnerSpec message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PlayRunnerSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PlayRunnerSpec} PlayRunnerSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayRunnerSpec.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PlayRunnerSpec();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.playExecution = $root.havocai.messages.v0.ResourceRef.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlayRunnerSpec message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PlayRunnerSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PlayRunnerSpec} PlayRunnerSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayRunnerSpec.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlayRunnerSpec message.
                 * @function verify
                 * @memberof havocai.messages.v0.PlayRunnerSpec
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayRunnerSpec.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.playExecution != null && message.hasOwnProperty("playExecution")) {
                        let error = $root.havocai.messages.v0.ResourceRef.verify(message.playExecution);
                        if (error)
                            return "playExecution." + error;
                    }
                    return null;
                };

                /**
                 * Creates a PlayRunnerSpec message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PlayRunnerSpec
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PlayRunnerSpec} PlayRunnerSpec
                 */
                PlayRunnerSpec.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PlayRunnerSpec)
                        return object;
                    let message = new $root.havocai.messages.v0.PlayRunnerSpec();
                    if (object.playExecution != null) {
                        if (typeof object.playExecution !== "object")
                            throw TypeError(".havocai.messages.v0.PlayRunnerSpec.playExecution: object expected");
                        message.playExecution = $root.havocai.messages.v0.ResourceRef.fromObject(object.playExecution);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlayRunnerSpec message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PlayRunnerSpec
                 * @static
                 * @param {havocai.messages.v0.PlayRunnerSpec} message PlayRunnerSpec
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayRunnerSpec.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.playExecution = null;
                    if (message.playExecution != null && message.hasOwnProperty("playExecution"))
                        object.playExecution = $root.havocai.messages.v0.ResourceRef.toObject(message.playExecution, options);
                    return object;
                };

                /**
                 * Converts this PlayRunnerSpec to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PlayRunnerSpec
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayRunnerSpec.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlayRunnerSpec
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PlayRunnerSpec
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlayRunnerSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PlayRunnerSpec";
                };

                return PlayRunnerSpec;
            })();

            v0.PlayRunnerList = (function() {

                /**
                 * Properties of a PlayRunnerList.
                 * @memberof havocai.messages.v0
                 * @interface IPlayRunnerList
                 * @property {Array.<havocai.messages.v0.IPlayRunner>|null} [values] PlayRunnerList values
                 */

                /**
                 * Constructs a new PlayRunnerList.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a PlayRunnerList.
                 * @implements IPlayRunnerList
                 * @constructor
                 * @param {havocai.messages.v0.IPlayRunnerList=} [properties] Properties to set
                 */
                function PlayRunnerList(properties) {
                    this.values = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PlayRunnerList values.
                 * @member {Array.<havocai.messages.v0.IPlayRunner>} values
                 * @memberof havocai.messages.v0.PlayRunnerList
                 * @instance
                 */
                PlayRunnerList.prototype.values = $util.emptyArray;

                /**
                 * Creates a new PlayRunnerList instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.PlayRunnerList
                 * @static
                 * @param {havocai.messages.v0.IPlayRunnerList=} [properties] Properties to set
                 * @returns {havocai.messages.v0.PlayRunnerList} PlayRunnerList instance
                 */
                PlayRunnerList.create = function create(properties) {
                    return new PlayRunnerList(properties);
                };

                /**
                 * Encodes the specified PlayRunnerList message. Does not implicitly {@link havocai.messages.v0.PlayRunnerList.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.PlayRunnerList
                 * @static
                 * @param {havocai.messages.v0.IPlayRunnerList} message PlayRunnerList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayRunnerList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (let i = 0; i < message.values.length; ++i)
                            $root.havocai.messages.v0.PlayRunner.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PlayRunnerList message, length delimited. Does not implicitly {@link havocai.messages.v0.PlayRunnerList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.PlayRunnerList
                 * @static
                 * @param {havocai.messages.v0.IPlayRunnerList} message PlayRunnerList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlayRunnerList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PlayRunnerList message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.PlayRunnerList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.PlayRunnerList} PlayRunnerList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayRunnerList.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.PlayRunnerList();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.values && message.values.length))
                                    message.values = [];
                                message.values.push($root.havocai.messages.v0.PlayRunner.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PlayRunnerList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.PlayRunnerList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.PlayRunnerList} PlayRunnerList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlayRunnerList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PlayRunnerList message.
                 * @function verify
                 * @memberof havocai.messages.v0.PlayRunnerList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PlayRunnerList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (let i = 0; i < message.values.length; ++i) {
                            let error = $root.havocai.messages.v0.PlayRunner.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a PlayRunnerList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.PlayRunnerList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.PlayRunnerList} PlayRunnerList
                 */
                PlayRunnerList.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.PlayRunnerList)
                        return object;
                    let message = new $root.havocai.messages.v0.PlayRunnerList();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".havocai.messages.v0.PlayRunnerList.values: array expected");
                        message.values = [];
                        for (let i = 0; i < object.values.length; ++i) {
                            if (typeof object.values[i] !== "object")
                                throw TypeError(".havocai.messages.v0.PlayRunnerList.values: object expected");
                            message.values[i] = $root.havocai.messages.v0.PlayRunner.fromObject(object.values[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PlayRunnerList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.PlayRunnerList
                 * @static
                 * @param {havocai.messages.v0.PlayRunnerList} message PlayRunnerList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlayRunnerList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (let j = 0; j < message.values.length; ++j)
                            object.values[j] = $root.havocai.messages.v0.PlayRunner.toObject(message.values[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this PlayRunnerList to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.PlayRunnerList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlayRunnerList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PlayRunnerList
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.PlayRunnerList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PlayRunnerList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.PlayRunnerList";
                };

                return PlayRunnerList;
            })();

            v0.Simulation = (function() {

                /**
                 * Properties of a Simulation.
                 * @memberof havocai.messages.v0
                 * @interface ISimulation
                 * @property {havocai.messages.v0.IMetadata|null} [meta] Simulation meta
                 * @property {havocai.messages.v0.ISimulationSpec|null} [spec] Simulation spec
                 */

                /**
                 * Constructs a new Simulation.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a Simulation.
                 * @implements ISimulation
                 * @constructor
                 * @param {havocai.messages.v0.ISimulation=} [properties] Properties to set
                 */
                function Simulation(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Simulation meta.
                 * @member {havocai.messages.v0.IMetadata|null|undefined} meta
                 * @memberof havocai.messages.v0.Simulation
                 * @instance
                 */
                Simulation.prototype.meta = null;

                /**
                 * Simulation spec.
                 * @member {havocai.messages.v0.ISimulationSpec|null|undefined} spec
                 * @memberof havocai.messages.v0.Simulation
                 * @instance
                 */
                Simulation.prototype.spec = null;

                /**
                 * Creates a new Simulation instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.Simulation
                 * @static
                 * @param {havocai.messages.v0.ISimulation=} [properties] Properties to set
                 * @returns {havocai.messages.v0.Simulation} Simulation instance
                 */
                Simulation.create = function create(properties) {
                    return new Simulation(properties);
                };

                /**
                 * Encodes the specified Simulation message. Does not implicitly {@link havocai.messages.v0.Simulation.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.Simulation
                 * @static
                 * @param {havocai.messages.v0.ISimulation} message Simulation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Simulation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.meta != null && Object.hasOwnProperty.call(message, "meta"))
                        $root.havocai.messages.v0.Metadata.encode(message.meta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.spec != null && Object.hasOwnProperty.call(message, "spec"))
                        $root.havocai.messages.v0.SimulationSpec.encode(message.spec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Simulation message, length delimited. Does not implicitly {@link havocai.messages.v0.Simulation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.Simulation
                 * @static
                 * @param {havocai.messages.v0.ISimulation} message Simulation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Simulation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Simulation message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.Simulation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.Simulation} Simulation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Simulation.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.Simulation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.meta = $root.havocai.messages.v0.Metadata.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.spec = $root.havocai.messages.v0.SimulationSpec.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Simulation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.Simulation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.Simulation} Simulation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Simulation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Simulation message.
                 * @function verify
                 * @memberof havocai.messages.v0.Simulation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Simulation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.meta != null && message.hasOwnProperty("meta")) {
                        let error = $root.havocai.messages.v0.Metadata.verify(message.meta);
                        if (error)
                            return "meta." + error;
                    }
                    if (message.spec != null && message.hasOwnProperty("spec")) {
                        let error = $root.havocai.messages.v0.SimulationSpec.verify(message.spec);
                        if (error)
                            return "spec." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Simulation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.Simulation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.Simulation} Simulation
                 */
                Simulation.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.Simulation)
                        return object;
                    let message = new $root.havocai.messages.v0.Simulation();
                    if (object.meta != null) {
                        if (typeof object.meta !== "object")
                            throw TypeError(".havocai.messages.v0.Simulation.meta: object expected");
                        message.meta = $root.havocai.messages.v0.Metadata.fromObject(object.meta);
                    }
                    if (object.spec != null) {
                        if (typeof object.spec !== "object")
                            throw TypeError(".havocai.messages.v0.Simulation.spec: object expected");
                        message.spec = $root.havocai.messages.v0.SimulationSpec.fromObject(object.spec);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Simulation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.Simulation
                 * @static
                 * @param {havocai.messages.v0.Simulation} message Simulation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Simulation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.meta = null;
                        object.spec = null;
                    }
                    if (message.meta != null && message.hasOwnProperty("meta"))
                        object.meta = $root.havocai.messages.v0.Metadata.toObject(message.meta, options);
                    if (message.spec != null && message.hasOwnProperty("spec"))
                        object.spec = $root.havocai.messages.v0.SimulationSpec.toObject(message.spec, options);
                    return object;
                };

                /**
                 * Converts this Simulation to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.Simulation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Simulation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Simulation
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.Simulation
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Simulation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.Simulation";
                };

                return Simulation;
            })();

            v0.SimulationSpec = (function() {

                /**
                 * Properties of a SimulationSpec.
                 * @memberof havocai.messages.v0
                 * @interface ISimulationSpec
                 * @property {number|null} [multiplier] SimulationSpec multiplier
                 * @property {Array.<havocai.messages.v0.ITrackSimulation>|null} [tracks] SimulationSpec tracks
                 */

                /**
                 * Constructs a new SimulationSpec.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a SimulationSpec.
                 * @implements ISimulationSpec
                 * @constructor
                 * @param {havocai.messages.v0.ISimulationSpec=} [properties] Properties to set
                 */
                function SimulationSpec(properties) {
                    this.tracks = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SimulationSpec multiplier.
                 * @member {number} multiplier
                 * @memberof havocai.messages.v0.SimulationSpec
                 * @instance
                 */
                SimulationSpec.prototype.multiplier = 0;

                /**
                 * SimulationSpec tracks.
                 * @member {Array.<havocai.messages.v0.ITrackSimulation>} tracks
                 * @memberof havocai.messages.v0.SimulationSpec
                 * @instance
                 */
                SimulationSpec.prototype.tracks = $util.emptyArray;

                /**
                 * Creates a new SimulationSpec instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.SimulationSpec
                 * @static
                 * @param {havocai.messages.v0.ISimulationSpec=} [properties] Properties to set
                 * @returns {havocai.messages.v0.SimulationSpec} SimulationSpec instance
                 */
                SimulationSpec.create = function create(properties) {
                    return new SimulationSpec(properties);
                };

                /**
                 * Encodes the specified SimulationSpec message. Does not implicitly {@link havocai.messages.v0.SimulationSpec.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.SimulationSpec
                 * @static
                 * @param {havocai.messages.v0.ISimulationSpec} message SimulationSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SimulationSpec.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.multiplier != null && Object.hasOwnProperty.call(message, "multiplier"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.multiplier);
                    if (message.tracks != null && message.tracks.length)
                        for (let i = 0; i < message.tracks.length; ++i)
                            $root.havocai.messages.v0.TrackSimulation.encode(message.tracks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SimulationSpec message, length delimited. Does not implicitly {@link havocai.messages.v0.SimulationSpec.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.SimulationSpec
                 * @static
                 * @param {havocai.messages.v0.ISimulationSpec} message SimulationSpec message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SimulationSpec.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SimulationSpec message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.SimulationSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.SimulationSpec} SimulationSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SimulationSpec.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.SimulationSpec();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.multiplier = reader.uint32();
                                break;
                            }
                        case 2: {
                                if (!(message.tracks && message.tracks.length))
                                    message.tracks = [];
                                message.tracks.push($root.havocai.messages.v0.TrackSimulation.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SimulationSpec message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.SimulationSpec
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.SimulationSpec} SimulationSpec
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SimulationSpec.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SimulationSpec message.
                 * @function verify
                 * @memberof havocai.messages.v0.SimulationSpec
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SimulationSpec.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.multiplier != null && message.hasOwnProperty("multiplier"))
                        if (!$util.isInteger(message.multiplier))
                            return "multiplier: integer expected";
                    if (message.tracks != null && message.hasOwnProperty("tracks")) {
                        if (!Array.isArray(message.tracks))
                            return "tracks: array expected";
                        for (let i = 0; i < message.tracks.length; ++i) {
                            let error = $root.havocai.messages.v0.TrackSimulation.verify(message.tracks[i]);
                            if (error)
                                return "tracks." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SimulationSpec message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.SimulationSpec
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.SimulationSpec} SimulationSpec
                 */
                SimulationSpec.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.SimulationSpec)
                        return object;
                    let message = new $root.havocai.messages.v0.SimulationSpec();
                    if (object.multiplier != null)
                        message.multiplier = object.multiplier >>> 0;
                    if (object.tracks) {
                        if (!Array.isArray(object.tracks))
                            throw TypeError(".havocai.messages.v0.SimulationSpec.tracks: array expected");
                        message.tracks = [];
                        for (let i = 0; i < object.tracks.length; ++i) {
                            if (typeof object.tracks[i] !== "object")
                                throw TypeError(".havocai.messages.v0.SimulationSpec.tracks: object expected");
                            message.tracks[i] = $root.havocai.messages.v0.TrackSimulation.fromObject(object.tracks[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SimulationSpec message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.SimulationSpec
                 * @static
                 * @param {havocai.messages.v0.SimulationSpec} message SimulationSpec
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SimulationSpec.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.tracks = [];
                    if (options.defaults)
                        object.multiplier = 0;
                    if (message.multiplier != null && message.hasOwnProperty("multiplier"))
                        object.multiplier = message.multiplier;
                    if (message.tracks && message.tracks.length) {
                        object.tracks = [];
                        for (let j = 0; j < message.tracks.length; ++j)
                            object.tracks[j] = $root.havocai.messages.v0.TrackSimulation.toObject(message.tracks[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SimulationSpec to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.SimulationSpec
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SimulationSpec.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SimulationSpec
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.SimulationSpec
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SimulationSpec.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.SimulationSpec";
                };

                return SimulationSpec;
            })();

            v0.TrackSimulation = (function() {

                /**
                 * Properties of a TrackSimulation.
                 * @memberof havocai.messages.v0
                 * @interface ITrackSimulation
                 * @property {havocai.messages.v0.TrackType|null} [type] TrackSimulation type
                 * @property {havocai.messages.v0.Affiliation|null} [affiliation] TrackSimulation affiliation
                 * @property {number|null} [speed] TrackSimulation speed
                 * @property {havocai.messages.v0.ISemiRandomRouting|null} [semiRandom] TrackSimulation semiRandom
                 * @property {havocai.messages.v0.IStraightLineRouting|null} [straightLine] TrackSimulation straightLine
                 */

                /**
                 * Constructs a new TrackSimulation.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a TrackSimulation.
                 * @implements ITrackSimulation
                 * @constructor
                 * @param {havocai.messages.v0.ITrackSimulation=} [properties] Properties to set
                 */
                function TrackSimulation(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TrackSimulation type.
                 * @member {havocai.messages.v0.TrackType} type
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @instance
                 */
                TrackSimulation.prototype.type = 0;

                /**
                 * TrackSimulation affiliation.
                 * @member {havocai.messages.v0.Affiliation} affiliation
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @instance
                 */
                TrackSimulation.prototype.affiliation = 0;

                /**
                 * TrackSimulation speed.
                 * @member {number} speed
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @instance
                 */
                TrackSimulation.prototype.speed = 0;

                /**
                 * TrackSimulation semiRandom.
                 * @member {havocai.messages.v0.ISemiRandomRouting|null|undefined} semiRandom
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @instance
                 */
                TrackSimulation.prototype.semiRandom = null;

                /**
                 * TrackSimulation straightLine.
                 * @member {havocai.messages.v0.IStraightLineRouting|null|undefined} straightLine
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @instance
                 */
                TrackSimulation.prototype.straightLine = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * TrackSimulation routingType.
                 * @member {"semiRandom"|"straightLine"|undefined} routingType
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @instance
                 */
                Object.defineProperty(TrackSimulation.prototype, "routingType", {
                    get: $util.oneOfGetter($oneOfFields = ["semiRandom", "straightLine"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new TrackSimulation instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @static
                 * @param {havocai.messages.v0.ITrackSimulation=} [properties] Properties to set
                 * @returns {havocai.messages.v0.TrackSimulation} TrackSimulation instance
                 */
                TrackSimulation.create = function create(properties) {
                    return new TrackSimulation(properties);
                };

                /**
                 * Encodes the specified TrackSimulation message. Does not implicitly {@link havocai.messages.v0.TrackSimulation.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @static
                 * @param {havocai.messages.v0.ITrackSimulation} message TrackSimulation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrackSimulation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.affiliation != null && Object.hasOwnProperty.call(message, "affiliation"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.affiliation);
                    if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.speed);
                    if (message.semiRandom != null && Object.hasOwnProperty.call(message, "semiRandom"))
                        $root.havocai.messages.v0.SemiRandomRouting.encode(message.semiRandom, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.straightLine != null && Object.hasOwnProperty.call(message, "straightLine"))
                        $root.havocai.messages.v0.StraightLineRouting.encode(message.straightLine, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TrackSimulation message, length delimited. Does not implicitly {@link havocai.messages.v0.TrackSimulation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @static
                 * @param {havocai.messages.v0.ITrackSimulation} message TrackSimulation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrackSimulation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TrackSimulation message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.TrackSimulation} TrackSimulation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrackSimulation.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.TrackSimulation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.type = reader.int32();
                                break;
                            }
                        case 2: {
                                message.affiliation = reader.int32();
                                break;
                            }
                        case 3: {
                                message.speed = reader.double();
                                break;
                            }
                        case 4: {
                                message.semiRandom = $root.havocai.messages.v0.SemiRandomRouting.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.straightLine = $root.havocai.messages.v0.StraightLineRouting.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TrackSimulation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.TrackSimulation} TrackSimulation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrackSimulation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TrackSimulation message.
                 * @function verify
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TrackSimulation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 98:
                        case 99:
                            break;
                        }
                    if (message.affiliation != null && message.hasOwnProperty("affiliation"))
                        switch (message.affiliation) {
                        default:
                            return "affiliation: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.speed != null && message.hasOwnProperty("speed"))
                        if (typeof message.speed !== "number")
                            return "speed: number expected";
                    if (message.semiRandom != null && message.hasOwnProperty("semiRandom")) {
                        properties.routingType = 1;
                        {
                            let error = $root.havocai.messages.v0.SemiRandomRouting.verify(message.semiRandom);
                            if (error)
                                return "semiRandom." + error;
                        }
                    }
                    if (message.straightLine != null && message.hasOwnProperty("straightLine")) {
                        if (properties.routingType === 1)
                            return "routingType: multiple values";
                        properties.routingType = 1;
                        {
                            let error = $root.havocai.messages.v0.StraightLineRouting.verify(message.straightLine);
                            if (error)
                                return "straightLine." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TrackSimulation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.TrackSimulation} TrackSimulation
                 */
                TrackSimulation.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.TrackSimulation)
                        return object;
                    let message = new $root.havocai.messages.v0.TrackSimulation();
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "TRACK_TYPE_UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "TRACK_TYPE_AIS":
                    case 1:
                        message.type = 1;
                        break;
                    case "TRACK_TYPE_RADAR":
                    case 2:
                        message.type = 2;
                        break;
                    case "TRACK_TYPE_EO":
                    case 3:
                        message.type = 3;
                        break;
                    case "TRACK_TYPE_FUSED":
                    case 4:
                        message.type = 4;
                        break;
                    case "TRACK_TYPE_USER_CREATED":
                    case 5:
                        message.type = 5;
                        break;
                    case "TRACK_TYPE_EXTERNAL_SYSTEM":
                    case 6:
                        message.type = 6;
                        break;
                    case "TRACK_TYPE_RF":
                    case 7:
                        message.type = 7;
                        break;
                    case "TRACK_TYPE_PERSON":
                    case 8:
                        message.type = 8;
                        break;
                    case "TRACK_TYPE_MISSILE":
                    case 9:
                        message.type = 9;
                        break;
                    case "TRACK_TYPE_TORPEDO":
                    case 10:
                        message.type = 10;
                        break;
                    case "TRACK_TYPE_RUBBER_DUCKIE":
                    case 98:
                        message.type = 98;
                        break;
                    case "TRACK_TYPE_NERF_DART":
                    case 99:
                        message.type = 99;
                        break;
                    }
                    switch (object.affiliation) {
                    default:
                        if (typeof object.affiliation === "number") {
                            message.affiliation = object.affiliation;
                            break;
                        }
                        break;
                    case "AFFILIATION_UNKNOWN":
                    case 0:
                        message.affiliation = 0;
                        break;
                    case "AFFILIATION_ASSUMED_FRIENDLY":
                    case 1:
                        message.affiliation = 1;
                        break;
                    case "AFFILIATION_FRIENDLY":
                    case 2:
                        message.affiliation = 2;
                        break;
                    case "AFFILIATION_NEUTRAL":
                    case 3:
                        message.affiliation = 3;
                        break;
                    case "AFFILIATION_SUSPECT":
                    case 4:
                        message.affiliation = 4;
                        break;
                    case "AFFILIATION_HOSTILE":
                    case 5:
                        message.affiliation = 5;
                        break;
                    }
                    if (object.speed != null)
                        message.speed = Number(object.speed);
                    if (object.semiRandom != null) {
                        if (typeof object.semiRandom !== "object")
                            throw TypeError(".havocai.messages.v0.TrackSimulation.semiRandom: object expected");
                        message.semiRandom = $root.havocai.messages.v0.SemiRandomRouting.fromObject(object.semiRandom);
                    }
                    if (object.straightLine != null) {
                        if (typeof object.straightLine !== "object")
                            throw TypeError(".havocai.messages.v0.TrackSimulation.straightLine: object expected");
                        message.straightLine = $root.havocai.messages.v0.StraightLineRouting.fromObject(object.straightLine);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TrackSimulation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @static
                 * @param {havocai.messages.v0.TrackSimulation} message TrackSimulation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TrackSimulation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "TRACK_TYPE_UNKNOWN" : 0;
                        object.affiliation = options.enums === String ? "AFFILIATION_UNKNOWN" : 0;
                        object.speed = 0;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.havocai.messages.v0.TrackType[message.type] === undefined ? message.type : $root.havocai.messages.v0.TrackType[message.type] : message.type;
                    if (message.affiliation != null && message.hasOwnProperty("affiliation"))
                        object.affiliation = options.enums === String ? $root.havocai.messages.v0.Affiliation[message.affiliation] === undefined ? message.affiliation : $root.havocai.messages.v0.Affiliation[message.affiliation] : message.affiliation;
                    if (message.speed != null && message.hasOwnProperty("speed"))
                        object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
                    if (message.semiRandom != null && message.hasOwnProperty("semiRandom")) {
                        object.semiRandom = $root.havocai.messages.v0.SemiRandomRouting.toObject(message.semiRandom, options);
                        if (options.oneofs)
                            object.routingType = "semiRandom";
                    }
                    if (message.straightLine != null && message.hasOwnProperty("straightLine")) {
                        object.straightLine = $root.havocai.messages.v0.StraightLineRouting.toObject(message.straightLine, options);
                        if (options.oneofs)
                            object.routingType = "straightLine";
                    }
                    return object;
                };

                /**
                 * Converts this TrackSimulation to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TrackSimulation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TrackSimulation
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.TrackSimulation
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TrackSimulation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.TrackSimulation";
                };

                return TrackSimulation;
            })();

            v0.SemiRandomRouting = (function() {

                /**
                 * Properties of a SemiRandomRouting.
                 * @memberof havocai.messages.v0
                 * @interface ISemiRandomRouting
                 * @property {string|null} [trackNamePrefix] SemiRandomRouting trackNamePrefix
                 * @property {number|null} [count] SemiRandomRouting count
                 * @property {Array.<havocai.messages.v0.IGeoPoint>|null} [area] SemiRandomRouting area
                 * @property {number|null} [maxHeadingVariation] SemiRandomRouting maxHeadingVariation
                 * @property {number|null} [headingUpdateInterval] SemiRandomRouting headingUpdateInterval
                 */

                /**
                 * Constructs a new SemiRandomRouting.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a SemiRandomRouting.
                 * @implements ISemiRandomRouting
                 * @constructor
                 * @param {havocai.messages.v0.ISemiRandomRouting=} [properties] Properties to set
                 */
                function SemiRandomRouting(properties) {
                    this.area = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SemiRandomRouting trackNamePrefix.
                 * @member {string} trackNamePrefix
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @instance
                 */
                SemiRandomRouting.prototype.trackNamePrefix = "";

                /**
                 * SemiRandomRouting count.
                 * @member {number} count
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @instance
                 */
                SemiRandomRouting.prototype.count = 0;

                /**
                 * SemiRandomRouting area.
                 * @member {Array.<havocai.messages.v0.IGeoPoint>} area
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @instance
                 */
                SemiRandomRouting.prototype.area = $util.emptyArray;

                /**
                 * SemiRandomRouting maxHeadingVariation.
                 * @member {number} maxHeadingVariation
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @instance
                 */
                SemiRandomRouting.prototype.maxHeadingVariation = 0;

                /**
                 * SemiRandomRouting headingUpdateInterval.
                 * @member {number} headingUpdateInterval
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @instance
                 */
                SemiRandomRouting.prototype.headingUpdateInterval = 0;

                /**
                 * Creates a new SemiRandomRouting instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @static
                 * @param {havocai.messages.v0.ISemiRandomRouting=} [properties] Properties to set
                 * @returns {havocai.messages.v0.SemiRandomRouting} SemiRandomRouting instance
                 */
                SemiRandomRouting.create = function create(properties) {
                    return new SemiRandomRouting(properties);
                };

                /**
                 * Encodes the specified SemiRandomRouting message. Does not implicitly {@link havocai.messages.v0.SemiRandomRouting.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @static
                 * @param {havocai.messages.v0.ISemiRandomRouting} message SemiRandomRouting message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SemiRandomRouting.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.trackNamePrefix != null && Object.hasOwnProperty.call(message, "trackNamePrefix"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackNamePrefix);
                    if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.count);
                    if (message.area != null && message.area.length)
                        for (let i = 0; i < message.area.length; ++i)
                            $root.havocai.messages.v0.GeoPoint.encode(message.area[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.maxHeadingVariation != null && Object.hasOwnProperty.call(message, "maxHeadingVariation"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.maxHeadingVariation);
                    if (message.headingUpdateInterval != null && Object.hasOwnProperty.call(message, "headingUpdateInterval"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.headingUpdateInterval);
                    return writer;
                };

                /**
                 * Encodes the specified SemiRandomRouting message, length delimited. Does not implicitly {@link havocai.messages.v0.SemiRandomRouting.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @static
                 * @param {havocai.messages.v0.ISemiRandomRouting} message SemiRandomRouting message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SemiRandomRouting.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SemiRandomRouting message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.SemiRandomRouting} SemiRandomRouting
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SemiRandomRouting.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.SemiRandomRouting();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.trackNamePrefix = reader.string();
                                break;
                            }
                        case 2: {
                                message.count = reader.uint32();
                                break;
                            }
                        case 3: {
                                if (!(message.area && message.area.length))
                                    message.area = [];
                                message.area.push($root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32()));
                                break;
                            }
                        case 4: {
                                message.maxHeadingVariation = reader.double();
                                break;
                            }
                        case 5: {
                                message.headingUpdateInterval = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SemiRandomRouting message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.SemiRandomRouting} SemiRandomRouting
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SemiRandomRouting.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SemiRandomRouting message.
                 * @function verify
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SemiRandomRouting.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.trackNamePrefix != null && message.hasOwnProperty("trackNamePrefix"))
                        if (!$util.isString(message.trackNamePrefix))
                            return "trackNamePrefix: string expected";
                    if (message.count != null && message.hasOwnProperty("count"))
                        if (!$util.isInteger(message.count))
                            return "count: integer expected";
                    if (message.area != null && message.hasOwnProperty("area")) {
                        if (!Array.isArray(message.area))
                            return "area: array expected";
                        for (let i = 0; i < message.area.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoPoint.verify(message.area[i]);
                            if (error)
                                return "area." + error;
                        }
                    }
                    if (message.maxHeadingVariation != null && message.hasOwnProperty("maxHeadingVariation"))
                        if (typeof message.maxHeadingVariation !== "number")
                            return "maxHeadingVariation: number expected";
                    if (message.headingUpdateInterval != null && message.hasOwnProperty("headingUpdateInterval"))
                        if (typeof message.headingUpdateInterval !== "number")
                            return "headingUpdateInterval: number expected";
                    return null;
                };

                /**
                 * Creates a SemiRandomRouting message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.SemiRandomRouting} SemiRandomRouting
                 */
                SemiRandomRouting.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.SemiRandomRouting)
                        return object;
                    let message = new $root.havocai.messages.v0.SemiRandomRouting();
                    if (object.trackNamePrefix != null)
                        message.trackNamePrefix = String(object.trackNamePrefix);
                    if (object.count != null)
                        message.count = object.count >>> 0;
                    if (object.area) {
                        if (!Array.isArray(object.area))
                            throw TypeError(".havocai.messages.v0.SemiRandomRouting.area: array expected");
                        message.area = [];
                        for (let i = 0; i < object.area.length; ++i) {
                            if (typeof object.area[i] !== "object")
                                throw TypeError(".havocai.messages.v0.SemiRandomRouting.area: object expected");
                            message.area[i] = $root.havocai.messages.v0.GeoPoint.fromObject(object.area[i]);
                        }
                    }
                    if (object.maxHeadingVariation != null)
                        message.maxHeadingVariation = Number(object.maxHeadingVariation);
                    if (object.headingUpdateInterval != null)
                        message.headingUpdateInterval = Number(object.headingUpdateInterval);
                    return message;
                };

                /**
                 * Creates a plain object from a SemiRandomRouting message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @static
                 * @param {havocai.messages.v0.SemiRandomRouting} message SemiRandomRouting
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SemiRandomRouting.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.area = [];
                    if (options.defaults) {
                        object.trackNamePrefix = "";
                        object.count = 0;
                        object.maxHeadingVariation = 0;
                        object.headingUpdateInterval = 0;
                    }
                    if (message.trackNamePrefix != null && message.hasOwnProperty("trackNamePrefix"))
                        object.trackNamePrefix = message.trackNamePrefix;
                    if (message.count != null && message.hasOwnProperty("count"))
                        object.count = message.count;
                    if (message.area && message.area.length) {
                        object.area = [];
                        for (let j = 0; j < message.area.length; ++j)
                            object.area[j] = $root.havocai.messages.v0.GeoPoint.toObject(message.area[j], options);
                    }
                    if (message.maxHeadingVariation != null && message.hasOwnProperty("maxHeadingVariation"))
                        object.maxHeadingVariation = options.json && !isFinite(message.maxHeadingVariation) ? String(message.maxHeadingVariation) : message.maxHeadingVariation;
                    if (message.headingUpdateInterval != null && message.hasOwnProperty("headingUpdateInterval"))
                        object.headingUpdateInterval = options.json && !isFinite(message.headingUpdateInterval) ? String(message.headingUpdateInterval) : message.headingUpdateInterval;
                    return object;
                };

                /**
                 * Converts this SemiRandomRouting to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SemiRandomRouting.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SemiRandomRouting
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.SemiRandomRouting
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SemiRandomRouting.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.SemiRandomRouting";
                };

                return SemiRandomRouting;
            })();

            v0.StraightLineRouting = (function() {

                /**
                 * Properties of a StraightLineRouting.
                 * @memberof havocai.messages.v0
                 * @interface IStraightLineRouting
                 * @property {string|null} [trackId] StraightLineRouting trackId
                 * @property {string|null} [trackName] StraightLineRouting trackName
                 * @property {havocai.messages.v0.IStartEndPoint|null} [startEnd] StraightLineRouting startEnd
                 * @property {havocai.messages.v0.IStartPointEndArea|null} [startArea] StraightLineRouting startArea
                 * @property {havocai.messages.v0.IStartPointHeading|null} [startHeading] StraightLineRouting startHeading
                 */

                /**
                 * Constructs a new StraightLineRouting.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a StraightLineRouting.
                 * @implements IStraightLineRouting
                 * @constructor
                 * @param {havocai.messages.v0.IStraightLineRouting=} [properties] Properties to set
                 */
                function StraightLineRouting(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StraightLineRouting trackId.
                 * @member {string} trackId
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @instance
                 */
                StraightLineRouting.prototype.trackId = "";

                /**
                 * StraightLineRouting trackName.
                 * @member {string} trackName
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @instance
                 */
                StraightLineRouting.prototype.trackName = "";

                /**
                 * StraightLineRouting startEnd.
                 * @member {havocai.messages.v0.IStartEndPoint|null|undefined} startEnd
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @instance
                 */
                StraightLineRouting.prototype.startEnd = null;

                /**
                 * StraightLineRouting startArea.
                 * @member {havocai.messages.v0.IStartPointEndArea|null|undefined} startArea
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @instance
                 */
                StraightLineRouting.prototype.startArea = null;

                /**
                 * StraightLineRouting startHeading.
                 * @member {havocai.messages.v0.IStartPointHeading|null|undefined} startHeading
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @instance
                 */
                StraightLineRouting.prototype.startHeading = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * StraightLineRouting movement.
                 * @member {"startEnd"|"startArea"|"startHeading"|undefined} movement
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @instance
                 */
                Object.defineProperty(StraightLineRouting.prototype, "movement", {
                    get: $util.oneOfGetter($oneOfFields = ["startEnd", "startArea", "startHeading"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new StraightLineRouting instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @static
                 * @param {havocai.messages.v0.IStraightLineRouting=} [properties] Properties to set
                 * @returns {havocai.messages.v0.StraightLineRouting} StraightLineRouting instance
                 */
                StraightLineRouting.create = function create(properties) {
                    return new StraightLineRouting(properties);
                };

                /**
                 * Encodes the specified StraightLineRouting message. Does not implicitly {@link havocai.messages.v0.StraightLineRouting.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @static
                 * @param {havocai.messages.v0.IStraightLineRouting} message StraightLineRouting message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StraightLineRouting.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.trackId != null && Object.hasOwnProperty.call(message, "trackId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.trackId);
                    if (message.trackName != null && Object.hasOwnProperty.call(message, "trackName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.trackName);
                    if (message.startEnd != null && Object.hasOwnProperty.call(message, "startEnd"))
                        $root.havocai.messages.v0.StartEndPoint.encode(message.startEnd, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.startArea != null && Object.hasOwnProperty.call(message, "startArea"))
                        $root.havocai.messages.v0.StartPointEndArea.encode(message.startArea, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.startHeading != null && Object.hasOwnProperty.call(message, "startHeading"))
                        $root.havocai.messages.v0.StartPointHeading.encode(message.startHeading, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified StraightLineRouting message, length delimited. Does not implicitly {@link havocai.messages.v0.StraightLineRouting.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @static
                 * @param {havocai.messages.v0.IStraightLineRouting} message StraightLineRouting message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StraightLineRouting.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StraightLineRouting message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.StraightLineRouting} StraightLineRouting
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StraightLineRouting.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.StraightLineRouting();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.trackId = reader.string();
                                break;
                            }
                        case 2: {
                                message.trackName = reader.string();
                                break;
                            }
                        case 3: {
                                message.startEnd = $root.havocai.messages.v0.StartEndPoint.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.startArea = $root.havocai.messages.v0.StartPointEndArea.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.startHeading = $root.havocai.messages.v0.StartPointHeading.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StraightLineRouting message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.StraightLineRouting} StraightLineRouting
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StraightLineRouting.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StraightLineRouting message.
                 * @function verify
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StraightLineRouting.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.trackId != null && message.hasOwnProperty("trackId"))
                        if (!$util.isString(message.trackId))
                            return "trackId: string expected";
                    if (message.trackName != null && message.hasOwnProperty("trackName"))
                        if (!$util.isString(message.trackName))
                            return "trackName: string expected";
                    if (message.startEnd != null && message.hasOwnProperty("startEnd")) {
                        properties.movement = 1;
                        {
                            let error = $root.havocai.messages.v0.StartEndPoint.verify(message.startEnd);
                            if (error)
                                return "startEnd." + error;
                        }
                    }
                    if (message.startArea != null && message.hasOwnProperty("startArea")) {
                        if (properties.movement === 1)
                            return "movement: multiple values";
                        properties.movement = 1;
                        {
                            let error = $root.havocai.messages.v0.StartPointEndArea.verify(message.startArea);
                            if (error)
                                return "startArea." + error;
                        }
                    }
                    if (message.startHeading != null && message.hasOwnProperty("startHeading")) {
                        if (properties.movement === 1)
                            return "movement: multiple values";
                        properties.movement = 1;
                        {
                            let error = $root.havocai.messages.v0.StartPointHeading.verify(message.startHeading);
                            if (error)
                                return "startHeading." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a StraightLineRouting message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.StraightLineRouting} StraightLineRouting
                 */
                StraightLineRouting.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.StraightLineRouting)
                        return object;
                    let message = new $root.havocai.messages.v0.StraightLineRouting();
                    if (object.trackId != null)
                        message.trackId = String(object.trackId);
                    if (object.trackName != null)
                        message.trackName = String(object.trackName);
                    if (object.startEnd != null) {
                        if (typeof object.startEnd !== "object")
                            throw TypeError(".havocai.messages.v0.StraightLineRouting.startEnd: object expected");
                        message.startEnd = $root.havocai.messages.v0.StartEndPoint.fromObject(object.startEnd);
                    }
                    if (object.startArea != null) {
                        if (typeof object.startArea !== "object")
                            throw TypeError(".havocai.messages.v0.StraightLineRouting.startArea: object expected");
                        message.startArea = $root.havocai.messages.v0.StartPointEndArea.fromObject(object.startArea);
                    }
                    if (object.startHeading != null) {
                        if (typeof object.startHeading !== "object")
                            throw TypeError(".havocai.messages.v0.StraightLineRouting.startHeading: object expected");
                        message.startHeading = $root.havocai.messages.v0.StartPointHeading.fromObject(object.startHeading);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a StraightLineRouting message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @static
                 * @param {havocai.messages.v0.StraightLineRouting} message StraightLineRouting
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StraightLineRouting.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.trackId = "";
                        object.trackName = "";
                    }
                    if (message.trackId != null && message.hasOwnProperty("trackId"))
                        object.trackId = message.trackId;
                    if (message.trackName != null && message.hasOwnProperty("trackName"))
                        object.trackName = message.trackName;
                    if (message.startEnd != null && message.hasOwnProperty("startEnd")) {
                        object.startEnd = $root.havocai.messages.v0.StartEndPoint.toObject(message.startEnd, options);
                        if (options.oneofs)
                            object.movement = "startEnd";
                    }
                    if (message.startArea != null && message.hasOwnProperty("startArea")) {
                        object.startArea = $root.havocai.messages.v0.StartPointEndArea.toObject(message.startArea, options);
                        if (options.oneofs)
                            object.movement = "startArea";
                    }
                    if (message.startHeading != null && message.hasOwnProperty("startHeading")) {
                        object.startHeading = $root.havocai.messages.v0.StartPointHeading.toObject(message.startHeading, options);
                        if (options.oneofs)
                            object.movement = "startHeading";
                    }
                    return object;
                };

                /**
                 * Converts this StraightLineRouting to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StraightLineRouting.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for StraightLineRouting
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.StraightLineRouting
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                StraightLineRouting.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.StraightLineRouting";
                };

                return StraightLineRouting;
            })();

            v0.StartEndPoint = (function() {

                /**
                 * Properties of a StartEndPoint.
                 * @memberof havocai.messages.v0
                 * @interface IStartEndPoint
                 * @property {havocai.messages.v0.IGeoPoint|null} [startPoint] StartEndPoint startPoint
                 * @property {havocai.messages.v0.IGeoPoint|null} [endPoint] StartEndPoint endPoint
                 */

                /**
                 * Constructs a new StartEndPoint.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a StartEndPoint.
                 * @implements IStartEndPoint
                 * @constructor
                 * @param {havocai.messages.v0.IStartEndPoint=} [properties] Properties to set
                 */
                function StartEndPoint(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StartEndPoint startPoint.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} startPoint
                 * @memberof havocai.messages.v0.StartEndPoint
                 * @instance
                 */
                StartEndPoint.prototype.startPoint = null;

                /**
                 * StartEndPoint endPoint.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} endPoint
                 * @memberof havocai.messages.v0.StartEndPoint
                 * @instance
                 */
                StartEndPoint.prototype.endPoint = null;

                /**
                 * Creates a new StartEndPoint instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.StartEndPoint
                 * @static
                 * @param {havocai.messages.v0.IStartEndPoint=} [properties] Properties to set
                 * @returns {havocai.messages.v0.StartEndPoint} StartEndPoint instance
                 */
                StartEndPoint.create = function create(properties) {
                    return new StartEndPoint(properties);
                };

                /**
                 * Encodes the specified StartEndPoint message. Does not implicitly {@link havocai.messages.v0.StartEndPoint.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.StartEndPoint
                 * @static
                 * @param {havocai.messages.v0.IStartEndPoint} message StartEndPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StartEndPoint.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.startPoint != null && Object.hasOwnProperty.call(message, "startPoint"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.startPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.endPoint != null && Object.hasOwnProperty.call(message, "endPoint"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.endPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified StartEndPoint message, length delimited. Does not implicitly {@link havocai.messages.v0.StartEndPoint.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.StartEndPoint
                 * @static
                 * @param {havocai.messages.v0.IStartEndPoint} message StartEndPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StartEndPoint.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StartEndPoint message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.StartEndPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.StartEndPoint} StartEndPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StartEndPoint.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.StartEndPoint();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.startPoint = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.endPoint = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StartEndPoint message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.StartEndPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.StartEndPoint} StartEndPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StartEndPoint.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StartEndPoint message.
                 * @function verify
                 * @memberof havocai.messages.v0.StartEndPoint
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StartEndPoint.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.startPoint != null && message.hasOwnProperty("startPoint")) {
                        let error = $root.havocai.messages.v0.GeoPoint.verify(message.startPoint);
                        if (error)
                            return "startPoint." + error;
                    }
                    if (message.endPoint != null && message.hasOwnProperty("endPoint")) {
                        let error = $root.havocai.messages.v0.GeoPoint.verify(message.endPoint);
                        if (error)
                            return "endPoint." + error;
                    }
                    return null;
                };

                /**
                 * Creates a StartEndPoint message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.StartEndPoint
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.StartEndPoint} StartEndPoint
                 */
                StartEndPoint.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.StartEndPoint)
                        return object;
                    let message = new $root.havocai.messages.v0.StartEndPoint();
                    if (object.startPoint != null) {
                        if (typeof object.startPoint !== "object")
                            throw TypeError(".havocai.messages.v0.StartEndPoint.startPoint: object expected");
                        message.startPoint = $root.havocai.messages.v0.GeoPoint.fromObject(object.startPoint);
                    }
                    if (object.endPoint != null) {
                        if (typeof object.endPoint !== "object")
                            throw TypeError(".havocai.messages.v0.StartEndPoint.endPoint: object expected");
                        message.endPoint = $root.havocai.messages.v0.GeoPoint.fromObject(object.endPoint);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a StartEndPoint message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.StartEndPoint
                 * @static
                 * @param {havocai.messages.v0.StartEndPoint} message StartEndPoint
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StartEndPoint.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.startPoint = null;
                        object.endPoint = null;
                    }
                    if (message.startPoint != null && message.hasOwnProperty("startPoint"))
                        object.startPoint = $root.havocai.messages.v0.GeoPoint.toObject(message.startPoint, options);
                    if (message.endPoint != null && message.hasOwnProperty("endPoint"))
                        object.endPoint = $root.havocai.messages.v0.GeoPoint.toObject(message.endPoint, options);
                    return object;
                };

                /**
                 * Converts this StartEndPoint to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.StartEndPoint
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StartEndPoint.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for StartEndPoint
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.StartEndPoint
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                StartEndPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.StartEndPoint";
                };

                return StartEndPoint;
            })();

            v0.StartPointEndArea = (function() {

                /**
                 * Properties of a StartPointEndArea.
                 * @memberof havocai.messages.v0
                 * @interface IStartPointEndArea
                 * @property {havocai.messages.v0.IGeoPoint|null} [startPoint] StartPointEndArea startPoint
                 * @property {Array.<havocai.messages.v0.IGeoPoint>|null} [area] StartPointEndArea area
                 */

                /**
                 * Constructs a new StartPointEndArea.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a StartPointEndArea.
                 * @implements IStartPointEndArea
                 * @constructor
                 * @param {havocai.messages.v0.IStartPointEndArea=} [properties] Properties to set
                 */
                function StartPointEndArea(properties) {
                    this.area = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StartPointEndArea startPoint.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} startPoint
                 * @memberof havocai.messages.v0.StartPointEndArea
                 * @instance
                 */
                StartPointEndArea.prototype.startPoint = null;

                /**
                 * StartPointEndArea area.
                 * @member {Array.<havocai.messages.v0.IGeoPoint>} area
                 * @memberof havocai.messages.v0.StartPointEndArea
                 * @instance
                 */
                StartPointEndArea.prototype.area = $util.emptyArray;

                /**
                 * Creates a new StartPointEndArea instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.StartPointEndArea
                 * @static
                 * @param {havocai.messages.v0.IStartPointEndArea=} [properties] Properties to set
                 * @returns {havocai.messages.v0.StartPointEndArea} StartPointEndArea instance
                 */
                StartPointEndArea.create = function create(properties) {
                    return new StartPointEndArea(properties);
                };

                /**
                 * Encodes the specified StartPointEndArea message. Does not implicitly {@link havocai.messages.v0.StartPointEndArea.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.StartPointEndArea
                 * @static
                 * @param {havocai.messages.v0.IStartPointEndArea} message StartPointEndArea message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StartPointEndArea.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.startPoint != null && Object.hasOwnProperty.call(message, "startPoint"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.startPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.area != null && message.area.length)
                        for (let i = 0; i < message.area.length; ++i)
                            $root.havocai.messages.v0.GeoPoint.encode(message.area[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified StartPointEndArea message, length delimited. Does not implicitly {@link havocai.messages.v0.StartPointEndArea.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.StartPointEndArea
                 * @static
                 * @param {havocai.messages.v0.IStartPointEndArea} message StartPointEndArea message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StartPointEndArea.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StartPointEndArea message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.StartPointEndArea
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.StartPointEndArea} StartPointEndArea
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StartPointEndArea.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.StartPointEndArea();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.startPoint = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                if (!(message.area && message.area.length))
                                    message.area = [];
                                message.area.push($root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StartPointEndArea message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.StartPointEndArea
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.StartPointEndArea} StartPointEndArea
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StartPointEndArea.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StartPointEndArea message.
                 * @function verify
                 * @memberof havocai.messages.v0.StartPointEndArea
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StartPointEndArea.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.startPoint != null && message.hasOwnProperty("startPoint")) {
                        let error = $root.havocai.messages.v0.GeoPoint.verify(message.startPoint);
                        if (error)
                            return "startPoint." + error;
                    }
                    if (message.area != null && message.hasOwnProperty("area")) {
                        if (!Array.isArray(message.area))
                            return "area: array expected";
                        for (let i = 0; i < message.area.length; ++i) {
                            let error = $root.havocai.messages.v0.GeoPoint.verify(message.area[i]);
                            if (error)
                                return "area." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a StartPointEndArea message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.StartPointEndArea
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.StartPointEndArea} StartPointEndArea
                 */
                StartPointEndArea.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.StartPointEndArea)
                        return object;
                    let message = new $root.havocai.messages.v0.StartPointEndArea();
                    if (object.startPoint != null) {
                        if (typeof object.startPoint !== "object")
                            throw TypeError(".havocai.messages.v0.StartPointEndArea.startPoint: object expected");
                        message.startPoint = $root.havocai.messages.v0.GeoPoint.fromObject(object.startPoint);
                    }
                    if (object.area) {
                        if (!Array.isArray(object.area))
                            throw TypeError(".havocai.messages.v0.StartPointEndArea.area: array expected");
                        message.area = [];
                        for (let i = 0; i < object.area.length; ++i) {
                            if (typeof object.area[i] !== "object")
                                throw TypeError(".havocai.messages.v0.StartPointEndArea.area: object expected");
                            message.area[i] = $root.havocai.messages.v0.GeoPoint.fromObject(object.area[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a StartPointEndArea message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.StartPointEndArea
                 * @static
                 * @param {havocai.messages.v0.StartPointEndArea} message StartPointEndArea
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StartPointEndArea.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.area = [];
                    if (options.defaults)
                        object.startPoint = null;
                    if (message.startPoint != null && message.hasOwnProperty("startPoint"))
                        object.startPoint = $root.havocai.messages.v0.GeoPoint.toObject(message.startPoint, options);
                    if (message.area && message.area.length) {
                        object.area = [];
                        for (let j = 0; j < message.area.length; ++j)
                            object.area[j] = $root.havocai.messages.v0.GeoPoint.toObject(message.area[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this StartPointEndArea to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.StartPointEndArea
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StartPointEndArea.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for StartPointEndArea
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.StartPointEndArea
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                StartPointEndArea.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.StartPointEndArea";
                };

                return StartPointEndArea;
            })();

            v0.StartPointHeading = (function() {

                /**
                 * Properties of a StartPointHeading.
                 * @memberof havocai.messages.v0
                 * @interface IStartPointHeading
                 * @property {havocai.messages.v0.IGeoPoint|null} [startPoint] StartPointHeading startPoint
                 * @property {number|null} [heading] StartPointHeading heading
                 * @property {number|null} [distance] StartPointHeading distance
                 */

                /**
                 * Constructs a new StartPointHeading.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a StartPointHeading.
                 * @implements IStartPointHeading
                 * @constructor
                 * @param {havocai.messages.v0.IStartPointHeading=} [properties] Properties to set
                 */
                function StartPointHeading(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StartPointHeading startPoint.
                 * @member {havocai.messages.v0.IGeoPoint|null|undefined} startPoint
                 * @memberof havocai.messages.v0.StartPointHeading
                 * @instance
                 */
                StartPointHeading.prototype.startPoint = null;

                /**
                 * StartPointHeading heading.
                 * @member {number} heading
                 * @memberof havocai.messages.v0.StartPointHeading
                 * @instance
                 */
                StartPointHeading.prototype.heading = 0;

                /**
                 * StartPointHeading distance.
                 * @member {number} distance
                 * @memberof havocai.messages.v0.StartPointHeading
                 * @instance
                 */
                StartPointHeading.prototype.distance = 0;

                /**
                 * Creates a new StartPointHeading instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.StartPointHeading
                 * @static
                 * @param {havocai.messages.v0.IStartPointHeading=} [properties] Properties to set
                 * @returns {havocai.messages.v0.StartPointHeading} StartPointHeading instance
                 */
                StartPointHeading.create = function create(properties) {
                    return new StartPointHeading(properties);
                };

                /**
                 * Encodes the specified StartPointHeading message. Does not implicitly {@link havocai.messages.v0.StartPointHeading.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.StartPointHeading
                 * @static
                 * @param {havocai.messages.v0.IStartPointHeading} message StartPointHeading message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StartPointHeading.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.startPoint != null && Object.hasOwnProperty.call(message, "startPoint"))
                        $root.havocai.messages.v0.GeoPoint.encode(message.startPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.heading != null && Object.hasOwnProperty.call(message, "heading"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.heading);
                    if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.distance);
                    return writer;
                };

                /**
                 * Encodes the specified StartPointHeading message, length delimited. Does not implicitly {@link havocai.messages.v0.StartPointHeading.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.StartPointHeading
                 * @static
                 * @param {havocai.messages.v0.IStartPointHeading} message StartPointHeading message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StartPointHeading.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StartPointHeading message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.StartPointHeading
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.StartPointHeading} StartPointHeading
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StartPointHeading.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.StartPointHeading();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.startPoint = $root.havocai.messages.v0.GeoPoint.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.heading = reader.double();
                                break;
                            }
                        case 3: {
                                message.distance = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StartPointHeading message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.StartPointHeading
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.StartPointHeading} StartPointHeading
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StartPointHeading.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StartPointHeading message.
                 * @function verify
                 * @memberof havocai.messages.v0.StartPointHeading
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StartPointHeading.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.startPoint != null && message.hasOwnProperty("startPoint")) {
                        let error = $root.havocai.messages.v0.GeoPoint.verify(message.startPoint);
                        if (error)
                            return "startPoint." + error;
                    }
                    if (message.heading != null && message.hasOwnProperty("heading"))
                        if (typeof message.heading !== "number")
                            return "heading: number expected";
                    if (message.distance != null && message.hasOwnProperty("distance"))
                        if (typeof message.distance !== "number")
                            return "distance: number expected";
                    return null;
                };

                /**
                 * Creates a StartPointHeading message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.StartPointHeading
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.StartPointHeading} StartPointHeading
                 */
                StartPointHeading.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.StartPointHeading)
                        return object;
                    let message = new $root.havocai.messages.v0.StartPointHeading();
                    if (object.startPoint != null) {
                        if (typeof object.startPoint !== "object")
                            throw TypeError(".havocai.messages.v0.StartPointHeading.startPoint: object expected");
                        message.startPoint = $root.havocai.messages.v0.GeoPoint.fromObject(object.startPoint);
                    }
                    if (object.heading != null)
                        message.heading = Number(object.heading);
                    if (object.distance != null)
                        message.distance = Number(object.distance);
                    return message;
                };

                /**
                 * Creates a plain object from a StartPointHeading message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.StartPointHeading
                 * @static
                 * @param {havocai.messages.v0.StartPointHeading} message StartPointHeading
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StartPointHeading.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.startPoint = null;
                        object.heading = 0;
                        object.distance = 0;
                    }
                    if (message.startPoint != null && message.hasOwnProperty("startPoint"))
                        object.startPoint = $root.havocai.messages.v0.GeoPoint.toObject(message.startPoint, options);
                    if (message.heading != null && message.hasOwnProperty("heading"))
                        object.heading = options.json && !isFinite(message.heading) ? String(message.heading) : message.heading;
                    if (message.distance != null && message.hasOwnProperty("distance"))
                        object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
                    return object;
                };

                /**
                 * Converts this StartPointHeading to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.StartPointHeading
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StartPointHeading.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for StartPointHeading
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.StartPointHeading
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                StartPointHeading.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.StartPointHeading";
                };

                return StartPointHeading;
            })();

            v0.SimulationList = (function() {

                /**
                 * Properties of a SimulationList.
                 * @memberof havocai.messages.v0
                 * @interface ISimulationList
                 * @property {Array.<havocai.messages.v0.ISimulation>|null} [values] SimulationList values
                 */

                /**
                 * Constructs a new SimulationList.
                 * @memberof havocai.messages.v0
                 * @classdesc Represents a SimulationList.
                 * @implements ISimulationList
                 * @constructor
                 * @param {havocai.messages.v0.ISimulationList=} [properties] Properties to set
                 */
                function SimulationList(properties) {
                    this.values = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SimulationList values.
                 * @member {Array.<havocai.messages.v0.ISimulation>} values
                 * @memberof havocai.messages.v0.SimulationList
                 * @instance
                 */
                SimulationList.prototype.values = $util.emptyArray;

                /**
                 * Creates a new SimulationList instance using the specified properties.
                 * @function create
                 * @memberof havocai.messages.v0.SimulationList
                 * @static
                 * @param {havocai.messages.v0.ISimulationList=} [properties] Properties to set
                 * @returns {havocai.messages.v0.SimulationList} SimulationList instance
                 */
                SimulationList.create = function create(properties) {
                    return new SimulationList(properties);
                };

                /**
                 * Encodes the specified SimulationList message. Does not implicitly {@link havocai.messages.v0.SimulationList.verify|verify} messages.
                 * @function encode
                 * @memberof havocai.messages.v0.SimulationList
                 * @static
                 * @param {havocai.messages.v0.ISimulationList} message SimulationList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SimulationList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (let i = 0; i < message.values.length; ++i)
                            $root.havocai.messages.v0.Simulation.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SimulationList message, length delimited. Does not implicitly {@link havocai.messages.v0.SimulationList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof havocai.messages.v0.SimulationList
                 * @static
                 * @param {havocai.messages.v0.ISimulationList} message SimulationList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SimulationList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SimulationList message from the specified reader or buffer.
                 * @function decode
                 * @memberof havocai.messages.v0.SimulationList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {havocai.messages.v0.SimulationList} SimulationList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SimulationList.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.havocai.messages.v0.SimulationList();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.values && message.values.length))
                                    message.values = [];
                                message.values.push($root.havocai.messages.v0.Simulation.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SimulationList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof havocai.messages.v0.SimulationList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {havocai.messages.v0.SimulationList} SimulationList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SimulationList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SimulationList message.
                 * @function verify
                 * @memberof havocai.messages.v0.SimulationList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SimulationList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (let i = 0; i < message.values.length; ++i) {
                            let error = $root.havocai.messages.v0.Simulation.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SimulationList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof havocai.messages.v0.SimulationList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {havocai.messages.v0.SimulationList} SimulationList
                 */
                SimulationList.fromObject = function fromObject(object) {
                    if (object instanceof $root.havocai.messages.v0.SimulationList)
                        return object;
                    let message = new $root.havocai.messages.v0.SimulationList();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".havocai.messages.v0.SimulationList.values: array expected");
                        message.values = [];
                        for (let i = 0; i < object.values.length; ++i) {
                            if (typeof object.values[i] !== "object")
                                throw TypeError(".havocai.messages.v0.SimulationList.values: object expected");
                            message.values[i] = $root.havocai.messages.v0.Simulation.fromObject(object.values[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SimulationList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof havocai.messages.v0.SimulationList
                 * @static
                 * @param {havocai.messages.v0.SimulationList} message SimulationList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SimulationList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (let j = 0; j < message.values.length; ++j)
                            object.values[j] = $root.havocai.messages.v0.Simulation.toObject(message.values[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SimulationList to JSON.
                 * @function toJSON
                 * @memberof havocai.messages.v0.SimulationList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SimulationList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SimulationList
                 * @function getTypeUrl
                 * @memberof havocai.messages.v0.SimulationList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SimulationList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/havocai.messages.v0.SimulationList";
                };

                return SimulationList;
            })();

            return v0;
        })();

        return messages;
    })();

    return havocai;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {number|Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */

            /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */
            Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.seconds = reader.int64();
                            break;
                        }
                    case 2: {
                            message.nanos = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp)
                    return object;
                let message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Timestamp to JSON.
             * @function toJSON
             * @memberof google.protobuf.Timestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Timestamp
             * @function getTypeUrl
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Timestamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Timestamp";
            };

            return Timestamp;
        })();

        return protobuf;
    })();

    return google;
})();

export { $root as default };
